<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IV Surface</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#172033',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Loading animation */
        @keyframes pulse-border {
            0%, 100% { border-color: rgba(59, 130, 246, 0.5); }
            50% { border-color: rgba(59, 130, 246, 1); }
        }
        .loading { animation: pulse-border 1.5s ease-in-out infinite; }

        /* Plotly responsive */
        .js-plotly-plot { width: 100% !important; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen">
    <!-- Mobile-first layout -->
    <div class="flex flex-col lg:flex-row min-h-screen">

        <!-- Sidebar - collapsible on mobile -->
        <aside id="sidebar" class="w-full lg:w-64 bg-slate-850 border-b lg:border-b-0 lg:border-r border-slate-700 flex-shrink-0">
            <div class="p-4">
                <!-- Logo -->
                <div class="flex items-center gap-2 mb-6">
                    <div class="w-8 h-8 bg-blue-500 rounded-lg flex items-center justify-center">
                        <span class="text-white font-bold text-sm">IV</span>
                    </div>
                    <span class="font-semibold text-lg">IV Surface</span>
                </div>

                <!-- Cached symbols -->
                <div class="hidden lg:block">
                    <h3 class="text-xs uppercase text-slate-500 font-medium mb-2">Cached</h3>
                    <div id="cached-list" class="space-y-1">
                        {% for item in cached_symbols %}
                        <button
                            onclick="loadSymbol('{{ item.symbol }}')"
                            class="w-full text-left px-3 py-2 rounded-lg hover:bg-slate-700 transition-colors flex justify-between items-center group"
                        >
                            <span class="font-medium">{{ item.symbol }}</span>
                            <span class="text-xs text-slate-500 group-hover:text-slate-400">
                                {% if item.age_minutes %}{{ item.age_minutes }}m{% endif %}
                            </span>
                        </button>
                        {% else %}
                        <p class="text-slate-500 text-sm px-3 py-2">No cached symbols</p>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main content -->
        <main class="flex-1 flex flex-col min-h-0">
            <!-- Header with search -->
            <header class="p-4 border-b border-slate-700 bg-slate-850">
                <div class="flex flex-col sm:flex-row gap-3 items-stretch sm:items-center">
                    <!-- Search input -->
                    <div class="flex-1 relative">
                        <input
                            type="text"
                            id="symbol-input"
                            placeholder="Enter symbol (e.g., AAPL, SPY)"
                            class="w-full bg-slate-800 border border-slate-600 rounded-lg px-4 py-2.5 text-sm
                                   focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent
                                   placeholder-slate-500"
                            onkeydown="if(event.key === 'Enter') loadSymbol(this.value)"
                        >
                    </div>

                    <!-- Action buttons -->
                    <div class="flex gap-2">
                        <button
                            onclick="loadSymbol(document.getElementById('symbol-input').value)"
                            class="px-4 py-2.5 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm font-medium
                                   transition-colors flex items-center gap-2"
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                            </svg>
                            <span class="hidden sm:inline">Load</span>
                        </button>
                        <button
                            onclick="refreshSurface()"
                            id="refresh-btn"
                            class="px-4 py-2.5 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium
                                   transition-colors disabled:opacity-50"
                            disabled
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Tabs -->
                <div class="flex gap-1 mt-4 overflow-x-auto" id="tabs">
                    <button onclick="switchTab('surface')" id="tab-surface"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors
                                   bg-slate-700 text-white whitespace-nowrap">
                        IV Surface
                    </button>
                    <button onclick="switchTab('equity')" id="tab-equity"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors
                                   text-slate-400 hover:text-white hover:bg-slate-700 whitespace-nowrap">
                        Equity
                    </button>
                    <button onclick="switchTab('vol')" id="tab-vol"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors
                                   text-slate-400 hover:text-white hover:bg-slate-700 whitespace-nowrap">
                        Vol Analysis
                    </button>
                    <!-- Surface controls - only visible when surface tab active -->
                    <div id="surface-controls" class="hidden ml-auto flex items-center gap-3 flex-wrap">
                        <!-- Option type toggle -->
                        <div class="flex items-center gap-2">
                            <span class="text-xs text-slate-500 uppercase">Type:</span>
                            <button onclick="toggleOptionType('put')" id="btn-put"
                                    class="px-3 py-1.5 rounded text-xs font-medium transition-colors bg-red-600 text-white">
                                Puts
                            </button>
                            <button onclick="toggleOptionType('call')" id="btn-call"
                                    class="px-3 py-1.5 rounded text-xs font-medium transition-colors bg-slate-700 text-slate-300 hover:bg-slate-600">
                                Calls
                            </button>
                        </div>
                        <div class="w-px h-6 bg-slate-600"></div>
                        <!-- X-axis toggle -->
                        <div class="flex items-center gap-2">
                            <span class="text-xs text-slate-500 uppercase">X-Axis:</span>
                            <button onclick="toggleXAxis('moneyness')" id="btn-moneyness"
                                    class="px-3 py-1.5 rounded text-xs font-medium transition-colors bg-blue-600 text-white">
                                Moneyness
                            </button>
                            <button onclick="toggleXAxis('strike')" id="btn-strike"
                                    class="px-3 py-1.5 rounded text-xs font-medium transition-colors bg-slate-700 text-slate-300 hover:bg-slate-600">
                                Strike
                            </button>
                        </div>
                        <div class="w-px h-6 bg-slate-600"></div>
                        <!-- Moneyness filter -->
                        <div class="flex items-center gap-2">
                            <button onclick="toggleFilter()" id="btn-filter"
                                    class="px-3 py-1.5 rounded text-xs font-medium transition-colors bg-slate-700 text-slate-300 hover:bg-slate-600"
                                    title="Filter by moneyness range">
                                K/S
                            </button>
                            <div id="filter-inputs" class="hidden flex items-center gap-1">
                                <input type="number" id="filter-min" step="0.05" min="0.5" max="1.5"
                                       class="w-14 bg-slate-700 border-0 rounded px-2 py-1 text-xs text-center"
                                       onchange="updateFilter()">
                                <span class="text-slate-500">-</span>
                                <input type="number" id="filter-max" step="0.05" min="0.5" max="1.5"
                                       class="w-14 bg-slate-700 border-0 rounded px-2 py-1 text-xs text-center"
                                       onchange="updateFilter()">
                            </div>
                        </div>
                        <!-- IV outlier filter -->
                        <div class="flex items-center gap-2">
                            <button onclick="toggleIvFilter()" id="btn-iv-filter"
                                    class="px-3 py-1.5 rounded text-xs font-medium transition-colors bg-slate-700 text-slate-300 hover:bg-slate-600"
                                    title="Filter IV outliers">
                                IV%
                            </button>
                            <div id="iv-filter-inputs" class="hidden flex items-center gap-1">
                                <input type="number" id="iv-filter-min" step="5" min="0" max="200"
                                       class="w-14 bg-slate-700 border-0 rounded px-2 py-1 text-xs text-center"
                                       onchange="updateIvFilter()">
                                <span class="text-slate-500">-</span>
                                <input type="number" id="iv-filter-max" step="5" min="0" max="500"
                                       class="w-14 bg-slate-700 border-0 rounded px-2 py-1 text-xs text-center"
                                       onchange="updateIvFilter()">
                            </div>
                        </div>
                    </div>
                </div>
            </header>

            <!-- Content area -->
            <div class="flex-1 p-4 overflow-auto">
                <!-- Landing state -->
                <div id="landing" class="h-full flex items-center justify-center">
                    <div class="text-center max-w-md px-4">
                        <div class="w-16 h-16 bg-slate-800 rounded-2xl flex items-center justify-center mx-auto mb-6">
                            <svg class="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                      d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                            </svg>
                        </div>
                        <h2 class="text-xl font-semibold mb-2">Welcome to IV Surface</h2>
                        <p class="text-slate-400 mb-6">
                            Enter a symbol above to compute and visualize its implied volatility surface.
                        </p>
                        <div class="flex flex-wrap gap-2 justify-center">
                            <button onclick="loadSymbol('SPY')"
                                    class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 rounded-lg text-sm transition-colors">
                                SPY
                            </button>
                            <button onclick="loadSymbol('AAPL')"
                                    class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 rounded-lg text-sm transition-colors">
                                AAPL
                            </button>
                            <button onclick="loadSymbol('TSLA')"
                                    class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 rounded-lg text-sm transition-colors">
                                TSLA
                            </button>
                            <button onclick="loadSymbol('NVDA')"
                                    class="px-3 py-1.5 bg-slate-800 hover:bg-slate-700 rounded-lg text-sm transition-colors">
                                NVDA
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Loading state -->
                <div id="loading" class="hidden h-full flex items-center justify-center">
                    <div class="text-center">
                        <div class="w-12 h-12 border-4 border-slate-700 border-t-blue-500 rounded-full animate-spin mx-auto mb-4"></div>
                        <p class="text-slate-400" id="loading-text">Computing IV surface...</p>
                    </div>
                </div>

                <!-- Surface tab -->
                <div id="content-surface" class="hidden h-full flex items-start justify-center">
                    <div class="w-full max-w-6xl">
                        <div id="surface-plot" class="w-full" style="aspect-ratio: 4/3; max-height: 75vh; min-height: 400px;"></div>
                    </div>
                </div>

                <!-- Equity tab -->
                <div id="content-equity" class="hidden h-full flex items-start justify-center">
                    <div class="w-full max-w-6xl">
                        <div id="equity-plot" class="w-full" style="aspect-ratio: 16/9; max-height: 70vh;"></div>
                    </div>
                </div>

                <!-- Vol analysis tab -->
                <div id="content-vol" class="hidden h-full flex items-start justify-center">
                    <div class="w-full max-w-6xl">
                        <div class="grid gap-4 lg:grid-cols-2">
                            <!-- Vol comparison chart -->
                            <div class="bg-slate-800 rounded-xl p-4">
                                <h3 class="font-medium mb-4">GARCH Volatility Forecast</h3>
                                <div id="vol-plot" style="aspect-ratio: 16/10; max-height: 50vh; min-height: 200px;"></div>
                            </div>

                            <!-- Stats cards -->
                            <div class="space-y-4">
                                <div class="bg-slate-800 rounded-xl p-4">
                                    <h3 class="font-medium mb-3">Realized Volatility</h3>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div>
                                            <p class="text-xs text-slate-500 uppercase">20-Day</p>
                                            <p class="text-2xl font-semibold" id="rv-20">--</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-slate-500 uppercase">60-Day</p>
                                            <p class="text-2xl font-semibold" id="rv-60">--</p>
                                        </div>
                                    </div>
                                </div>

                                <div class="bg-slate-800 rounded-xl p-4">
                                    <h3 class="font-medium mb-3">GARCH Forecast</h3>
                                    <div class="flex items-center gap-2 mb-3">
                                        <select id="garch-model" onchange="updateVolAnalysis()"
                                                class="bg-slate-700 border-0 rounded-lg px-3 py-1.5 text-sm">
                                            <option value="gjr">GJR-GARCH</option>
                                            <option value="garch">GARCH(1,1)</option>
                                            <option value="egarch">EGARCH</option>
                                        </select>
                                    </div>
                                    <div>
                                        <p class="text-xs text-slate-500 uppercase">Current Vol</p>
                                        <p class="text-2xl font-semibold" id="garch-current">--</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status bar -->
            <footer class="px-4 py-2 border-t border-slate-700 bg-slate-850 text-xs text-slate-500">
                <div class="flex flex-wrap gap-x-4 gap-y-1 items-center justify-between">
                    <div class="flex gap-4">
                        <span id="status-spot">Spot: --</span>
                        <span id="status-rate">Rate: 5.0%</span>
                        <span id="status-type">Puts</span>
                    </div>
                    <span id="status-time">--</span>
                </div>
            </footer>
        </main>
    </div>

    <script>
        // State - use window scope for accessibility from onclick handlers
        window.currentSymbol = null;
        window.currentTab = 'surface';
        window.surfaceData = null;  // Full data with both put/call surfaces
        window.equityData = null;
        window.volData = null;
        window.xAxisMode = 'moneyness';  // 'moneyness' or 'strike'
        window.optionType = 'put';  // 'put' or 'call'
        window.eventSource = null;  // SSE connection for streaming
        window.isStreaming = false;
        window.surfacePlotInitialized = false;  // Track if plot exists for react() vs newPlot()
        window.savedCamera = null;  // Store camera position to preserve across re-renders

        // Filter settings - moneyness
        window.filterEnabled = false;
        window.filterMoneyMin = 0.8;
        window.filterMoneyMax = 1.2;
        window.autoFilterBounds = { min: 0.8, max: 1.2 };  // Auto-estimated bounds

        // Filter settings - IV outliers
        window.ivFilterEnabled = false;
        window.ivFilterMin = 10;   // Min IV in %
        window.ivFilterMax = 100;  // Max IV in %
        window.autoIvBounds = { min: 10, max: 100 };

        // Tab switching
        function switchTab(tab) {
            window.currentTab = tab;

            // Update tab buttons (only the main tab buttons, not the axis buttons)
            ['tab-surface', 'tab-equity', 'tab-vol'].forEach(id => {
                const btn = document.getElementById(id);
                btn.classList.remove('bg-slate-700', 'text-white');
                btn.classList.add('text-slate-400');
            });
            document.getElementById(`tab-${tab}`).classList.remove('text-slate-400');
            document.getElementById(`tab-${tab}`).classList.add('bg-slate-700', 'text-white');

            // Show/hide content
            document.querySelectorAll('[id^="content-"]').forEach(el => el.classList.add('hidden'));
            const content = document.getElementById(`content-${tab}`);
            if (content) content.classList.remove('hidden');

            // Show/hide surface controls
            const controls = document.getElementById('surface-controls');
            if (tab === 'surface' && window.surfaceData) {
                controls.classList.remove('hidden');
            } else {
                controls.classList.add('hidden');
            }

            // Resize plots on tab switch
            setTimeout(() => {
                Plotly.Plots.resize(document.getElementById('surface-plot'));
                Plotly.Plots.resize(document.getElementById('equity-plot'));
                Plotly.Plots.resize(document.getElementById('vol-plot'));
            }, 100);
        }

        // Toggle X-axis between moneyness and strike
        function toggleXAxis(mode) {
            window.xAxisMode = mode;

            // Update button styles
            const mBtn = document.getElementById('btn-moneyness');
            const sBtn = document.getElementById('btn-strike');

            if (mode === 'moneyness') {
                mBtn.classList.remove('bg-slate-700', 'text-slate-300');
                mBtn.classList.add('bg-blue-600', 'text-white');
                sBtn.classList.remove('bg-blue-600', 'text-white');
                sBtn.classList.add('bg-slate-700', 'text-slate-300');
            } else {
                sBtn.classList.remove('bg-slate-700', 'text-slate-300');
                sBtn.classList.add('bg-blue-600', 'text-white');
                mBtn.classList.remove('bg-blue-600', 'text-white');
                mBtn.classList.add('bg-slate-700', 'text-slate-300');
            }

            // Re-render surface
            if (window.surfaceData) {
                renderSurface(window.surfaceData);
            }
        }

        // Toggle option type between puts and calls
        function toggleOptionType(type) {
            window.optionType = type;

            // Update button styles
            const pBtn = document.getElementById('btn-put');
            const cBtn = document.getElementById('btn-call');

            if (type === 'put') {
                pBtn.classList.remove('bg-slate-700', 'text-slate-300');
                pBtn.classList.add('bg-red-600', 'text-white');
                cBtn.classList.remove('bg-green-600', 'text-white');
                cBtn.classList.add('bg-slate-700', 'text-slate-300');
            } else {
                cBtn.classList.remove('bg-slate-700', 'text-slate-300');
                cBtn.classList.add('bg-green-600', 'text-white');
                pBtn.classList.remove('bg-red-600', 'text-white');
                pBtn.classList.add('bg-slate-700', 'text-slate-300');
            }

            // Update status bar
            document.getElementById('status-type').textContent = type === 'put' ? 'Puts' : 'Calls';

            // Use cached data if available (no re-fetch needed!)
            if (window.surfaceData && window.surfaceData.surfaces) {
                renderSurface(window.surfaceData);
            }
        }

        // Toggle filter visibility
        function toggleFilter() {
            window.filterEnabled = !window.filterEnabled;
            const btn = document.getElementById('btn-filter');
            const inputs = document.getElementById('filter-inputs');

            if (window.filterEnabled) {
                btn.classList.remove('bg-slate-700', 'text-slate-300');
                btn.classList.add('bg-purple-600', 'text-white');
                inputs.classList.remove('hidden');
                // Initialize inputs with current values
                document.getElementById('filter-min').value = window.filterMoneyMin;
                document.getElementById('filter-max').value = window.filterMoneyMax;
            } else {
                btn.classList.remove('bg-purple-600', 'text-white');
                btn.classList.add('bg-slate-700', 'text-slate-300');
                inputs.classList.add('hidden');
            }

            // Re-render with/without filter
            if (window.surfaceData) {
                renderSurface(window.surfaceData);
            }
        }

        // Update filter values from inputs
        function updateFilter() {
            window.filterMoneyMin = parseFloat(document.getElementById('filter-min').value) || 0.8;
            window.filterMoneyMax = parseFloat(document.getElementById('filter-max').value) || 1.2;

            if (window.surfaceData) {
                renderSurface(window.surfaceData);
            }
        }

        // Auto-estimate filter bounds based on data (IQR-based)
        function estimateFilterBounds(surface) {
            if (!surface || !surface.moneyness) return { min: 0.8, max: 1.2 };

            const moneyness = [...surface.moneyness].sort((a, b) => a - b);
            const n = moneyness.length;

            // Use IQR to estimate reasonable range
            const q1 = moneyness[Math.floor(n * 0.25)];
            const q3 = moneyness[Math.floor(n * 0.75)];
            const iqr = q3 - q1;

            // Expand slightly beyond IQR for a reasonable range
            let min = Math.max(0.5, q1 - 0.5 * iqr);
            let max = Math.min(1.5, q3 + 0.5 * iqr);

            // Round to nearest 0.05
            min = Math.round(min * 20) / 20;
            max = Math.round(max * 20) / 20;

            // Ensure range includes ATM
            if (min > 1.0) min = 0.95;
            if (max < 1.0) max = 1.05;

            return { min, max };
        }

        // Apply auto-estimated filter bounds
        function applyAutoFilter() {
            const surface = window.surfaceData?.surfaces?.[window.optionType] || window.surfaceData?.surface;
            if (surface) {
                const bounds = estimateFilterBounds(surface);
                window.filterMoneyMin = bounds.min;
                window.filterMoneyMax = bounds.max;
                window.autoFilterBounds = bounds;

                // Update inputs if they exist
                const minInput = document.getElementById('filter-min');
                const maxInput = document.getElementById('filter-max');
                if (minInput) minInput.value = bounds.min;
                if (maxInput) maxInput.value = bounds.max;

                // Re-render
                renderSurface(window.surfaceData);
            }
        }

        // Toggle IV filter visibility
        function toggleIvFilter() {
            window.ivFilterEnabled = !window.ivFilterEnabled;
            const btn = document.getElementById('btn-iv-filter');
            const inputs = document.getElementById('iv-filter-inputs');

            if (window.ivFilterEnabled) {
                btn.classList.remove('bg-slate-700', 'text-slate-300');
                btn.classList.add('bg-purple-600', 'text-white');
                inputs.classList.remove('hidden');
                document.getElementById('iv-filter-min').value = window.ivFilterMin;
                document.getElementById('iv-filter-max').value = window.ivFilterMax;
            } else {
                btn.classList.remove('bg-purple-600', 'text-white');
                btn.classList.add('bg-slate-700', 'text-slate-300');
                inputs.classList.add('hidden');
            }

            if (window.surfaceData) {
                renderSurface(window.surfaceData);
            }
        }

        // Update IV filter values from inputs
        function updateIvFilter() {
            window.ivFilterMin = parseFloat(document.getElementById('iv-filter-min').value) || 10;
            window.ivFilterMax = parseFloat(document.getElementById('iv-filter-max').value) || 100;

            if (window.surfaceData) {
                renderSurface(window.surfaceData);
            }
        }

        // Auto-estimate IV filter bounds (IQR-based to remove outliers)
        function estimateIvFilterBounds(surface) {
            if (!surface || !surface.ivs) return { min: 10, max: 100 };

            // Convert to percentage and sort
            const ivs = surface.ivs.map(iv => iv * 100).sort((a, b) => a - b);
            const n = ivs.length;

            // Use IQR to detect outliers
            const q1 = ivs[Math.floor(n * 0.25)];
            const q3 = ivs[Math.floor(n * 0.75)];
            const iqr = q3 - q1;

            // Standard outlier bounds: Q1 - 1.5*IQR to Q3 + 1.5*IQR
            let min = Math.max(5, q1 - 1.5 * iqr);
            let max = q3 + 1.5 * iqr;

            // Round to nearest 5%
            min = Math.round(min / 5) * 5;
            max = Math.round(max / 5) * 5;

            return { min, max };
        }

        // Auto-apply filter when data loads (enables filter + estimates bounds)
        function autoApplyFilter() {
            const surface = window.surfaceData?.surfaces?.[window.optionType] || window.surfaceData?.surface;
            if (surface) {
                // Enable moneyness filter automatically
                window.filterEnabled = true;
                const bounds = estimateFilterBounds(surface);
                window.filterMoneyMin = bounds.min;
                window.filterMoneyMax = bounds.max;
                window.autoFilterBounds = bounds;

                // Update moneyness filter UI
                const btn = document.getElementById('btn-filter');
                const inputs = document.getElementById('filter-inputs');
                if (btn) {
                    btn.classList.remove('bg-slate-700', 'text-slate-300');
                    btn.classList.add('bg-purple-600', 'text-white');
                }
                if (inputs) {
                    inputs.classList.remove('hidden');
                    document.getElementById('filter-min').value = bounds.min;
                    document.getElementById('filter-max').value = bounds.max;
                }

                // Enable IV filter automatically
                window.ivFilterEnabled = true;
                const ivBounds = estimateIvFilterBounds(surface);
                window.ivFilterMin = ivBounds.min;
                window.ivFilterMax = ivBounds.max;
                window.autoIvBounds = ivBounds;

                // Update IV filter UI
                const ivBtn = document.getElementById('btn-iv-filter');
                const ivInputs = document.getElementById('iv-filter-inputs');
                if (ivBtn) {
                    ivBtn.classList.remove('bg-slate-700', 'text-slate-300');
                    ivBtn.classList.add('bg-purple-600', 'text-white');
                }
                if (ivInputs) {
                    ivInputs.classList.remove('hidden');
                    document.getElementById('iv-filter-min').value = ivBounds.min;
                    document.getElementById('iv-filter-max').value = ivBounds.max;
                }
            }
        }

        // Update progress indicator
        function updateProgress(current, total, expiration) {
            const loadingText = document.getElementById('loading-text');
            if (loadingText) {
                const pct = Math.round((current / total) * 100);
                loadingText.textContent = `Computing IV: ${pct}% (${expiration})`;
            }
        }

        // Load surface data using SSE for streaming
        function loadSurfaceDataStreaming(symbol) {
            // Close any existing connection
            if (window.eventSource) {
                window.eventSource.close();
            }

            window.isStreaming = true;
            const plotEl = document.getElementById('surface-plot');

            window.eventSource = new EventSource(`/api/surface/${symbol}/stream`);

            window.eventSource.addEventListener('metadata', (e) => {
                const data = JSON.parse(e.data);
                window.surfaceData = {
                    symbol: data.symbol,
                    spot: data.spot,
                    quote_time: data.quote_time,
                    is_eod: data.is_eod,
                    surfaces: { put: null, call: null },
                };
                document.getElementById('status-spot').textContent = `Spot: $${data.spot.toFixed(2)}`;
                document.getElementById('status-time').textContent = data.is_eod ? 'EOD' : 'Live';
                document.getElementById('loading-text').textContent = `Loading ${data.total_expirations} expirations...`;
            });

            window.eventSource.addEventListener('progress', (e) => {
                const data = JSON.parse(e.data);
                updateProgress(data.index, data.total, data.expiration);

                // Update surfaces for progressive rendering
                if (data.surfaces) {
                    window.surfaceData.surfaces = data.surfaces;
                    // Re-render with current data (progressive update)
                    if (data.index % 3 === 0 || data.index === data.total) {
                        // Only render every 3rd update to avoid too much redraw
                        renderSurface(window.surfaceData);
                    }
                }
            });

            window.eventSource.addEventListener('complete', (e) => {
                const data = JSON.parse(e.data);
                window.surfaceData = {
                    symbol: data.symbol,
                    spot: data.spot,
                    surfaces: data.surfaces,
                    stats: data.stats,
                    is_eod: window.surfaceData?.is_eod,
                    quote_time: window.surfaceData?.quote_time,
                };

                window.eventSource.close();
                window.eventSource = null;
                window.isStreaming = false;

                // Auto-apply filter on new data load
                autoApplyFilter();

                // Final render
                renderSurface(window.surfaceData);

                // Hide loading, show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('surface-controls').classList.remove('hidden');
                switchTab('surface');

                // Load equity and vol data in background
                loadEquityData(symbol);
                loadVolData(symbol);
            });

            window.eventSource.addEventListener('error', (e) => {
                const data = e.data ? JSON.parse(e.data) : { error: 'Connection lost' };
                console.error('Stream error:', data);
                window.eventSource.close();
                window.eventSource = null;
                window.isStreaming = false;
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('landing').classList.remove('hidden');
                alert(`Error: ${data.error || 'Connection lost'}`);
            });

            window.eventSource.onerror = () => {
                if (window.isStreaming) {
                    console.error('EventSource connection error');
                    window.eventSource.close();
                    window.eventSource = null;
                    window.isStreaming = false;
                }
            };
        }

        // Load surface data (non-streaming fallback, also used for quick reload)
        async function loadSurfaceData(symbol, forceRefresh = false) {
            // If we already have data for this symbol and not forcing refresh, just re-render
            if (!forceRefresh && window.surfaceData && window.surfaceData.symbol === symbol) {
                renderSurface(window.surfaceData);
                return;
            }

            // Show loading state on the plot
            const plotEl = document.getElementById('surface-plot');
            plotEl.style.opacity = '0.5';

            try {
                const response = await fetch(`/api/surface/${symbol}`);
                window.surfaceData = await response.json();

                if (window.surfaceData.error) {
                    throw new Error(window.surfaceData.error);
                }

                // Update status bar
                document.getElementById('status-spot').textContent = `Spot: $${window.surfaceData.spot.toFixed(2)}`;
                document.getElementById('status-time').textContent = window.surfaceData.is_eod ? 'EOD' : 'Live';

                // Render surface
                renderSurface(window.surfaceData);

            } catch (error) {
                console.error('Failed to load surface:', error);
                alert(`Error: ${error.message}`);
            } finally {
                // Restore opacity
                plotEl.style.opacity = '1';
            }
        }

        // Load symbol - uses streaming for progressive rendering
        async function loadSymbol(symbol, useStreaming = true) {
            if (!symbol) return;
            symbol = symbol.toUpperCase().trim();

            // Check if we already have fresh data for this symbol
            if (window.surfaceData && window.surfaceData.symbol === symbol && !window.isStreaming) {
                // Already have data, just show it
                document.getElementById('symbol-input').value = symbol;
                document.getElementById('refresh-btn').disabled = false;
                document.getElementById('landing').classList.add('hidden');
                document.getElementById('surface-controls').classList.remove('hidden');
                switchTab('surface');
                renderSurface(window.surfaceData);
                return;
            }

            window.currentSymbol = symbol;
            document.getElementById('symbol-input').value = symbol;
            document.getElementById('refresh-btn').disabled = false;

            // Show loading
            document.getElementById('landing').classList.add('hidden');
            document.getElementById('loading').classList.remove('hidden');
            document.querySelectorAll('[id^="content-"]').forEach(el => el.classList.add('hidden'));

            document.getElementById('loading-text').textContent = 'Fetching option chain...';
            document.getElementById('status-type').textContent = window.optionType === 'put' ? 'Puts' : 'Calls';

            if (useStreaming) {
                // Use SSE for progressive loading
                loadSurfaceDataStreaming(symbol);
            } else {
                // Use regular fetch (fallback)
                try {
                    const response = await fetch(`/api/surface/${symbol}`);
                    window.surfaceData = await response.json();

                    if (window.surfaceData.error) {
                        throw new Error(window.surfaceData.error);
                    }

                    // Update status bar
                    document.getElementById('status-spot').textContent = `Spot: $${window.surfaceData.spot.toFixed(2)}`;
                    document.getElementById('status-time').textContent = window.surfaceData.is_eod ? 'EOD' : 'Live';

                    // Render surface
                    renderSurface(window.surfaceData);

                    // Show surface tab and controls
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('surface-controls').classList.remove('hidden');
                    switchTab('surface');

                    // Load equity and vol data in background
                    loadEquityData(symbol);
                    loadVolData(symbol);

                } catch (error) {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('landing').classList.remove('hidden');
                    alert(`Error: ${error.message}`);
                }
            }
        }

        // Polynomial surface fitting using least squares
        // Model: IV = a0 + a1*x + a2*x² + a3*y + a4*y² + a5*x*y + a6*x²*y + a7*x*y² + a8*x³ + a9*y³
        function fitPolynomialSurface(xData, yData, zData) {
            const n = xData.length;
            if (n < 10) {
                // Not enough data, return simple average
                const avgZ = zData.reduce((a, b) => a + b, 0) / n;
                return [avgZ, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            }

            // Normalize x and y for numerical stability
            const xMean = xData.reduce((a, b) => a + b, 0) / n;
            const yMean = yData.reduce((a, b) => a + b, 0) / n;
            const xStd = Math.sqrt(xData.reduce((a, b) => a + (b - xMean) ** 2, 0) / n) || 1;
            const yStd = Math.sqrt(yData.reduce((a, b) => a + (b - yMean) ** 2, 0) / n) || 1;

            // Build design matrix A and target vector b
            const numCoeffs = 10;
            const A = [];
            const b = [];

            for (let i = 0; i < n; i++) {
                const x = (xData[i] - xMean) / xStd;
                const y = (yData[i] - yMean) / yStd;
                // Basis: [1, x, x², y, y², xy, x²y, xy², x³, y³]
                A.push([1, x, x*x, y, y*y, x*y, x*x*y, x*y*y, x*x*x, y*y*y]);
                b.push(zData[i]);
            }

            // Solve normal equations: (A^T A) coeffs = A^T b
            const ATA = Array(numCoeffs).fill(0).map(() => Array(numCoeffs).fill(0));
            const ATb = Array(numCoeffs).fill(0);

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < numCoeffs; j++) {
                    ATb[j] += A[i][j] * b[i];
                    for (let k = 0; k < numCoeffs; k++) {
                        ATA[j][k] += A[i][j] * A[i][k];
                    }
                }
            }

            // Add ridge regularization for stability
            const lambda = 0.01;
            for (let i = 0; i < numCoeffs; i++) {
                ATA[i][i] += lambda;
            }

            // Solve using Gaussian elimination with partial pivoting
            const coeffsNorm = solveLinearSystem(ATA, ATb);

            // Store normalization parameters with coefficients
            return { coeffs: coeffsNorm, xMean, yMean, xStd, yStd };
        }

        // Solve linear system Ax = b using Gaussian elimination
        function solveLinearSystem(A, b) {
            const n = b.length;
            const aug = A.map((row, i) => [...row, b[i]]);

            for (let col = 0; col < n; col++) {
                // Partial pivoting
                let maxRow = col;
                for (let row = col + 1; row < n; row++) {
                    if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
                        maxRow = row;
                    }
                }
                [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];

                if (Math.abs(aug[col][col]) < 1e-10) continue;

                // Eliminate
                for (let row = col + 1; row < n; row++) {
                    const factor = aug[row][col] / aug[col][col];
                    for (let j = col; j <= n; j++) {
                        aug[row][j] -= factor * aug[col][j];
                    }
                }
            }

            // Back substitution
            const x = Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = aug[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= aug[i][j] * x[j];
                }
                x[i] /= aug[i][i] || 1;
            }
            return x;
        }

        // Evaluate polynomial at point (x, y)
        function evaluatePolynomial(fit, xRaw, yRaw) {
            if (Array.isArray(fit)) {
                // Simple coefficients (fallback)
                return fit[0];
            }
            const { coeffs, xMean, yMean, xStd, yStd } = fit;
            const x = (xRaw - xMean) / xStd;
            const y = (yRaw - yMean) / yStd;
            // Basis: [1, x, x², y, y², xy, x²y, xy², x³, y³]
            return coeffs[0] + coeffs[1]*x + coeffs[2]*x*x + coeffs[3]*y + coeffs[4]*y*y +
                   coeffs[5]*x*y + coeffs[6]*x*x*y + coeffs[7]*x*y*y + coeffs[8]*x*x*x + coeffs[9]*y*y*y;
        }

        // Render 3D surface
        function renderSurface(data) {
            // Support both old format (data.surface) and new format (data.surfaces.put/call)
            let surface;
            if (data.surfaces) {
                // New format: pick put or call based on current option type
                surface = data.surfaces[window.optionType];
            } else if (data.surface) {
                // Old format: single surface
                surface = data.surface;
            }

            if (!surface || !surface.ivs || surface.ivs.length === 0) {
                console.log('No surface data to render');
                return;
            }

            const spot = data.spot;

            // Apply filters (moneyness and IV)
            let filteredIndices = [];
            for (let i = 0; i < surface.ivs.length; i++) {
                // Check moneyness filter
                if (window.filterEnabled && surface.moneyness) {
                    const m = surface.moneyness[i];
                    if (m < window.filterMoneyMin || m > window.filterMoneyMax) {
                        continue;  // Skip - outside moneyness range
                    }
                }
                // Check IV filter (ivs are in decimal form, e.g., 0.5 = 50%)
                if (window.ivFilterEnabled && surface.ivs) {
                    const ivPct = surface.ivs[i] * 100;
                    if (ivPct < window.ivFilterMin || ivPct > window.ivFilterMax) {
                        continue;  // Skip - IV outlier
                    }
                }
                filteredIndices.push(i);
            }

            // Build filtered arrays
            const filteredMoneyness = filteredIndices.map(i => surface.moneyness[i]);
            const filteredStrikes = filteredIndices.map(i => surface.strikes[i]);
            const filteredMaturities = filteredIndices.map(i => surface.maturities_days?.[i] || Math.round(surface.maturities[i] * 365));
            const filteredIvs = filteredIndices.map(i => surface.ivs[i]);

            if (filteredIvs.length === 0) {
                console.log('No data after filtering');
                return;
            }

            // Choose X-axis data based on mode
            const xData = window.xAxisMode === 'moneyness' ? filteredMoneyness : filteredStrikes;
            const xLabel = window.xAxisMode === 'moneyness' ? 'Moneyness (K/S)' : `Strike ($)`;
            const atmValue = window.xAxisMode === 'moneyness' ? 1.0 : spot;

            // Use days for maturity (Y-axis)
            const yData = filteredMaturities;

            // Convert IVs to percentage for z-axis
            const zData = filteredIvs.map(iv => iv * 100);

            // Fit polynomial regression surface for smoothness
            // Model: IV = a0 + a1*x + a2*x² + a3*y + a4*y² + a5*x*y + a6*x²*y + a7*x*y²
            const coeffs = fitPolynomialSurface(xData, yData, zData);

            // Create regular grid for smooth surface - extend beyond data bounds
            const xMinData = Math.min(...xData);
            const xMaxData = Math.max(...xData);
            const yMinData = Math.min(...yData);
            const yMaxData = Math.max(...yData);

            // Extend grid beyond data bounds for visual continuity
            const xRange = xMaxData - xMinData;
            const yRange = yMaxData - yMinData;
            const xMin = xMinData - xRange * 0.1;
            const xMax = xMaxData + xRange * 0.1;
            const yMin = yMinData - yRange * 0.15;  // Extend into negative for visual continuity
            const yMax = yMaxData + yRange * 0.15;

            const gridSize = 40;  // Resolution of the smooth surface
            const gridX = [];
            const gridY = [];
            for (let i = 0; i < gridSize; i++) {
                gridX.push(xMin + (xMax - xMin) * i / (gridSize - 1));
                gridY.push(yMin + (yMax - yMin) * i / (gridSize - 1));
            }

            // Evaluate regression on grid
            const gridZ = [];
            for (let j = 0; j < gridSize; j++) {
                const row = [];
                for (let i = 0; i < gridSize; i++) {
                    const x = gridX[i];
                    const y = gridY[j];
                    const iv = evaluatePolynomial(coeffs, x, y);
                    row.push(Math.max(5, Math.min(200, iv)));  // Clamp to reasonable range
                }
                gridZ.push(row);
            }

            // Smooth surface using polynomial regression
            const surfaceTrace = {
                type: 'surface',
                x: gridX,
                y: gridY,
                z: gridZ,
                colorscale: [
                    [0, '#1e40af'],
                    [0.25, '#3b82f6'],
                    [0.5, '#22c55e'],
                    [0.75, '#eab308'],
                    [1, '#ef4444']
                ],
                colorbar: {
                    title: 'IV %',
                    ticksuffix: '%',
                    len: 0.75
                },
                opacity: 0.9,
                hovertemplate: window.xAxisMode === 'moneyness'
                    ? 'Moneyness: %{x:.3f}<br>Days: %{y:.0f}d<br>IV: %{z:.1f}%<extra></extra>'
                    : 'Strike: $%{x:.0f}<br>Days: %{y:.0f}d<br>IV: %{z:.1f}%<extra></extra>',
                name: 'IV Surface (fitted)',
                showlegend: true,
                contours: {
                    z: { show: true, usecolormap: true, highlightcolor: "#fff", project: { z: false } }
                }
            };

            // Compute axis ranges from data for tight fit
            const xPad = (xMax - xMin) * 0.05;  // 5% padding
            const yPad = Math.max(5, (yMax - yMin) * 0.05);  // At least 5 days padding
            const zMin = Math.min(...zData);
            const zMax = Math.max(...zData);
            const zPad = (zMax - zMin) * 0.1;  // 10% padding

            // ATM marker as a solid transparent plane using mesh3d
            // Plane extends beyond data bounds for visibility
            const yPlaneMin = -yPad * 2;  // Extend into negative (before 0 days)
            const yPlaneMax = yMax + yPad * 3;  // Extend above max expiry
            const atmTrace = {
                type: 'mesh3d',
                x: [atmValue, atmValue, atmValue, atmValue],
                y: [yPlaneMin, yPlaneMax, yPlaneMax, yPlaneMin],
                z: [zMin - zPad, zMin - zPad, zMax + zPad, zMax + zPad],
                i: [0, 0],  // Triangle indices
                j: [1, 2],
                k: [2, 3],
                color: '#d946ef',  // Fuchsia - distinct from blue-green-yellow-red surface colorscale
                opacity: 0.2,
                name: window.xAxisMode === 'moneyness' ? 'ATM (K=S)' : `Spot $${spot.toFixed(0)}`,
                hovertemplate: window.xAxisMode === 'moneyness'
                    ? 'ATM Plane (Moneyness = 1)<extra></extra>'
                    : `Spot Price: $${spot.toFixed(2)}<extra></extra>`,
                showlegend: true
            };

            // Data point markers - small dots showing actual option locations
            const markersTrace = {
                type: 'scatter3d',
                mode: 'markers',
                x: xData,
                y: yData,
                z: zData,
                marker: {
                    size: 3,
                    color: '#94a3b8',
                    opacity: 0.6,
                    line: {
                        width: 0.5,
                        color: '#64748b'
                    }
                },
                name: 'Option Contracts',
                hovertemplate: window.xAxisMode === 'moneyness'
                    ? 'Moneyness: %{x:.3f}<br>Days: %{y}d<br>IV: %{z:.1f}%<extra></extra>'
                    : 'Strike: $%{x:.0f}<br>Days: %{y}d<br>IV: %{z:.1f}%<extra></extra>',
                showlegend: true
            };

            // Title showing option type and filter status
            const optTypeLabel = window.optionType === 'put' ? 'PUTS' : 'CALLS';
            const moneyLabel = window.filterEnabled ? ` K/S:${window.filterMoneyMin}-${window.filterMoneyMax}` : '';
            const ivLabel = window.ivFilterEnabled ? ` IV:${window.ivFilterMin}-${window.ivFilterMax}%` : '';
            const filterLabel = (moneyLabel || ivLabel) ? ` [${moneyLabel}${ivLabel}]`.replace('[ ', '[') : '';

            const plotEl = document.getElementById('surface-plot');

            // Use saved camera if available (deep copy to avoid reference issues)
            const defaultCamera = {
                eye: { x: 1.2, y: -1.8, z: 0.8 },
                up: { x: 0, y: 0, z: 1 },
                center: { x: 0, y: 0, z: 0 }
            };
            const cameraToUse = window.savedCamera ? JSON.parse(JSON.stringify(window.savedCamera)) : defaultCamera;

            const layout = {
                title: {
                    text: `${data.symbol} ${optTypeLabel} IV Surface${filterLabel}`,
                    font: { color: '#94a3b8', size: 16 },
                    x: 0.5,
                    y: 0.95
                },
                scene: {
                    xaxis: {
                        title: xLabel,
                        gridcolor: '#334155',
                        range: [xMin - xPad, xMax + xPad],
                        autorange: false
                    },
                    yaxis: {
                        title: 'Days to Expiry',
                        gridcolor: '#334155',
                        range: [yMin - yPad, yMax + yPad],
                        autorange: false
                    },
                    zaxis: {
                        title: 'IV %',
                        gridcolor: '#334155',
                        range: [Math.max(0, zMin - zPad), zMax + zPad],
                        autorange: false
                    },
                    bgcolor: '#0f172a',
                    // Camera: maturity on depth axis, 0 days facing viewer
                    camera: cameraToUse,
                    // Use manual aspect ratio for good proportions regardless of data scale
                    aspectmode: 'manual',
                    aspectratio: { x: 1, y: 1.2, z: 0.8 }
                },
                paper_bgcolor: '#0f172a',
                margin: { l: 0, r: 0, t: 40, b: 0 },
                autosize: true,
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(15, 23, 42, 0.8)',
                    font: { color: '#94a3b8' }
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'],
                displaylogo: false
            };

            // Use react() if plot exists to preserve camera, else newPlot()
            if (window.surfacePlotInitialized) {
                Plotly.react(plotEl, [surfaceTrace, atmTrace, markersTrace], layout, config);
            } else {
                Plotly.newPlot(plotEl, [surfaceTrace, atmTrace, markersTrace], layout, config);
                window.surfacePlotInitialized = true;

                // Add listener to save camera position when user interacts with plot
                plotEl.on('plotly_relayout', function(eventData) {
                    if (eventData['scene.camera']) {
                        window.savedCamera = JSON.parse(JSON.stringify(eventData['scene.camera']));
                    }
                });
            }
        }

        // Load equity data
        async function loadEquityData(symbol) {
            try {
                const response = await fetch(`/api/equity/${symbol}?period=1y`);
                window.equityData = await response.json();

                if (!window.equityData.error) {
                    renderEquityChart(window.equityData);
                }
            } catch (error) {
                console.error('Failed to load equity data:', error);
            }
        }

        // Render equity chart
        function renderEquityChart(data) {
            const trace = {
                type: 'candlestick',
                x: data.dates,
                open: data.open,
                high: data.high,
                low: data.low,
                close: data.close,
                increasing: { line: { color: '#22c55e' } },
                decreasing: { line: { color: '#ef4444' } }
            };

            const layout = {
                paper_bgcolor: '#0f172a',
                plot_bgcolor: '#0f172a',
                xaxis: {
                    rangeslider: { visible: false },
                    gridcolor: '#334155',
                    color: '#94a3b8'
                },
                yaxis: {
                    gridcolor: '#334155',
                    color: '#94a3b8',
                    side: 'right'
                },
                margin: { l: 10, r: 60, t: 10, b: 40 },
                autosize: true
            };

            Plotly.newPlot('equity-plot', [trace], layout, { responsive: true, displaylogo: false });
        }

        // Load vol analysis
        async function loadVolData(symbol) {
            try {
                const model = document.getElementById('garch-model').value;
                const response = await fetch(`/api/vol_analysis/${symbol}?model=${model}`);
                window.volData = await response.json();

                if (!window.volData.error) {
                    renderVolAnalysis(window.volData);
                }
            } catch (error) {
                console.error('Failed to load vol data:', error);
            }
        }

        function updateVolAnalysis() {
            if (window.currentSymbol) {
                loadVolData(window.currentSymbol);
            }
        }

        // Render vol analysis
        function renderVolAnalysis(data) {
            // Update stats
            if (data.realized_vol) {
                document.getElementById('rv-20').textContent =
                    (data.realized_vol.rv_20 * 100).toFixed(1) + '%';
                document.getElementById('rv-60').textContent =
                    (data.realized_vol.rv_60 * 100).toFixed(1) + '%';
            }

            if (data.garch && !data.garch.error) {
                document.getElementById('garch-current').textContent =
                    (data.garch.current_vol * 100).toFixed(1) + '%';

                // Render forecast chart
                const trace = {
                    type: 'scatter',
                    mode: 'lines+markers',
                    x: data.garch.forecast_days,
                    y: data.garch.forecast.map(v => v * 100),
                    line: { color: '#3b82f6', width: 2 },
                    marker: { size: 8 }
                };

                const layout = {
                    paper_bgcolor: 'transparent',
                    plot_bgcolor: 'transparent',
                    xaxis: {
                        title: 'Days Ahead',
                        gridcolor: '#334155',
                        color: '#94a3b8'
                    },
                    yaxis: {
                        title: 'Vol %',
                        gridcolor: '#334155',
                        color: '#94a3b8',
                        ticksuffix: '%'
                    },
                    margin: { l: 50, r: 20, t: 20, b: 50 },
                    autosize: true
                };

                Plotly.newPlot('vol-plot', [trace], layout, { responsive: true, displaylogo: false });
            }
        }

        // Refresh - forces a re-fetch by clearing cached data
        function refreshSurface() {
            if (window.currentSymbol) {
                // Clear cached data to force refresh
                window.surfaceData = null;
                loadSymbol(window.currentSymbol);
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            Plotly.Plots.resize(document.getElementById('surface-plot'));
            Plotly.Plots.resize(document.getElementById('equity-plot'));
            Plotly.Plots.resize(document.getElementById('vol-plot'));
        });
    </script>
</body>
</html>
