--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out --auto=yes
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         67108864 B, 64 B, direct-mapped
Command:          bazel-bin/benchmarks/readme_benchmarks
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir______________________ I1mr____________ ILmr__________ Dr_____________________ D1mr_______________ DLmr___________ Dw____________________ D1mw_______________ DLmw____________ Bc_____________________ Bcm_________________ Bi____________________ Bim___________ 

102,845,965,245 (100.0%) 147,672 (100.0%) 5,431 (100.0%) 33,288,614,322 (100.0%) 36,320,491 (100.0%) 22,093 (100.0%) 8,276,356,197 (100.0%) 53,872,450 (100.0%) 148,593 (100.0%) 11,778,744,642 (100.0%) 118,947,310 (100.0%) 1,712,390,936 (100.0%) 8,193 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir___________________________ I1mr_________________ ILmr______________ Dr__________________________ D1mr_____________________ DLmr____________ Dw__________________________ D1mw_____________________ DLmw_______________ Bc__________________________ Bcm______________________ Bi__________________________ Bim_________________  file:function

< 27,095,636,080 (26.3%, 26.3%)  3,084  (2.1%,  2.1%)   4  (0.1%,  0.1%) 9,312,699,144 (28.0%, 28.0%)  3,632,458 (10.0%, 10.0%)  35 (0.2%, 0.2%)             0  (0.0%,  0.0%)          0  (0.0%,  0.0%)     0 (0.0%,  0.0%) 1,694,841,024 (14.4%, 14.4%)    991,906  (0.8%,  0.8%)             0  (0.0%,  0.0%)     0  (0.0%,  0.0%)  ./math/../sysdeps/ieee754/dbl-64/e_exp.c:__ieee754_exp_fma

< 17,508,180,600 (17.0%, 43.4%)  4,765  (3.2%,  5.3%)   7  (0.1%,  0.2%) 7,941,843,576 (23.9%, 51.8%) 10,867,828 (29.9%, 39.9%)  42 (0.2%, 0.3%) 2,377,690,128 (28.7%, 28.7%) 19,961,571 (37.1%, 37.1%)    99 (0.1%,  0.1%) 2,419,372,512 (20.5%, 34.9%) 13,894,158 (11.7%, 12.5%)             0  (0.0%,  0.0%)     0  (0.0%,  0.0%)  /proc/self/cwd/./src/thomas_solver.hpp:mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

< 12,913,549,070 (12.6%, 55.9%) 14,839 (10.0%, 15.4%)  41  (0.8%,  1.0%) 4,586,665,448 (13.8%, 65.6%) 13,291,376 (36.6%, 76.5%) 129 (0.6%, 0.9%) 1,230,359,624 (14.9%, 43.6%)  7,744,772 (14.4%, 51.4%)   263 (0.2%,  0.2%) 2,075,821,492 (17.6%, 52.6%) 48,549,709 (40.8%, 53.3%)             0  (0.0%,  0.0%)     0  (0.0%,  0.0%)  /proc/self/cwd/./src/pde_solver.hpp:
  12,168,997,050 (11.8%)         6,657  (4.5%)         21  (0.4%)        4,041,771,304 (12.1%)        11,341,233 (31.2%)         93 (0.4%)       1,109,809,644 (13.4%)         3,901,249  (7.2%)          126 (0.1%)        1,953,470,664 (16.6%)        45,041,607 (37.9%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     744,064,974  (0.7%)         1,699  (1.2%)         13  (0.2%)          544,773,324  (1.6%)         1,950,083  (5.4%)         36 (0.2%)         120,519,992  (1.5%)         3,842,118  (7.1%)           75 (0.1%)          122,253,332  (1.0%)         3,501,696  (2.9%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

< 12,711,302,670 (12.4%, 68.3%)     10  (0.0%, 15.4%)   1  (0.0%,  1.0%) 3,389,680,712 (10.2%, 75.8%)         44  (0.0%, 76.5%)   2 (0.0%, 0.9%) 1,694,840,356 (20.5%, 64.1%)        707  (0.0%, 51.4%)    31 (0.0%,  0.3%) 2,542,260,534 (21.6%, 74.1%)         26  (0.0%, 53.3%)             0  (0.0%,  0.0%)     0  (0.0%,  0.0%)  ./math/./w_exp_template.c:exp@@GLIBC_2.29

<  9,349,125,324  (9.1%, 77.4%) 26,736 (18.1%, 33.5%)  39  (0.7%,  1.7%) 1,841,088,794  (5.5%, 81.3%)  7,383,229 (20.3%, 96.8%)  41 (0.2%, 1.1%) 1,722,788,574 (20.8%, 84.9%)  5,802,785 (10.8%, 62.2%) 9,055 (6.1%,  6.4%)   830,574,872  (7.1%, 81.2%)  6,966,769  (5.9%, 59.2%)             0  (0.0%,  0.0%)     0  (0.0%,  0.0%)  /proc/self/cwd/src/american_option.cpp:
   8,863,741,440  (8.6%)             0                  0                1,631,803,840  (4.9%)         7,382,008 (20.3%)         40 (0.2%)       1,624,855,110 (19.6%)         5,797,767 (10.8%)        8,960 (6.0%)          795,055,730  (6.7%)         6,948,746  (5.8%)                    0                    0                   mango::(anonymous namespace)::AmericanPutObstacle::operator()(double, std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>) const [clone .isra.0]
     466,247,328  (0.5%)            51  (0.0%)          4  (0.1%)          201,729,536  (0.6%)                 3  (0.0%)          0                 97,470,640  (1.2%)               710  (0.0%)           32 (0.0%)           34,788,256  (0.3%)             1,521  (0.0%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<  5,010,195,594  (4.9%, 82.2%)     36  (0.0%, 33.5%)  15  (0.3%,  2.0%) 1,277,425,734  (3.8%, 85.2%)          0  (0.0%, 96.8%)   0 (0.0%, 1.1%)    77,118,209  (0.9%, 85.8%)          0  (0.0%, 62.2%)     0 (0.0%,  6.4%)   537,339,744  (4.6%, 85.7%) 26,120,752 (22.0%, 81.1%)             0  (0.0%,  0.0%)     0  (0.0%,  0.0%)  /proc/self/cwd/./src/bspline_4d.hpp:
   5,010,195,576  (4.9%)            34  (0.0%)         13  (0.2%)        1,277,425,734  (3.8%)                 0                  0                 77,118,204  (0.9%)                 0                    0                 537,339,744  (4.6%)        26,120,752 (22.0%)                    0                    0                   mango::BSpline4D_FMA::eval(double, double, double, double) const

<  4,520,678,136  (4.4%, 86.6%)  5,798  (3.9%, 37.4%) 919 (16.9%, 18.9%) 2,107,648,263  (6.3%, 91.5%)    124,439  (0.3%, 97.2%)  31 (0.1%, 1.3%)        97,845  (0.0%, 85.8%)      5,381  (0.0%, 62.2%)   186 (0.1%,  6.5%)   804,237,158  (6.8%, 92.6%)      3,025  (0.0%, 81.2%) 1,705,430,602 (99.6%, 99.6%) 6,419 (78.3%, 78.3%)  ???:
   4,520,234,470  (4.4%)         3,247  (2.2%)        413  (7.6%)        2,107,567,710  (6.3%)           124,072  (0.3%)         11 (0.0%)              34,104  (0.0%)             4,560  (0.0%)           79 (0.1%)          804,202,875  (6.8%)             1,758  (0.0%)        1,705,429,858 (99.6%)        6,377 (77.8%)           ???

<  3,464,942,528  (3.4%, 90.0%)     79  (0.1%, 37.5%)   9  (0.2%, 19.1%)   841,063,768  (2.5%, 94.0%)     89,064  (0.2%, 97.4%)   0 (0.0%, 1.3%)   255,431,672  (3.1%, 88.9%)  7,272,376 (13.5%, 75.7%) 8,294 (5.6%, 12.1%)   264,127,128  (2.2%, 94.8%)  8,697,285  (7.3%, 88.5%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /proc/self/cwd/./src/operators/centered_difference.hpp:
   2,769,190,920  (2.7%)            20  (0.0%)          4  (0.1%)          674,313,768  (2.0%)            89,064  (0.2%)          0                203,930,064  (2.5%)         5,403,876 (10.0%)           36 (0.0%)          210,877,128  (1.8%)         6,947,262  (5.8%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     695,750,000  (0.7%)            59  (0.0%)          5  (0.1%)          166,750,000  (0.5%)                 0                  0                 51,500,000  (0.6%)         1,868,490  (3.5%)        8,258 (5.6%)           53,250,000  (0.5%)         1,750,023  (1.5%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

<  2,540,283,670  (2.5%, 92.5%)     74  (0.1%, 37.5%)   1  (0.0%, 19.1%)             0  (0.0%, 94.0%)          0  (0.0%, 97.4%)   0 (0.0%, 1.3%)             0  (0.0%, 88.9%)          0  (0.0%, 75.7%)     0 (0.0%, 12.1%)             0  (0.0%, 94.8%)          0  (0.0%, 88.5%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  ./math/../sysdeps/ieee754/dbl-64/math_config.h:
   2,540,277,872  (2.5%)            74  (0.1%)          1  (0.0%)                    0                         0                  0                          0                         0                    0                           0                         0                            0                    0                   __ieee754_exp_fma

<  1,579,182,745  (1.5%, 94.0%)    104  (0.1%, 37.6%)  38  (0.7%, 19.8%)   356,993,370  (1.1%, 95.1%)          1  (0.0%, 97.4%)   0 (0.0%, 1.3%)   100,777,154  (1.2%, 90.1%)          1  (0.0%, 75.7%)     0 (0.0%, 12.1%)   199,065,061  (1.7%, 96.5%)  5,923,782  (5.0%, 93.4%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /proc/self/cwd/./src/bspline_utils.hpp:
   1,505,777,156  (1.5%)            85  (0.1%)         30  (0.6%)          343,305,156  (1.0%)                 0                  0                 99,532,520  (1.2%)                 1  (0.0%)            0                 189,111,464  (1.6%)         5,923,551  (5.0%)                    0                    0                   mango::cubic_basis_nonuniform(std::vector<double, std::allocator<double> > const&, int, double, double*) [clone .isra.0]

<  1,490,907,880  (1.4%, 95.5%)     12  (0.0%, 37.6%)   2  (0.0%, 19.8%)   750,702,332  (2.3%, 97.3%)          8  (0.0%, 97.4%)   1 (0.0%, 1.3%)         1,608  (0.0%, 90.1%)          0  (0.0%, 75.7%)     0 (0.0%, 12.1%)             0  (0.0%, 96.5%)          0  (0.0%, 93.4%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /proc/self/cwd/./src/operators/black_scholes_pde.hpp:
   1,192,398,000  (1.2%)             7  (0.0%)          1  (0.0%)          601,449,000  (1.8%)                 0                  0                          0                         0                    0                           0                         0                            0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     298,500,000  (0.3%)             0                  0                  149,250,000  (0.4%)                 0                  0                          0                         0                    0                           0                         0                            0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

<  1,270,189,179  (1.2%, 96.7%)    144  (0.1%, 37.7%)  19  (0.3%, 20.2%)   368,984,757  (1.1%, 98.5%)    238,223  (0.7%, 98.1%)  22 (0.1%, 1.4%)   337,634,302  (4.1%, 94.2%)  1,898,656  (3.5%, 79.2%) 7,708 (5.2%, 17.3%)   144,498,043  (1.2%, 97.7%)  1,897,102  (1.6%, 95.0%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
   1,270,185,488  (1.2%)           103  (0.1%)         10  (0.2%)          368,984,194  (1.1%)           238,180  (0.7%)          6 (0.0%)         337,633,951  (4.1%)         1,898,568  (3.5%)        7,620 (5.1%)          144,497,320  (1.2%)         1,896,936  (1.6%)                    0                    0                   __memcpy_avx_unaligned_erms

<  1,118,408,670  (1.1%, 97.8%)  6,424  (4.4%, 42.1%)  11  (0.2%, 20.4%)    47,094,408  (0.1%, 98.6%)    119,073  (0.3%, 98.4%)   3 (0.0%, 1.4%)   326,455,278  (3.9%, 98.1%) 11,040,796 (20.5%, 99.7%)   124 (0.1%, 17.3%)   163,985,320  (1.4%, 99.1%)  3,500,008  (2.9%, 98.0%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /proc/self/cwd/./src/operators/spatial_operator.hpp:
   1,113,147,240  (1.1%)         6,401  (4.3%)         10  (0.2%)           45,341,192  (0.1%)            89,067  (0.2%)          3 (0.0%)         326,447,064  (3.9%)        11,040,093 (20.5%)           93 (0.1%)          162,235,320  (1.4%)         3,500,008  (2.9%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<    807,496,870  (0.8%, 98.6%)     14  (0.0%, 42.1%)   7  (0.1%, 20.5%)    12,144,849  (0.0%, 98.6%)    119,066  (0.3%, 98.7%)   1 (0.0%, 1.4%)       267,712  (0.0%, 98.2%)          0  (0.0%, 99.7%)     0 (0.0%, 17.3%)             0  (0.0%, 99.1%)          0  (0.0%, 98.0%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /usr/include/c++/14/bits/std_abs.h:
     801,826,128  (0.8%)             0                  0                    6,947,064  (0.0%)           119,064  (0.3%)          0                          0                         0                    0                           0                         0                            0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<    320,154,484  (0.3%, 98.9%)  9,475  (6.4%, 48.5%) 203  (3.7%, 24.2%)   106,101,357  (0.3%, 99.0%)    151,232  (0.4%, 99.2%)   0 (0.0%, 1.4%)       188,935  (0.0%, 98.2%)      3,609  (0.0%, 99.7%)   164 (0.1%, 17.4%)    14,079,778  (0.1%, 99.2%)  1,750,739  (1.5%, 99.5%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /usr/include/c++/14/bits/stl_vector.h:
     131,250,000  (0.1%)            37  (0.0%)          5  (0.1%)           26,250,000  (0.1%)           150,000  (0.4%)          0                          0                         0                    0                  14,000,000  (0.1%)         1,750,008  (1.5%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

<    260,886,610  (0.3%, 99.1%)  3,375  (2.3%, 50.8%)  18  (0.3%, 24.6%)    76,534,722  (0.2%, 99.2%)         13  (0.0%, 99.2%)   0 (0.0%, 1.4%)    38,276,876  (0.5%, 98.6%)      3,554  (0.0%, 99.7%)   774 (0.5%, 18.0%)     6,950,854  (0.1%, 99.3%)         71  (0.0%, 99.5%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /usr/include/c++/14/span:
     236,411,920  (0.2%)            78  (0.1%)          8  (0.1%)           73,023,576  (0.2%)                 6  (0.0%)          0                 38,235,320  (0.5%)               706  (0.0%)           31 (0.0%)                    0                         0                            0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<    246,297,424  (0.2%, 99.4%)  3,298  (2.2%, 53.0%)  51  (0.9%, 25.5%)    12,711,672  (0.0%, 99.2%)         14  (0.0%, 99.2%)   5 (0.0%, 1.4%)    18,724,867  (0.2%, 98.8%)        711  (0.0%, 99.7%)    32 (0.0%, 18.0%)    10,458,660  (0.1%, 99.4%)        163  (0.0%, 99.5%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /usr/include/c++/14/bits/stl_algobase.h:
     174,137,880  (0.2%)             6  (0.0%)          2  (0.0%)            3,731,526  (0.0%)                 1  (0.0%)          1 (0.0%)           1,243,842  (0.0%)                 0                    0                           0                         0                            0                    0                   mango::BSpline4D_FMA::eval(double, double, double, double) const

<    132,273,404  (0.1%, 99.5%)     34  (0.0%, 53.0%)   5  (0.1%, 25.6%)    50,433,996  (0.2%, 99.4%)          0  (0.0%, 99.2%)   0 (0.0%, 1.4%)     3,508,060  (0.0%, 98.9%)        672  (0.0%, 99.7%)   650 (0.4%, 18.4%)    17,394,128  (0.1%, 99.5%)          2  (0.0%, 99.5%)             0  (0.0%, 99.6%)     0  (0.0%, 78.3%)  /proc/self/cwd/./src/operators/grid_spacing.hpp:
     104,258,896  (0.1%)            24  (0.0%)          4  (0.1%)           45,182,384  (0.1%)                 0                  0                  3,500,000  (0.0%)                 0                    0                  13,894,128  (0.1%)                 2  (0.0%)                    0                    0                   mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir___________________________ I1mr_________________ ILmr_____________ Dr___________________________ D1mr_____________________ DLmr____________ Dw__________________________ D1mw_____________________ DLmw_______________ Bc__________________________ Bcm______________________ Bi___________________________ Bim_________________  function:file

> 36,663,146,514 (35.6%, 35.6%) 21,389 (14.5%, 14.5%)  66 (1.2%,  1.2%) 13,791,542,680 (41.4%, 41.4%) 22,684,404 (62.5%, 62.5%) 144 (0.7%, 0.7%) 4,237,053,500 (51.2%, 51.2%) 40,308,207 (74.8%, 74.8%)   417 (0.3%,  0.3%) 4,808,532,136 (40.8%, 40.8%) 69,384,560 (58.3%, 58.3%)     6,947,064  (0.4%,   0.4%)     1  (0.0%,  0.0%)  mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]:
  17,508,180,600 (17.0%)         4,765  (3.2%)          7 (0.1%)         7,941,843,576 (23.9%)        10,867,828 (29.9%)         42 (0.2%)       2,377,690,128 (28.7%)        19,961,571 (37.1%)           99 (0.1%)        2,419,372,512 (20.5%)        13,894,158 (11.7%)                    0                     0                   /proc/self/cwd/./src/thomas_solver.hpp
  12,168,997,050 (11.8%)         6,657  (4.5%)         21 (0.4%)         4,041,771,304 (12.1%)        11,341,233 (31.2%)         93 (0.4%)       1,109,809,644 (13.4%)         3,901,249  (7.2%)          126 (0.1%)        1,953,470,664 (16.6%)        45,041,607 (37.9%)                    0                     0                   /proc/self/cwd/./src/pde_solver.hpp
   2,769,190,920  (2.7%)            20  (0.0%)          4 (0.1%)           674,313,768  (2.0%)            89,064  (0.2%)          0                203,930,064  (2.5%)         5,403,876 (10.0%)           36 (0.0%)          210,877,128  (1.8%)         6,947,262  (5.8%)                    0                     0                   /proc/self/cwd/./src/operators/centered_difference.hpp
   1,192,398,000  (1.2%)             7  (0.0%)          1 (0.0%)           601,449,000  (1.8%)                 0                  0                          0                         0                    0                           0                         0                            0                     0                   /proc/self/cwd/./src/operators/black_scholes_pde.hpp
   1,113,147,240  (1.1%)         6,401  (4.3%)         10 (0.2%)            45,341,192  (0.1%)            89,067  (0.2%)          3 (0.0%)         326,447,064  (3.9%)        11,040,093 (20.5%)           93 (0.1%)          162,235,320  (1.4%)         3,500,008  (2.9%)                    0                     0                   /proc/self/cwd/./src/operators/spatial_operator.hpp
     801,826,128  (0.8%)             0                  0                    6,947,064  (0.0%)           119,064  (0.3%)          0                          0                         0                    0                           0                         0                            0                     0                   /usr/include/c++/14/bits/std_abs.h
     466,247,328  (0.5%)            51  (0.0%)          4 (0.1%)           201,729,536  (0.6%)                 3  (0.0%)          0                 97,470,640  (1.2%)               710  (0.0%)           32 (0.0%)           34,788,256  (0.3%)             1,521  (0.0%)                    0                     0                   /proc/self/cwd/src/american_option.cpp
     236,411,920  (0.2%)            78  (0.1%)          8 (0.1%)            73,023,576  (0.2%)                 6  (0.0%)          0                 38,235,320  (0.5%)               706  (0.0%)           31 (0.0%)                    0                         0                            0                     0                   /usr/include/c++/14/span
     104,258,896  (0.1%)            24  (0.0%)          4 (0.1%)            45,182,384  (0.1%)                 0                  0                  3,500,000  (0.0%)                 0                    0                  13,894,128  (0.1%)                 2  (0.0%)                    0                     0                   /proc/self/cwd/./src/operators/grid_spacing.hpp

> 29,635,913,952 (28.8%, 64.5%)  3,158  (2.1%, 16.6%)   5 (0.1%,  1.3%)  9,312,699,144 (28.0%, 69.4%)  3,632,458 (10.0%, 72.5%)  35 (0.2%, 0.8%)             0  (0.0%, 51.2%)          0  (0.0%, 74.8%)     0 (0.0%,  0.3%) 1,694,841,024 (14.4%, 55.2%)    991,906  (0.8%, 59.2%)             0  (0.0%,   0.4%)     0  (0.0%,  0.0%)  __ieee754_exp_fma:
  27,095,636,080 (26.3%)         3,084  (2.1%)          4 (0.1%)         9,312,699,144 (28.0%)         3,632,458 (10.0%)         35 (0.2%)                   0                         0                    0               1,694,841,024 (14.4%)           991,906  (0.8%)                    0                     0                   ./math/../sysdeps/ieee754/dbl-64/e_exp.c
   2,540,277,872  (2.5%)            74  (0.1%)          1 (0.0%)                     0                         0                  0                          0                         0                    0                           0                         0                            0                     0                   ./math/../sysdeps/ieee754/dbl-64/math_config.h

> 12,711,302,670 (12.4%, 76.8%)     10  (0.0%, 16.6%)   1 (0.0%,  1.3%)  3,389,680,712 (10.2%, 79.6%)         44  (0.0%, 72.5%)   2 (0.0%, 0.8%) 1,694,840,356 (20.5%, 71.7%)        707  (0.0%, 74.8%)    31 (0.0%,  0.3%) 2,542,260,534 (21.6%, 76.8%)         26  (0.0%, 59.2%)             0  (0.0%,   0.4%)     0  (0.0%,  0.0%)  exp@@GLIBC_2.29:./math/./w_exp_template.c

>  8,877,638,900  (8.6%, 85.5%)      7  (0.0%, 16.6%)   1 (0.0%,  1.3%)  1,631,803,840  (4.9%, 84.5%)  7,382,008 (20.3%, 92.8%)  40 (0.2%, 1.0%) 1,624,855,110 (19.6%, 91.3%)  5,797,767 (10.8%, 85.6%) 8,960 (6.0%,  6.3%)   802,004,460  (6.8%, 83.6%)  6,948,746  (5.8%, 65.0%)             0  (0.0%,   0.4%)     0  (0.0%,  0.0%)  mango::(anonymous namespace)::AmericanPutObstacle::operator()(double, std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>) const [clone .isra.0]:
   8,863,741,440  (8.6%)             0                  0                1,631,803,840  (4.9%)         7,382,008 (20.3%)         40 (0.2%)       1,624,855,110 (19.6%)         5,797,767 (10.8%)        8,960 (6.0%)          795,055,730  (6.7%)         6,948,746  (5.8%)                    0                     0                   /proc/self/cwd/src/american_option.cpp

>  5,508,976,218  (5.4%, 90.8%)     79  (0.1%, 16.7%)  28 (0.5%,  1.9%)  1,385,639,988  (4.2%, 88.7%)          1  (0.0%, 92.8%)   1 (0.0%, 1.0%)    80,849,730  (1.0%, 92.3%)          0  (0.0%, 85.6%)     0 (0.0%,  6.3%)   572,167,320  (4.9%, 88.5%) 26,533,635 (22.3%, 87.3%)             0  (0.0%,   0.4%)     0  (0.0%,  0.0%)  mango::BSpline4D_FMA::eval(double, double, double, double) const:
   5,010,195,576  (4.9%)            34  (0.0%)         13 (0.2%)         1,277,425,734  (3.8%)                 0                  0                 77,118,204  (0.9%)                 0                    0                 537,339,744  (4.6%)        26,120,752 (22.0%)                    0                     0                   /proc/self/cwd/./src/bspline_4d.hpp
     174,137,880  (0.2%)             6  (0.0%)          2 (0.0%)             3,731,526  (0.0%)                 1  (0.0%)          1 (0.0%)           1,243,842  (0.0%)                 0                    0                           0                         0                            0                     0                   /usr/include/c++/14/bits/stl_algobase.h

>  4,520,234,565  (4.4%, 95.2%)  3,247  (2.2%, 18.9%) 413 (7.6%,  9.5%)  2,107,567,710  (6.3%, 95.0%)    124,072  (0.3%, 93.1%)  11 (0.0%, 1.1%)        34,104  (0.0%, 92.3%)      4,560  (0.0%, 85.6%)    79 (0.1%,  6.4%)   804,202,875  (6.8%, 95.3%)      1,758  (0.0%, 87.3%) 1,705,429,858 (99.6%, 100.0%) 6,377 (77.8%, 77.8%)  ???:
   4,520,234,470  (4.4%)         3,247  (2.2%)        413 (7.6%)         2,107,567,710  (6.3%)           124,072  (0.3%)         11 (0.0%)              34,104  (0.0%)             4,560  (0.0%)           79 (0.1%)          804,202,875  (6.8%)             1,758  (0.0%)        1,705,429,858 (99.6%)         6,377 (77.8%)           ???

>  1,967,574,970  (1.9%, 97.1%)  2,744  (1.9%, 20.7%)  30 (0.6%, 10.0%)    915,026,656  (2.7%, 97.7%)  2,220,083  (6.1%, 99.2%)  36 (0.2%, 1.2%)   182,524,990  (2.2%, 94.5%)  5,712,024 (10.6%, 96.2%) 8,396 (5.7%, 12.0%)   203,503,332  (1.7%, 97.0%)  7,001,727  (5.9%, 93.2%)             0  (0.0%, 100.0%)     0  (0.0%, 77.8%)  mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve():
     744,064,974  (0.7%)         1,699  (1.2%)         13 (0.2%)           544,773,324  (1.6%)         1,950,083  (5.4%)         36 (0.2%)         120,519,992  (1.5%)         3,842,118  (7.1%)           75 (0.1%)          122,253,332  (1.0%)         3,501,696  (2.9%)                    0                     0                   /proc/self/cwd/./src/pde_solver.hpp
     695,750,000  (0.7%)            59  (0.0%)          5 (0.1%)           166,750,000  (0.5%)                 0                  0                 51,500,000  (0.6%)         1,868,490  (3.5%)        8,258 (5.6%)           53,250,000  (0.5%)         1,750,023  (1.5%)                    0                     0                   /proc/self/cwd/./src/operators/centered_difference.hpp
     298,500,000  (0.3%)             0                  0                  149,250,000  (0.4%)                 0                  0                          0                         0                    0                           0                         0                            0                     0                   /proc/self/cwd/./src/operators/black_scholes_pde.hpp
     131,250,000  (0.1%)            37  (0.0%)          5 (0.1%)            26,250,000  (0.1%)           150,000  (0.4%)          0                          0                         0                    0                  14,000,000  (0.1%)         1,750,008  (1.5%)                    0                     0                   /usr/include/c++/14/bits/stl_vector.h

>  1,600,333,068  (1.6%, 98.7%)     88  (0.1%, 20.8%)  31 (0.6%, 10.6%)    348,282,124  (1.0%, 98.8%)          0  (0.0%, 99.2%)   0 (0.0%, 1.2%)    99,532,520  (1.2%, 95.7%)          1  (0.0%, 96.2%)     0 (0.0%, 12.0%)   189,111,464  (1.6%, 98.6%)  5,923,551  (5.0%, 98.2%)             0  (0.0%, 100.0%)     0  (0.0%, 77.8%)  mango::cubic_basis_nonuniform(std::vector<double, std::allocator<double> > const&, int, double, double*) [clone .isra.0]:
   1,505,777,156  (1.5%)            85  (0.1%)         30 (0.6%)           343,305,156  (1.0%)                 0                  0                 99,532,520  (1.2%)                 1  (0.0%)            0                 189,111,464  (1.6%)         5,923,551  (5.0%)                    0                     0                   /proc/self/cwd/./src/bspline_utils.hpp

>  1,270,185,488  (1.2%, 99.9%)    103  (0.1%, 20.9%)  10 (0.2%, 10.8%)    368,984,194  (1.1%, 99.9%)    238,180  (0.7%, 99.9%)   6 (0.0%, 1.2%)   337,633,951  (4.1%, 99.8%)  1,898,568  (3.5%, 99.7%) 7,620 (5.1%, 17.2%)   144,497,320  (1.2%, 99.9%)  1,896,936  (1.6%, 99.8%)             0  (0.0%, 100.0%)     0  (0.0%, 77.8%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./math/../sysdeps/ieee754/dbl-64/e_exp.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./math/../sysdeps/ieee754/dbl-64/e_exp.c

--------------------------------------------------------------------------------
-- Annotated source file: ./math/../sysdeps/ieee754/dbl-64/math_config.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./math/../sysdeps/ieee754/dbl-64/math_config.h

--------------------------------------------------------------------------------
-- Annotated source file: ./math/./w_exp_template.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./math/./w_exp_template.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/bspline_4d.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr____ ILmr____ Dr________________ D1mr DLmr Dw_______________ D1mw DLmw Bc________________ Bcm_______________ Bi Bim 

-- line 48 ----------------------------------------
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// For right boundary, uses nextafter to ensure x < xmax (not x <= xmax)
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// to avoid issues with half-open interval [xmin, xmax)
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  ///
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// @param x Query point
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// @param xmin Minimum value
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// @param xmax Maximum value
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// @return Clamped value
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  inline double clamp_query(double x, double xmin, double xmax) {
    9,950,736 (0.0%) 0        0                  0           0    0          0           0    0   4,975,368 (0.0%)         16  (0.0%)  0   0      if (x <= xmin) return xmin;
    9,950,736 (0.0%) 3 (0.0%) 1 (0.0%)           0           0    0          0           0    0   4,975,368 (0.0%)          3  (0.0%)  0   0      if (x >= xmax) {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          return std::nextafter(xmax, -std::numeric_limits<double>::infinity());
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      return x;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// 4D Tensor-Product B-Spline with FMA Optimization
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  ///
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  /// Evaluates 4D B-spline surfaces using tensor-product structure:
-- line 65 ----------------------------------------
-- line 84 ----------------------------------------
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> t,
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> v,
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> r,
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> coeff)
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          : m_(std::move(m)),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            t_(std::move(t)),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            v_(std::move(v)),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            r_(std::move(r)),
            4 (0.0%) 1 (0.0%) 1 (0.0%)           0           0    0          1 (0.0%)    0    0           0                 0          0   0            tm_(clamped_knots_cubic(m_)),
            3 (0.0%) 0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            tt_(clamped_knots_cubic(t_)),
            3 (0.0%) 0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            tv_(clamped_knots_cubic(v_)),
            3 (0.0%) 0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            tr_(clamped_knots_cubic(r_)),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            c_(std::move(coeff)),
            5 (0.0%) 1 (0.0%) 1 (0.0%)           0           0    0          1 (0.0%)    0    0           0                 0          0   0            Nm_(static_cast<int>(m_.size())),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            Nt_(static_cast<int>(t_.size())),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            Nv_(static_cast<int>(v_.size())),
            .        .        .                  .           .    .          .           .    .           .                 .          .   .            Nr_(static_cast<int>(r_.size()))
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nm_ >= 4 && "Moneyness grid must have ≥4 points");
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nt_ >= 4 && "Maturity grid must have ≥4 points");
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nv_ >= 4 && "Volatility grid must have ≥4 points");
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nr_ >= 4 && "Rate grid must have ≥4 points");
-- line 105 ----------------------------------------
-- line 109 ----------------------------------------
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// Evaluate B-spline at query point
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      ///
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param mq Moneyness query
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param tq Maturity query
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param vq Volatility query
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param rq Rate query
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// @return Interpolated value
   13,682,262 (0.0%) 3 (0.0%) 1 (0.0%)           0           0    0  7,463,052 (0.1%)    0    0           0                 0          0   0      double eval(double mq, double tq, double vq, double rq) const {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          // Clamp queries to domain
    4,975,368 (0.0%) 0        0          4,975,368 (0.0%)    0    0          0           0    0           0                 0          0   0          mq = clamp_query(mq, m_.front(), m_.back());
    4,975,368 (0.0%) 0        0          4,975,368 (0.0%)    0    0          0           0    0           0                 0          0   0          tq = clamp_query(tq, t_.front(), t_.back());
    4,975,368 (0.0%) 3 (0.0%) 1 (0.0%)   4,975,368 (0.0%)    0    0          0           0    0           0                 0          0   0          vq = clamp_query(vq, v_.front(), v_.back());
    4,975,368 (0.0%) 0        0          4,975,368 (0.0%)    0    0          0           0    0           0                 0          0   0          rq = clamp_query(rq, r_.front(), r_.back());
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          // Find knot spans
    2,487,684 (0.0%) 0        0          2,487,684 (0.0%)    0    0          0           0    0           0                 0          0   0          int im = find_span_cubic(tm_, mq);
    2,487,684 (0.0%) 0        0          2,487,684 (0.0%)    0    0          0           0    0           0                 0          0   0          int jt = find_span_cubic(tt_, tq);
    2,487,684 (0.0%) 0        0          2,487,684 (0.0%)    0    0          0           0    0           0                 0          0   0          int kv = find_span_cubic(tv_, vq);
    3,731,526 (0.0%) 0        0          2,487,684 (0.0%)    0    0  1,243,842 (0.0%)    0    0           0                 0          0   0          int lr = find_span_cubic(tr_, rq);
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          // Evaluate basis functions
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          double wm[4], wt[4], wv[4], wr[4];
   16,169,946 (0.0%) 3 (0.0%) 1 (0.0%)           0           0    0 11,194,578 (0.1%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tm_, im, mq, wm);
   11,194,578 (0.0%) 3 (0.0%) 1 (0.0%)   3,731,526 (0.0%)    0    0  2,487,684 (0.0%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tt_, jt, tq, wt);
   11,194,578 (0.0%) 3 (0.0%) 1 (0.0%)   4,975,368 (0.0%)    0    0  2,487,684 (0.0%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tv_, kv, vq, wv);
    8,706,894 (0.0%) 0        0          2,487,684 (0.0%)    0    0  1,243,842 (0.0%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tr_, lr, rq, wr);
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          // Tensor-product evaluation with FMA
    2,487,684 (0.0%) 0        0          1,243,842 (0.0%)    0    0          0           0    0           0                 0          0   0          double sum = 0.0;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
   19,901,472 (0.0%) 0        0                  0           0    0          0           0    0   4,975,368 (0.0%)  1,243,862  (1.0%)  0   0          for (int a = 0; a < 4; ++a) {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .              int im_idx = im - a;
   12,438,420 (0.0%) 3 (0.0%) 1 (0.0%)   1,243,842 (0.0%)    0    0          0           0    0   4,975,368 (0.0%)          4  (0.0%)  0   0              if (static_cast<unsigned>(im_idx) >= static_cast<unsigned>(Nm_)) continue;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
    4,975,368 (0.0%) 0        0          4,975,368 (0.0%)    0    0          0           0    0           0                 0          0   0              double wma = wm[a];
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
  104,482,728 (0.1%) 0        0         59,704,416 (0.2%)    0    0          0           0    0  19,901,472 (0.2%)  4,975,372  (4.2%)  0   0              for (int b = 0; b < 4; ++b) {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                  int jt_idx = jt - b;
  109,458,096 (0.1%) 0        0         24,876,840 (0.1%)    0    0          0           0    0  19,901,472 (0.2%)          6  (0.0%)  0   0                  if (static_cast<unsigned>(jt_idx) >= static_cast<unsigned>(Nt_)) continue;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
   60,948,258 (0.1%) 2 (0.0%) 1 (0.0%)  39,802,944 (0.1%)    0    0          0           0    0           0                 0          0   0                  double wtab = std::fma(wma, wt[b], 0.0);  // wma * wt[b]
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
  278,620,608 (0.3%) 0        0         19,901,472 (0.1%)    0    0          0           0    0  79,605,888 (0.7%) 19,901,477 (16.7%)  0   0                  for (int c = 0; c < 4; ++c) {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      int kv_idx = kv - c;
  358,226,496 (0.3%) 1 (0.0%) 1 (0.0%)  99,507,360 (0.3%)    0    0          0           0    0  79,605,888 (0.7%)          4  (0.0%)  0   0                      if (static_cast<unsigned>(kv_idx) >= static_cast<unsigned>(Nv_)) continue;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
  238,817,664 (0.2%) 2 (0.0%) 1 (0.0%) 159,211,776 (0.5%)    0    0          0           0    0           0                 0          0   0                      double wtabc = std::fma(wtab, wv[c], 0.0);  // wtab * wv[c]
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // Compute base index for coefficient array
   79,605,888 (0.1%) 0        0                  0           0    0          0           0    0           0                 0          0   0                      const std::size_t base =
  504,999,852 (0.5%) 2 (0.0%) 1 (0.0%) 100,751,202 (0.3%)    0    0 49,753,680 (0.6%)    0    0           0                 0          0   0                          (((std::size_t)im_idx * Nt_ + jt_idx) * Nv_ + kv_idx) * Nr_;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // Compute valid range for rate dimension (d ∈ [0,3])
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // We access coefficient at index (lr - d), which must satisfy 0 <= lr - d < Nr_
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // This gives: max(0, lr - Nr_ + 1) <= d <= min(3, lr)
  238,817,664 (0.2%) 0        0                  0           0    0          0           0    0           0                 0          0   0                      const int d_min = std::max(0, lr - (Nr_ - 1));
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      const int d_max = std::min(3, lr);
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // Get pointer to coefficient block for efficient streaming
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      const double* coeff_block = c_.data() + base;
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // Stream coefficients with no per-iteration branches
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // This replaces 4 separate if blocks with a tight loop,
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      // improving ILP and enabling CPU prefetching
  875,664,768 (0.9%) 0        0                  0           0    0          0           0    0 318,423,552 (2.7%)          8  (0.0%)  0   0                      for (int d = d_min; d <= d_max; ++d) {
  480,123,012 (0.5%) 3 (0.0%) 1 (0.0%)           0           0    0          0           0    0           0                 0          0   0                          const int lr_idx = lr - d;
1,518,731,082 (1.5%) 3 (0.0%) 1 (0.0%) 716,452,992 (2.2%)    0    0  1,243,842 (0.0%)    0    0           0                 0          0   0                          sum = std::fma(coeff_block[lr_idx], wtabc * wr[d], sum);
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                      }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .                  }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .              }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          return sum;
    9,950,736 (0.0%) 0        0          8,706,894 (0.0%)    0    0          0           0    0           0                 0          0   0      }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// Get grid dimensions
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      [[nodiscard]] std::tuple<int, int, int, int> dimensions() const noexcept {
            .        .        .                  .           .    .          .           .    .           .                 .          .   .          return {Nm_, Nt_, Nv_, Nr_};
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      }
            .        .        .                  .           .    .          .           .    .           .                 .          .   .  
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      /// Get moneyness grid
            .        .        .                  .           .    .          .           .    .           .                 .          .   .      [[nodiscard]] const std::vector<double>& moneyness_grid() const noexcept { return m_; }
-- line 191 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/bspline_utils.hpp
--------------------------------------------------------------------------------
Ir________________ I1mr_____ ILmr____ Dr_______________ D1mr____ DLmr Dw_______________ D1mw____ DLmw Bc_______________ Bcm_____________ Bi Bim 

-- line 20 ----------------------------------------
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// For n data points, creates n+4 knots with repeated endpoints:
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// [x[0], x[0], x[0], x[0], x[1], ..., x[n-4], x[n-1], x[n-1], x[n-1], x[n-1]]
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// The interior knots x[1] through x[n-4] are placed between the clamped endpoints.
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// This ensures the collocation matrix is non-singular (Schoenberg-Whitney condition).
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param x Grid points (must be sorted)
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @return Clamped knot vector
         88 (0.0%)  1 (0.0%) 0                 0        0           0         66 (0.0%) 0           0          0                0         0   0  inline std::vector<double> clamped_knots_cubic(const std::vector<double>& x) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .      const int n = static_cast<int>(x.size());
         22 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0      std::vector<double> t(n + 4);
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Left clamp: repeat first point 4 times
          .         .        .                 .        .           .          .        .           .          .                .         .   .      std::fill_n(t.begin(), 4, x.front());
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Interior knots positioned strictly between data sites (midpoints)
         22 (0.0%)  0        0                 0        0           0          0        0           0         11 (0.0%)         9 (0.0%)  0   0      if (n > 4) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .          const int interior = n - 4;
          5 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0          const int intervals = n - 1;
         15 (0.0%)  0        0                 0        0           0          0        0           0          5 (0.0%)         2 (0.0%)  0   0          for (int idx = 0; idx < interior; ++idx) {
         10 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0              const double ratio = static_cast<double>(idx + 1) /
         25 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0                                   static_cast<double>(interior + 1);
         40 (0.0%)  1 (0.0%) 1 (0.0%)         15 (0.0%) 0           0          0        0           0          0                0         0   0              double pos = ratio * static_cast<double>(intervals);
         10 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0              int low = static_cast<int>(std::floor(pos));
         10 (0.0%)  0        0                 0        0           0          0        0           0          5 (0.0%)         4 (0.0%)  0   0              if (low >= intervals) {
         10 (0.0%)  0        0                 5 (0.0%) 1 (0.0%)    0          0        0           0          0                0         0   0                  low = intervals - 1;
          .         .        .                 .        .           .          .        .           .          .                .         .   .              }
         10 (0.0%)  1 (0.0%) 1 (0.0%)          0        0           0          0        0           0          0                0         0   0              const double frac = pos - static_cast<double>(low);
         11 (0.0%)  0        0                 6 (0.0%) 0           0          0        0           0          0                0         0   0              const double left = x[low];
         16 (0.0%)  0        0                 6 (0.0%) 0           0          0        0           0          0                0         0   0              const double right = x[low + 1];
         17 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0              double knot = (1.0 - frac) * left + frac * right;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          6 (0.0%)  1 (0.0%) 1 (0.0%)          0        0           0          0        0           0          0                0         0   0              const double spacing = right - left;
          7 (0.0%)  0        0                 1 (0.0%) 0           0          0        0           0          0                0         0   0              const double eps = std::max(1e-12 * spacing,
         18 (0.0%)  0        0                 2 (0.0%) 0           0          0        0           0          0                0         0   0                                          std::numeric_limits<double>::epsilon() *
          .         .        .                 .        .           .          .        .           .          .                .         .   .                                              std::max(std::abs(right), 1.0));
         18 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0              knot = std::clamp(knot, left + eps, right - eps);
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
         12 (0.0%)  0        0                 0        0           0          6 (0.0%) 0           0          0                0         0   0              t[4 + idx] = knot;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          }
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Right clamp: repeat last point 4 times
          .         .        .                 .        .           .          .        .           .          .                .         .   .      std::fill_n(t.end() - 4, 4, x.back());
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      return t;
         99 (0.0%)  0        0                77 (0.0%) 0           0          0        0           0          0                0         0   0  }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// Find knot span containing x using binary search
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// Returns index i such that t[i] <= x < t[i+1]
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param t Knot vector
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param x Query point
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @return Knot span index
          .         .        .                 .        .           .          .        .           .          .                .         .   .  inline int find_span_cubic(const std::vector<double>& t, double x) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .      constexpr int DEGREE = 3;
  4,976,088 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0      const int n_ctrl = static_cast<int>(t.size()) - DEGREE - 1;
          .         .        .                 .        .           .          .        .           .          .                .         .   .      const int min_span = DEGREE;
  8,707,254 (0.0%)  3 (0.0%) 1 (0.0%)          0        0           0          0        0           0          0                0         0   0      const int max_span = std::max(min_span, n_ctrl - 1);
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
 14,930,904 (0.0%)  3 (0.0%) 1 (0.0%)  4,976,968 (0.0%) 0           0          0        0           0  4,976,968 (0.0%)         8 (0.0%)  0   0      if (x <= t[min_span]) {
      1,080 (0.0%)  0        0                 0        0           0        360 (0.0%) 0           0          0                0         0   0          return min_span;
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
 14,931,424 (0.0%)  0        0         4,978,728 (0.0%) 0           0        360 (0.0%) 0           0  4,976,608 (0.0%)       208 (0.0%)  0   0      if (x >= t[n_ctrl]) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .          return max_span;
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      auto it = std::upper_bound(t.begin() + min_span, t.begin() + n_ctrl + 1, x);
  8,707,774 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0      int i = static_cast<int>(std::distance(t.begin(), it)) - 1;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
 11,197,218 (0.0%)  9 (0.0%) 3 (0.1%)  3,731,526 (0.0%) 0           0          0        0           0          0                0         0   0      if (i < min_span) i = min_span;
  9,953,376 (0.0%)  0        0               880 (0.0%) 0           0  1,243,842 (0.0%) 0           0          0                0         0   0      if (i > max_span) i = max_span;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      return i;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// Evaluate cubic basis functions using Cox-de Boor recursion
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// Computes the 4 nonzero cubic basis functions at x for knot span i.
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// Uses de Boor's recursive formula with proper handling of zero denominators.
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param t Knot vector
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param i Knot span index
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param x Evaluation point
          .         .        .                 .        .           .          .        .           .          .                .         .   .  /// @param N Output: 4 basis function values N[0..3]
          .         .        .                 .        .           .          .        .           .          .                .         .   .  ///          N[0] corresponds to basis i, N[1] to i-1, N[2] to i-2, N[3] to i-3
 24,883,760 (0.0%)  0        0                 0        0           0  4,976,608 (0.1%) 0           0          0                0         0   0  inline void cubic_basis_nonuniform(const std::vector<double>& t, int i, double x, double N[4]) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .      const int n = static_cast<int>(t.size());
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Ensure exact interpolation at the right boundary.
 19,907,872 (0.0%)  3 (0.0%) 1 (0.0%)  9,953,936 (0.0%) 0           0          0        0           0  4,976,968 (0.0%)         2 (0.0%)  0   0      if (std::abs(x - t.back()) < 1e-14) {
      1,440 (0.0%)  0        0               720 (0.0%) 0           0        360 (0.0%) 0           0          0                0         0   0          N[0] = 1.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          N[1] = 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          N[2] = 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          N[3] = 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          return;
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Degree 0: piecewise constants
  9,953,216 (0.0%)  3 (0.0%) 1 (0.0%)          0        0           0  4,976,608 (0.1%) 1 (0.0%)    0          0                0         0   0      double N0[4] = {0, 0, 0, 0};
          .         .        .                 .        .           .          .        .           .          .                .         .   .      for (int k = 0; k < 4; ++k) {
 14,929,824 (0.0%)  0        0                 0        0           0          0        0           0          0                0         0   0          int idx = i - k;
 34,836,256 (0.0%)  0        0                 0        0           0          0        0           0 14,929,824 (0.1%)         6 (0.0%)  0   0          if (idx >= 0 && idx + 1 < n) {
184,134,496 (0.2%) 16 (0.0%) 5 (0.1%) 59,719,296 (0.2%) 0           0 19,906,432 (0.2%) 0           0 19,906,432 (0.2%)        21 (0.0%)  0   0              N0[k] = (t[idx] <= x && x < t[idx + 1]) ? 1.0 : 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          }
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Degree 1: linear combination
  9,953,216 (0.0%)  0        0                 0        0           0  4,976,608 (0.1%) 0           0          0                0         0   0      double N1[4] = {0, 0, 0, 0};
          .         .        .                 .        .           .          .        .           .          .                .         .   .      for (int k = 0; k < 4; ++k) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .          int idx = i - k;
 24,883,040 (0.0%)  1 (0.0%) 1 (0.0%)          0        0           0          0        0           0  9,953,216 (0.1%)         0         0   0          if (idx >= 0 && idx + 2 < n) {
 79,625,728 (0.1%)  3 (0.0%) 1 (0.0%) 39,812,864 (0.1%) 0           0          0        0           0          0                0         0   0              double leftDen  = t[idx + 1] - t[idx];
 29,859,648 (0.0%)  0        0        14,929,824 (0.0%) 0           0          0        0           0          0                0         0   0              double rightDen = t[idx + 2] - t[idx + 1];
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
106,482,964 (0.1%)  8 (0.0%) 2 (0.0%)  6,950,804 (0.0%) 0           0          0        0           0 19,906,432 (0.2%) 1,974,366 (1.7%)  0   0              double left  = (leftDen > 0.0) ? (x - t[idx]) / leftDen * N0[k] : 0.0;
 80,571,708 (0.1%)  7 (0.0%) 3 (0.1%)  6,950,804 (0.0%) 0           0          0        0           0 14,929,824 (0.1%)         4 (0.0%)  0   0              double right = (rightDen > 0.0 && k > 0) ? (t[idx + 2] - x) / rightDen * N0[k - 1] : 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
 49,766,080 (0.0%)  4 (0.0%) 2 (0.0%)          0        0           0 19,906,432 (0.2%) 0           0          0                0         0   0              N1[k] = left + right;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          }
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Degree 2: quadratic
  9,953,216 (0.0%)  0        0                 0        0           0  4,976,608 (0.1%) 0           0          0                0         0   0      double N2[4] = {0, 0, 0, 0};
          .         .        .                 .        .           .          .        .           .          .                .         .   .      for (int k = 0; k < 4; ++k) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .          int idx = i - k;
 34,836,256 (0.0%)  4 (0.0%) 2 (0.0%)          0        0           0          0        0           0 14,929,824 (0.1%)         0         0   0          if (idx >= 0 && idx + 3 < n) {
 79,625,728 (0.1%)  0        0        39,812,864 (0.1%) 0           0          0        0           0          0                0         0   0              double leftDen  = t[idx + 2] - t[idx];
 29,859,648 (0.0%)  6 (0.0%) 2 (0.0%) 29,859,648 (0.1%) 0           0          0        0           0          0                0         0   0              double rightDen = t[idx + 3] - t[idx + 1];
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
111,459,572 (0.1%)  5 (0.0%) 1 (0.0%) 11,927,412 (0.0%) 0           0          0        0           0 19,906,432 (0.2%) 1,974,204 (1.7%)  0   0              double left  = (leftDen > 0.0) ? (x - t[idx]) / leftDen * N1[k] : 0.0;
 95,501,532 (0.1%)  7 (0.0%) 3 (0.1%) 11,927,412 (0.0%) 0           0          0        0           0 14,929,824 (0.1%)       730 (0.0%)  0   0              double right = (rightDen > 0.0 && k > 0) ? (t[idx + 3] - x) / rightDen * N1[k - 1] : 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
 44,789,472 (0.0%)  0        0                 0        0           0 19,906,432 (0.2%) 0           0          0                0         0   0              N2[k] = left + right;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          }
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .      // Degree 3: cubic
          .         .        .                 .        .           .          .        .           .          .                .         .   .      for (int k = 0; k < 4; ++k) {
          .         .        .                 .        .           .          .        .           .          .                .         .   .          int idx = i - k;
 59,719,296 (0.1%)  6 (0.0%) 2 (0.0%)          0        0           0          0        0           0 19,906,432 (0.2%)         4 (0.0%)  0   0          if (idx >= 0 && idx + 4 < n) {
 74,649,120 (0.1%)  3 (0.0%) 1 (0.0%) 39,812,864 (0.1%) 0           0          0        0           0          0                0         0   0              double leftDen  = t[idx + 3] - t[idx];
 29,859,648 (0.0%)  0        0        29,859,648 (0.1%) 0           0          0        0           0          0                0         0   0              double rightDen = t[idx + 4] - t[idx + 1];
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
 96,529,748 (0.1%)  6 (0.0%) 2 (0.0%) 16,904,020 (0.1%) 0           0          0        0           0 19,906,432 (0.2%) 1,974,210 (1.7%)  0   0              double left  = (leftDen > 0.0) ? (x - t[idx]) / leftDen * N2[k] : 0.0;
 99,532,160 (0.1%)  3 (0.0%) 1 (0.0%) 14,929,824 (0.0%) 0           0          0        0           0 14,929,824 (0.1%)         4 (0.0%)  0   0              double right = (rightDen > 0.0 && k > 0) ? (t[idx + 4] - x) / rightDen * N2[k - 1] : 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
 59,719,296 (0.1%)  0        0                 0        0           0 19,906,432 (0.2%) 0           0          0                0         0   0              N[k] = left + right;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          } else {
          .         .        .                 .        .           .          .        .           .          .                .         .   .              N[k] = 0.0;
          .         .        .                 .        .           .          .        .           .          .                .         .   .          }
          .         .        .                 .        .           .          .        .           .          .                .         .   .      }
  9,953,216 (0.0%)  0        0         9,953,216 (0.0%) 0           0          0        0           0          0                0         0   0  }
          .         .        .                 .        .           .          .        .           .          .                .         .   .  
          .         .        .                 .        .           .          .        .           .          .                .         .   .  }  // namespace mango

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/operators/black_scholes_pde.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr____ ILmr____ Dr________________ D1mr____ DLmr____ Dw__________ D1mw DLmw Bc Bcm Bi Bim 

-- line 20 ----------------------------------------
            .        .        .                  .        .        .            .           .    .  .   .  .   .  public:
            .        .        .                  .        .        .            .           .    .  .   .  .   .      /**
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Construct Black-Scholes operator
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @param sigma Volatility (σ)
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @param r Risk-free rate
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @param d Continuous dividend yield
            .        .        .                  .        .        .            .           .    .  .   .  .   .       */
            .        .        .                  .        .        .            .           .    .  .   .  .   .      BlackScholesPDE(T sigma, T r, T d)
        3,332 (0.0%) 0        0              1,666 (0.0%) 8 (0.0%) 1 (0.0%)     0           0    0  0   0  0   0          : half_sigma_sq_(T(0.5) * sigma * sigma)
        6,548 (0.0%) 5 (0.0%) 1 (0.0%)       1,666 (0.0%) 0        0        1,608 (0.0%)    0    0  0   0  0   0          , drift_(r - d - half_sigma_sq_)
            .        .        .                  .        .        .            .           .    .  .   .  .   .          , discount_rate_(r)
            .        .        .                  .        .        .            .           .    .  .   .  .   .      {}
            .        .        .                  .        .        .            .           .    .  .   .  .   .  
            .        .        .                  .        .        .            .           .    .  .   .  .   .      /**
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Apply operator: L(V) = (σ²/2)·∂²V/∂x² + (r-d-σ²/2)·∂V/∂x - r·V
            .        .        .                  .        .        .            .           .    .  .   .  .   .       *
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @param d2v_dx2 Second derivative ∂²V/∂x²
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @param dv_dx First derivative ∂V/∂x
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @param v Value V
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * @return L(V)
            .        .        .                  .        .        .            .           .    .  .   .  .   .       */
            .        .        .                  .        .        .            .           .    .  .   .  .   .      T operator()(T d2v_dx2, T dv_dx, T v) const {
1,480,398,000 (1.4%) 7 (0.0%) 1 (0.0%) 740,199,000 (2.2%) 0        0            0           0    0  0   0  0   0          return half_sigma_sq_ * d2v_dx2 + drift_ * dv_dx - discount_rate_ * v;
            .        .        .                  .        .        .            .           .    .  .   .  .   .      }
            .        .        .                  .        .        .            .           .    .  .   .  .   .  
            .        .        .                  .        .        .            .           .    .  .   .  .   .      /**
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Compute first derivative coefficient: (r - d - σ²/2)
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Used for finite difference Jacobian construction
            .        .        .                  .        .        .            .           .    .  .   .  .   .       */
    3,500,000 (0.0%) 0        0          3,500,000 (0.0%) 0        0            0           0    0  0   0  0   0      T first_derivative_coeff() const { return drift_; }
            .        .        .                  .        .        .            .           .    .  .   .  .   .  
            .        .        .                  .        .        .            .           .    .  .   .  .   .      /**
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Compute second derivative coefficient: σ²/2
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Used for finite difference Jacobian construction
            .        .        .                  .        .        .            .           .    .  .   .  .   .       */
    3,500,000 (0.0%) 0        0          3,500,000 (0.0%) 0        0            0           0    0  0   0  0   0      T second_derivative_coeff() const { return half_sigma_sq_; }
            .        .        .                  .        .        .            .           .    .  .   .  .   .  
            .        .        .                  .        .        .            .           .    .  .   .  .   .      /**
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Compute discount rate: r
            .        .        .                  .        .        .            .           .    .  .   .  .   .       * Used for finite difference Jacobian construction
            .        .        .                  .        .        .            .           .    .  .   .  .   .       */
    3,500,000 (0.0%) 0        0          3,500,000 (0.0%) 0        0            0           0    0  0   0  0   0      T discount_rate() const { return discount_rate_; }
            .        .        .                  .        .        .            .           .    .  .   .  .   .  
            .        .        .                  .        .        .            .           .    .  .   .  .   .  private:
            .        .        .                  .        .        .            .           .    .  .   .  .   .      T half_sigma_sq_;    // σ²/2
            .        .        .                  .        .        .            .           .    .  .   .  .   .      T drift_;            // r - d - σ²/2
            .        .        .                  .        .        .            .           .    .  .   .  .   .      T discount_rate_;    // r
            .        .        .                  .        .        .            .           .    .  .   .  .   .  };
            .        .        .                  .        .        .            .           .    .  .   .  .   .  
            .        .        .                  .        .        .            .           .    .  .   .  .   .  } // namespace mango::operators
-- line 69 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/operators/centered_difference.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr_____ ILmr____ Dr________________ D1mr_________ DLmr Dw________________ D1mw_____________ DLmw________ Bc________________ Bcm_____________ Bi Bim 

-- line 30 ----------------------------------------
            .         .        .                  .             .           .           .                .             .                  .                .         .   .  template<std::floating_point T = double>
            .         .        .                  .             .           .           .                .             .                  .                .         .   .  class CenteredDifference {
            .         .        .                  .             .           .           .                .             .                  .                .         .   .  public:
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      /**
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       * Construct centered difference stencil
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       * @param spacing Grid spacing information
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       */
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      explicit CenteredDifference(const GridSpacing<T>& spacing)
        1,608 (0.0%)  0        0                  0             0           0       1,608 (0.0%)        10  (0.0%)     0                  0                0         0   0          : spacing_(spacing)
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      {}
            .         .        .                  .             .           .           .                .             .                  .                .         .   .  
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      /**
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       * Compute first derivative at interior point i
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       * @param u Field values
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       * @param i Interior point index (must satisfy 1 <= i < n-1)
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       * @return du/dx at point i
            .         .        .                  .             .           .           .                .             .                  .                .         .   .       */
-- line 46 ----------------------------------------
-- line 108 ----------------------------------------
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      // Optimized vectorized path for uniform grids (fused kernel)
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      // Evaluator: (T d2u_dx2, T du_dx, T u) -> T
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      template<typename Evaluator>
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      void apply_uniform(std::span<const T> u,
            .         .        .                  .             .           .           .                .             .                  .                .         .   .                        std::span<T> Lu,
            .         .        .                  .             .           .           .                .             .                  .                .         .   .                        size_t start,
            .         .        .                  .             .           .           .                .             .                  .                .         .   .                        size_t end,
            .         .        .                  .             .           .           .                .             .                  .                .         .   .                        Evaluator&& eval) const {
   17,394,128 (0.0%)  0        0         17,394,128 (0.1%) 89,064 (0.2%)    0           0                0             0                  0                0         0   0          const T half_dx_inv = spacing_.spacing_inv() * T(0.5);
            .         .        .                  .             .           .           .                .             .                  .                .         .   .          const T dx2_inv = spacing_.spacing_inv_sq();
            .         .        .                  .             .           .           .                .             .                  .                .         .   .  
            .         .        .                  .             .           .           .                .             .                  .                .         .   .          MANGO_PRAGMA_SIMD
            .         .        .                  .             .           .           .                .             .                  .                .         .   .          for (size_t i = start; i < end; ++i) {
1,065,205,576 (1.0%) 27 (0.0%) 4 (0.1%) 536,951,320 (1.6%)      0           0           0                0             0                  0                0         0   0              const T du_dx = (u[i+1] - u[i-1]) * half_dx_inv;
            .         .        .                  .             .           .           .                .             .                  .                .         .   .              // d2u_dx2 = (u[i+1] + u[i-1] - 2*u[i]) * dx2_inv
            .         .        .                  .             .           .           .                .             .                  .                .         .   .              // Use FMA: std::fma(x, y, z) = x*y + z
1,285,847,384 (1.3%) 20 (0.0%) 3 (0.1%) 272,824,192 (0.8%)      0           0           0                0             0                  0                0         0   0              const T d2u_dx2 = std::fma(u[i+1] + u[i-1], dx2_inv, -T(2)*u[i]*dx2_inv);
1,096,493,832 (1.1%) 32 (0.0%) 2 (0.0%)  13,894,128 (0.0%)      0           0 255,430,064 (3.1%) 7,272,366 (13.5%) 8,294 (5.6%) 264,127,128 (2.2%) 8,697,285 (7.3%)  0   0              Lu[i] = eval(d2u_dx2, du_dx, u[i]);  // Lambda inlines away
            .         .        .                  .             .           .           .                .             .                  .                .         .   .          }
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      }
            .         .        .                  .             .           .           .                .             .                  .                .         .   .  
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      // General path for non-uniform grids
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      template<typename Evaluator>
            .         .        .                  .             .           .           .                .             .                  .                .         .   .      void apply_non_uniform(std::span<const T> u,
            .         .        .                  .             .           .           .                .             .                  .                .         .   .                            std::span<T> Lu,
            .         .        .                  .             .           .           .                .             .                  .                .         .   .                            size_t start,
-- line 133 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/operators/grid_spacing.hpp
--------------------------------------------------------------------------------
Ir_______________ I1mr_____ ILmr____ Dr_______________ D1mr DLmr Dw______________ D1mw______ DLmw______ Bc_______________ Bcm_____ Bi Bim 

-- line 21 ----------------------------------------
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  template<typename T = double>
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  class GridSpacing {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  public:
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      /**
         .         .        .                 .           .    .         .          .          .                 .        .         .   .       * Create grid spacing from a grid view
         .         .        .                 .           .    .         .          .          .                 .        .         .   .       * @param grid Grid points (non-owning view)
         .         .        .                 .           .    .         .          .          .                 .        .         .   .       */
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      explicit GridSpacing(GridView<T> grid)
     3,224 (0.0%)  0        0                 0           0    0     3,224 (0.0%)  22 (0.0%)   0                 0        0         0   0          : grid_(grid)
     1,612 (0.0%)  0        0                 0           0    0     1,612 (0.0%) 650 (0.0%) 650 (0.4%)          0        0         0   0          , is_uniform_(grid.is_uniform())
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          const size_t n = grid.size();
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          if (n < 2) return;
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          if (is_uniform_) {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              // Uniform grid: compute once
     3,224 (0.0%)  0        0                 0           0    0     1,612 (0.0%)   0          0                 0        0         0   0              dx_uniform_ = (grid.x_max() - grid.x_min()) / static_cast<T>(n - 1);
     3,224 (0.0%)  0        0             1,612 (0.0%)    0    0         0          0          0                 0        0         0   0              dx_uniform_inv_ = T(1) / dx_uniform_;
     3,224 (0.0%)  0        0                 0           0    0     1,612 (0.0%)   0          0                 0        0         0   0              dx_uniform_inv_sq_ = dx_uniform_inv_ * dx_uniform_inv_;
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          } else {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              // Non-uniform grid: pre-compute all spacings
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              dx_array_.reserve(n - 1);
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              for (size_t i = 0; i < n - 1; ++i) {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .                  dx_array_.push_back(grid[i + 1] - grid[i]);
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      // Query if grid is uniform
 8,697,064 (0.0%)  5 (0.0%) 1 (0.0%)  8,697,064 (0.0%)    0    0         0          0          0                 0        0         0   0      bool is_uniform() const { return is_uniform_; }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      // Get uniform spacing (only valid if is_uniform())
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      T spacing() const {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          assert(is_uniform_ && "spacing() requires uniform grid");
 3,500,000 (0.0%)  0        0         3,500,000 (0.0%)    0    0         0          0          0                 0        0         0   0          return dx_uniform_;
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
 6,947,064 (0.0%)  0        0         6,947,064 (0.0%)    0    0         0          0          0                 0        0         0   0      T spacing_inv() const {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          assert(is_uniform_ && "spacing_inv() requires uniform grid");
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          return dx_uniform_inv_;
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
69,629,448 (0.1%) 15 (0.0%) 2 (0.0%) 22,591,192 (0.1%)    0    0         0          0          0        17,394,128 (0.1%) 2 (0.0%)  0   0      T spacing_inv_sq() const {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          assert(is_uniform_ && "spacing_inv_sq() requires uniform grid");
29,591,192 (0.0%)  7 (0.0%) 1 (0.0%)  8,697,064 (0.0%)    0    0 3,500,000 (0.0%)   0          0                 0        0         0   0          return dx_uniform_inv_sq_;
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      // Get spacing at point i: dx[i] = x[i+1] - x[i]
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      // Valid for i in [0, n-2]
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      T spacing_at(size_t i) const {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          assert(i < grid_.size() - 1 && "spacing_at(i) requires i < n-1");
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          if (is_uniform_) {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              return dx_uniform_;
-- line 73 ----------------------------------------
-- line 82 ----------------------------------------
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      // Left and right spacing for non-uniform centered differences
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      // Preconditions:
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      //   left_spacing(i):  requires 1 <= i < size()
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      //   right_spacing(i): requires 0 <= i < size()-1
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      T left_spacing(size_t i) const {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          assert(i >= 1 && i < grid_.size() && "left_spacing: index out of bounds");
13,894,128 (0.0%)  7 (0.0%) 1 (0.0%)          0           0    0         0          0          0                 0        0         0   0          if (is_uniform_) {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              return dx_uniform_;
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          } else {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .              return dx_array_[i - 1];  // dx[i-1] = x[i] - x[i-1]
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      }
         .         .        .                 .           .    .         .          .          .                 .        .         .   .  
         .         .        .                 .           .    .         .          .          .                 .        .         .   .      T right_spacing(size_t i) const {
         .         .        .                 .           .    .         .          .          .                 .        .         .   .          assert(i < grid_.size() - 1 && "right_spacing: index out of bounds");
-- line 98 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/operators/spatial_operator.hpp
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr____ Dr_______________ D1mr_________ DLmr____ Dw________________ D1mw____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 38 ----------------------------------------
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      { pde.discount_rate() } -> std::convertible_to<double>;            // r (c = -r)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  };
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  /// SpatialOperator: Composes PDE, GridSpacing, and CenteredDifference
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  ///
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  /// Note: Uses std::fma in Jacobian assembly for improved precision and performance.
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  /// Therefore T must be a standard floating-point type (float, double, long double).
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  template<typename PDE, std::floating_point T = double>
      4,998 (0.0%)     0        0                 0             0        0              4,998 (0.0%)       703 (0.0%) 31 (0.0%)           0                0         0   0  class SpatialOperator {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  public:
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      SpatialOperator(PDE pde, std::shared_ptr<GridSpacing<T>> spacing)
      6,432 (0.0%)     0        0             3,216 (0.0%)      6 (0.0%) 0              3,216 (0.0%)         0         0                  0                0         0   0          : pde_(std::move(pde))
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          , spacing_(std::move(spacing))
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          , stencil_(*spacing_)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      {}
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      /// Get interior range for this stencil (3-point: [1, n-1))
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      /// Precondition: n >= GridSpacing<T>::min_stencil_size() (i.e., n >= 3)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      StencilInterior interior_range(size_t n) const {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          assert(n >= GridSpacing<T>::min_stencil_size() && "Grid too small for stencil");
 33,250,000 (0.0%)     5 (0.0%) 1 (0.0%)  3,500,000 (0.0%)      0        0         10,500,000 (0.1%)         0         0                  0                0         0   0          return {1, n - 1};  // 3-point stencil width
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      /// Apply operator to full grid (convenience)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      void apply(double t, std::span<const T> u, std::span<T> Lu) const {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          const auto range = interior_range(u.size());
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          apply_interior(t, u, Lu, range.start, range.end);
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
-- line 66 ----------------------------------------
-- line 76 ----------------------------------------
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              if constexpr (TimeDependentPDE<PDE>) {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  return pde_(t, d2u, du, val);  // Time-dependent PDE
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              } else {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  return pde_(d2u, du, val);     // Time-independent PDE
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          };
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          // Dispatch to appropriate stencil strategy
 17,394,128 (0.0%)    23 (0.0%) 1 (0.0%)  8,697,064 (0.0%) 89,064 (0.2%) 0                  0                0         0          8,697,064 (0.1%)         0         0   0          if (spacing_->is_uniform()) {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              stencil_.apply_uniform(u, Lu, start, end, eval);
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          } else {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              stencil_.apply_non_uniform(u, Lu, start, end, eval);
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      /// Greeks computation (delegates to stencil)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      void compute_first_derivative(std::span<const T> u,
-- line 92 ----------------------------------------
-- line 116 ----------------------------------------
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          // Get PDE coefficients
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          const T a = pde_.second_derivative_coeff();  // σ²/2
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          const T b = pde_.first_derivative_coeff();   // r - d - σ²/2
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          const T c = -pde_.discount_rate();           // -r
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          const size_t n = jac.size();
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
  7,000,000 (0.0%)     0        0         3,500,000 (0.0%) 30,003 (0.1%) 3 (0.0%)           0                0         0          3,500,000 (0.0%)         2 (0.0%)  0   0          if (spacing_->is_uniform()) {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // Uniform grid: constant coefficients (O(1) compute + O(n) fill)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              const T dx = spacing_->spacing();
  3,500,000 (0.0%)     0        0                 0             0        0                  0                0         0                  0                0         0   0              const T dx_sq = dx * dx;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // Jacobian of L(u): ∂L/∂u
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // Use FMA for coefficient computations
 24,500,000 (0.0%)    11 (0.0%) 1 (0.0%)  7,000,000 (0.0%)      0        0                  0                0         0                  0                0         0   0              const T jac_lower_coeff = std::fma(a, T(1) / dx_sq, -b / (T(2) * dx));
  7,000,000 (0.0%)     0        0         3,500,000 (0.0%)      0        0                  0                0         0                  0                0         0   0              const T jac_diag_coeff = std::fma(T(-2) * a, T(1) / dx_sq, c);
  3,500,000 (0.0%)     0        0                 0             0        0                  0                0         0                  0                0         0   0              const T jac_upper_coeff = std::fma(a, T(1) / dx_sq, b / (T(2) * dx));
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // F(u) = u - rhs - coeff_dt·L(u)
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // ∂F/∂u = I - coeff_dt·∂L/∂u
 10,500,000 (0.0%)    11 (0.0%) 1 (0.0%)  7,000,000 (0.0%)      0        0                  0                0         0                  0                0         0   0              const T lower = -coeff_dt * jac_lower_coeff;
  7,000,000 (0.0%)     0        0                 0             0        0                  0                0         0                  0                0         0   0              const T diag = 1.0 - coeff_dt * jac_diag_coeff;
  3,500,000 (0.0%)     0        0                 0             0        0                  0                0         0                  0                0         0   0              const T upper = -coeff_dt * jac_upper_coeff;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // Fill interior points
449,000,000 (0.4%) 3,132 (2.1%) 2 (0.0%)          0             0        0                  0                0         0        124,000,000 (1.1%) 3,500,006 (2.9%)  0   0              for (size_t i = 1; i < n - 1; ++i) {
106,500,000 (0.1%) 3,219 (2.2%) 2 (0.0%)          0             0        0        103,000,000 (1.2%) 3,630,030 (6.7%) 30 (0.0%)           0                0         0   0                  jac.lower()[i - 1] = lower;
106,500,000 (0.1%)     0        0                 0             0        0        103,000,000 (1.2%) 3,690,031 (6.8%) 31 (0.0%)           0                0         0   0                  jac.diag()[i] = diag;
106,500,000 (0.1%)     9 (0.0%) 1 (0.0%)          0             0        0        103,000,000 (1.2%) 3,720,032 (6.9%) 32 (0.0%)           0                0         0   0                  jac.upper()[i] = upper;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          } else {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              // Non-uniform grid: per-point coefficients (O(n))
  3,500,000 (0.0%)     0        0                 0             0        0                  0                0         0                  0                0         0   0              for (size_t i = 1; i < n - 1; ++i) {
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  // Get local grid spacing
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T dx_left = spacing_->left_spacing(i);    // x[i] - x[i-1]
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T dx_right = spacing_->right_spacing(i);  // x[i+1] - x[i]
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T dx_avg = (dx_left + dx_right) / 2.0;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  // Second derivative: (u[i-1]/dx_left - u[i]*(1/dx_left + 1/dx_right) + u[i+1]/dx_right) / dx_avg
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T d2_coeff_im1 = a / (dx_left * dx_avg);
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T d2_coeff_i = -a * (1.0 / dx_left + 1.0 / dx_right) / dx_avg;
-- line 157 ----------------------------------------
-- line 163 ----------------------------------------
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T d1_coeff_ip1 = b / d1_denom;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  // Jacobian of L(u): ∂L_i/∂u
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T jac_lower_i = d2_coeff_im1 + d1_coeff_im1;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T jac_diag_i = d2_coeff_i + c;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  const T jac_upper_i = d2_coeff_ip1 + d1_coeff_ip1;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  // F(u) = u - rhs - coeff_dt·L(u), so ∂F/∂u = I - coeff_dt·∂L/∂u
229,253,112 (0.2%)    14 (0.0%) 2 (0.0%) 13,894,128 (0.0%)      0        0          6,947,064 (0.1%)         0         0         27,788,256 (0.2%)         0         0   0                  jac.lower()[i - 1] = -coeff_dt * jac_lower_i;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  jac.diag()[i] = 1.0 - coeff_dt * jac_diag_i;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .                  jac.upper()[i] = -coeff_dt * jac_upper_i;
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .              }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          }
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .  
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          // Note: Boundary rows (i=0, i=n-1) are NOT filled here.
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .          // They must be handled separately based on boundary condition types.
          .            .        .                 .             .        .                  .                .         .                  .                .         .   .      }
-- line 179 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde_solver.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr________ ILmr____ Dr__________________ D1mr_____________ DLmr_____ Dw________________ D1mw____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 60 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// Cache blocking is automatically applied for large grids (n ≥ threshold)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// to improve cache locality and reduce memory bandwidth.
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// @tparam BoundaryL Left boundary condition type
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// @tparam BoundaryR Right boundary condition type
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// @tparam SpatialOp Spatial operator type
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  template<typename BoundaryL, typename BoundaryR, typename SpatialOp>
       21,658 (0.0%)     9 (0.0%) 1 (0.0%)         8,330 (0.0%)         0          0              6,664 (0.0%)         0         0                  0                0         0   0  class PDESolver {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  public:
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Constructor
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param grid Spatial grid (x coordinates)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param time Time domain configuration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param config TR-BDF2 configuration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param root_config Root-finding configuration for Newton solver
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param left_bc Left boundary condition
-- line 76 ----------------------------------------
-- line 81 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const TimeDomain& time,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const TRBDF2Config& config,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const RootFindingConfig& root_config,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const BoundaryL& left_bc,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const BoundaryR& right_bc,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const SpatialOp& spatial_op,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                std::optional<ObstacleCallback> obstacle = std::nullopt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                WorkspaceStorage* external_workspace = nullptr)
        6,664 (0.0%) 1,539 (1.0%) 1 (0.0%)         3,332 (0.0%)         6  (0.0%)  0              3,332 (0.0%)         0         0                  0                0         0   0          : grid_(grid)
        6,664 (0.0%) 1,648 (1.1%) 1 (0.0%)             0                0          0              6,664 (0.0%)       703 (0.0%) 31 (0.0%)           0                0         0   0          , time_(time)
        3,332 (0.0%)     0        0                1,666 (0.0%)        27  (0.0%)  0              1,666 (0.0%)         0         0                  0                0         0   0          , config_(config)
        3,332 (0.0%)     0        0                1,666 (0.0%)        27  (0.0%)  0              1,666 (0.0%)         0         0                  0                0         0   0          , root_config_(root_config)
        1,666 (0.0%) 1,662 (1.1%) 1 (0.0%)             0                0          0              1,666 (0.0%)       702 (0.0%) 31 (0.0%)           0                0         0   0          , left_bc_(left_bc)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , right_bc_(right_bc)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , spatial_op_(spatial_op)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , obstacle_(std::move(obstacle))
        3,332 (0.0%)     0        0                1,666 (0.0%)         0          0              1,666 (0.0%)         0         0                  0                0         0   0          , n_(grid.size())
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , workspace_owner_(nullptr)
        1,666 (0.0%)     0        0                    0                0          0              1,666 (0.0%)         0         0                  0                0         0   0          , workspace_(nullptr)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , u_current_(n_)
        1,666 (0.0%)     0        0                1,666 (0.0%)         0          0                  0                0         0                  0                0         0   0          , u_old_(n_)
        1,666 (0.0%)     0        0                1,666 (0.0%)         0          0                  0                0         0                  0                0         0   0          , rhs_(n_)
        4,998 (0.0%)     8 (0.0%) 1 (0.0%)         1,666 (0.0%)         0          0              3,332 (0.0%)         0         0                  0                0         0   0          , newton_ws_(n_, acquire_workspace(grid, external_workspace))
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Initialize grid information for legacy operators that need it
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // (e.g., LaplacianOperator) via set_grid() if present
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (requires { spatial_op_.set_grid(grid, workspace_->dx()); }) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              spatial_op_.set_grid(grid, workspace_->dx());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
-- line 111 ----------------------------------------
-- line 120 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double t = time_.t_start();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_obstacle(t, std::span{u_current_});
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_boundary_conditions(std::span{u_current_}, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solve PDE from t_start to t_end
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @return expected success or solver error diagnostic
       26,656 (0.0%)    38 (0.0%) 2 (0.0%)         3,332 (0.0%)        18  (0.0%)  0             16,660 (0.0%)       711 (0.0%) 32 (0.0%)           0                0         0   0      expected<void, SolverError> solve() {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double t = time_.t_start();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double dt = time_.dt();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
   10,508,330 (0.0%)     0        0            3,500,000 (0.0%)    29,994  (0.1%)  0          1,750,000 (0.0%)         0         0          1,751,666 (0.0%)     1,668 (0.0%)  0   0          for (size_t step = 0; step < time_.n_steps(); ++step) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double t_old = t;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Store u^n for TR-BDF2
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              std::copy(u_current_.begin(), u_current_.end(), u_old_.begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Stage 1: Trapezoidal rule to t_n + γ·dt
    5,250,000 (0.0%)     0        0            5,250,000 (0.0%)         0          0                  0                0         0                  0                0         0   0              double t_stage1 = t + config_.gamma * dt;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              auto stage1_ok = solve_stage1(t, t_stage1, dt);
    3,500,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0          1,750,000 (0.0%)         0         0   0              if (!stage1_ok) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  return unexpected(stage1_ok.error());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Stage 2: BDF2 from t_n to t_n+1
    5,250,000 (0.0%)     0        0            3,500,000 (0.0%)    30,006  (0.1%)  0          1,750,000 (0.0%)         0         0                  0                0         0   0              double t_next = t + dt;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              auto stage2_ok = solve_stage2(t_stage1, t_next, dt);
    3,500,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0          1,750,000 (0.0%)         3 (0.0%)  0   0              if (!stage2_ok) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  return unexpected(stage2_ok.error());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Update time
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              t = t_next;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Process temporal events AFTER completing the step
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              process_temporal_events(t_old, t_next, step);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Process snapshots (CHANGED: pass step index)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              process_snapshots(step, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
        6,664 (0.0%) 1,590 (1.1%) 1 (0.0%)         1,666 (0.0%)         6  (0.0%)  0              3,332 (0.0%)         9 (0.0%)  0                  0                0         0   0          return {};
       23,324 (0.0%)    10 (0.0%) 1 (0.0%)        18,326 (0.0%)        21  (0.0%)  0                  0                0         0              1,666 (0.0%)         0         0   0      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Get current solution
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::span<const double> solution() const {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          return std::span{u_current_};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Check if obstacle condition is present
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      bool has_obstacle() const {
-- line 171 ----------------------------------------
-- line 237 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::vector<TemporalEvent> events_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      size_t next_event_idx_ = 0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // Workspace for derivatives
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::vector<double> du_dx_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::vector<double> d2u_dx2_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      WorkspaceStorage& acquire_workspace(std::span<const double> grid, WorkspaceStorage* external_workspace) {
        3,332 (0.0%)     0        0                    0                0          0                  0                0         0              1,666 (0.0%)         4 (0.0%)  0   0          if (external_workspace) {
        1,666 (0.0%)     0        0                    0                0          0              1,666 (0.0%)         0         0                  0                0         0   0              workspace_ = external_workspace;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              return *workspace_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          workspace_owner_ = std::make_unique<WorkspaceStorage>(n_, grid);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          workspace_ = workspace_owner_.get();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          return *workspace_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Process snapshots at current step index
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void process_snapshots(size_t step_idx, double t_current) {
    7,000,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0          1,750,000 (0.0%)         0         0   0          while (next_snapshot_idx_ < snapshot_requests_.size()) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              const auto& req = snapshot_requests_[next_snapshot_idx_];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Check if this step index matches
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (req.step_index > step_idx) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  break;  // Future snapshot
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (req.step_index != step_idx) {
-- line 264 ----------------------------------------
-- line 301 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Events are applied AFTER the TR-BDF2 step completes.
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// This ensures proper ordering: PDE evolution happens first,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// then events modify the solution (e.g., dividend jumps).
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// CRITICAL: After each event, obstacle and boundary conditions
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// must be re-applied to maintain consistency. Dividend jumps
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// interpolate the solution, which can violate constraints.
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void process_temporal_events(double t_old, double t_new, [[maybe_unused]] size_t step) {
    5,250,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0          1,750,000 (0.0%)         4 (0.0%)  0   0          while (next_event_idx_ < events_.size()) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              const auto& event = events_[next_event_idx_];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (event.time <= t_old) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  next_event_idx_++;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  continue;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (event.time > t_new) {
-- line 317 ----------------------------------------
-- line 339 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Apply obstacle condition: u(x,t) ≥ ψ(x,t)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Projects solution onto obstacle constraint via complementarity:
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// u[i] = max(u[i], ψ[i]) for all i
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// This is called AFTER each Newton update to enforce variational
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// inequality constraints (e.g., American option early exercise).
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void apply_obstacle(double t, std::span<double> u) {
   13,897,460 (0.0%)     0        0            6,948,730 (0.0%)         1  (0.0%)  0                  0                0         0          6,948,730 (0.1%)         0         0   0          if (!obstacle_) return;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
        1,666 (0.0%)     0        0                1,666 (0.0%)         0          0                  0                0         0                  0                0         0   0          auto psi = workspace_->psi_buffer();
   62,523,576 (0.1%)    29 (0.0%) 1 (0.0%)             0                0          0                  0                0         0                  0                0         0   0          (*obstacle_)(t, grid_, psi);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Project: u[i] = max(u[i], psi[i])
  906,223,748 (0.9%)     0        0           20,842,858 (0.1%)         2  (0.0%)  0                  0                0         0        224,820,004 (1.9%) 6,950,393 (5.8%)  0   0          for (size_t i = 0; i < u.size(); ++i) {
1,005,981,606 (1.0%) 1,626 (1.1%) 3 (0.1%)   407,950,960 (1.2%)        38  (0.0%) 38 (0.2%)           0                0         0        203,975,480 (1.7%) 6,710,204 (5.6%)  0   0              if (u[i] < psi[i]) {
   90,137,130 (0.1%)     0        0                    0                0          0        351,548,812 (4.2%)         0         0                  0                0         0   0                  u[i] = psi[i];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Apply boundary conditions
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void apply_boundary_conditions(std::span<double> u, double t) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          auto dx_span = workspace_->dx();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Left boundary
   17,395,794 (0.0%)     0        0           17,395,794 (0.1%)         2  (0.0%)  2 (0.0%)           0                0         0                  0                0         0   0          double x_left = grid_[0];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double dx_left = (n_ > 1) ? dx_span[0] : 1.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double u_interior_left = (n_ > 1) ? u[1] : 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          left_bc_.apply(u[0], x_left, t, dx_left, u_interior_left, 0.0, bc::BoundarySide::Left);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Right boundary
   41,736,986 (0.0%)    46 (0.0%) 2 (0.0%)    34,789,922 (0.1%)         2  (0.0%)  0          6,947,064 (0.1%)         0         0                  0                0         0   0          double x_right = grid_[n_ - 1];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double dx_right = (n_ > 1) ? dx_span[n_ - 2] : 1.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double u_interior_right = (n_ > 1) ? u[n_ - 2] : 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          right_bc_.apply(u[n_ - 1], x_right, t, dx_right, u_interior_right, 0.0, bc::BoundarySide::Right);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Apply spatial operator (single-pass evaluation)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Note: Cache blocking was previously attempted but removed because it was
-- line 379 ----------------------------------------
-- line 385 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                        std::span<const double> u,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                        std::span<double> Lu) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const size_t n = grid_.size();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Direct evaluation (no blocking)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          spatial_op_.apply(t, u, Lu);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Zero boundary values (BCs will override after)
   17,394,128 (0.0%)     9 (0.0%) 1 (0.0%)             0                0          0         17,394,128 (0.2%)         0         0                  0                0         0   0          Lu[0] = Lu[n-1] = 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// TR-BDF2 Stage 1: Trapezoidal rule
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// u^{n+γ} = u^n + (γ·dt/2) · [L(u^n) + L(u^{n+γ})]
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solved via Newton-Raphson iteration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      expected<void, SolverError> solve_stage1(double t_n, double t_stage, double dt) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double w1 = config_.stage1_weight(dt);  // γ·dt/2
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Compute L(u^n)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_operator_with_blocking(t_n, std::span{u_old_}, workspace_->lu());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // RHS = u^n + w1·L(u^n)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA for SAXPY-style loop
  166,750,000 (0.2%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0         55,000,000 (0.5%) 1,750,012 (1.5%)  0   0          for (size_t i = 0; i < n_; ++i) {
  154,500,000 (0.2%)    18 (0.0%) 2 (0.0%)   252,250,000 (0.8%)         0          0         51,500,000 (0.6%) 1,890,000 (3.5%)  0                  0                0         0   0              rhs_[i] = std::fma(w1, workspace_->lu()[i], u_old_[i]);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Initial guess: u* = u^n
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          std::copy(u_old_.begin(), u_old_.end(), u_current_.begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Solve implicit stage
   10,500,000 (0.0%)     9 (0.0%) 1 (0.0%)     3,500,000 (0.0%)         0          0          1,750,000 (0.0%)         0         0                  0                0         0   0          auto result = solve_implicit_stage(t_stage, w1,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{u_current_},
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{rhs_});
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    3,500,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0          1,750,000 (0.0%)         0         0   0          if (!result.converged) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              SolverError error{
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .code = SolverErrorCode::Stage1ConvergenceFailure,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .message = result.failure_reason.value_or("TR-BDF2 stage1 failed to converge"),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .iterations = result.iterations
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              };
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (error.message == "Singular Jacobian") {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  error.code = SolverErrorCode::LinearSolveFailure;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              return unexpected(error);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    5,250,000 (0.0%)     0        0                    0                0          0          3,500,000 (0.0%)    31,356 (0.1%)  1 (0.0%)           0                0         0   0          return {};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// TR-BDF2 Stage 2: BDF2
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Standard TR-BDF2 formulation (Ascher, Ruuth, Wetton 1995):
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// u^{n+1} - [(1-γ)·dt/(2-γ)]·L(u^{n+1}) = [1/(γ(2-γ))]·u^{n+γ} - [(1-γ)²/(γ(2-γ))]·u^n
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solved via Newton-Raphson iteration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      expected<void, SolverError> solve_stage2([[maybe_unused]] double t_stage, double t_next, double dt) {
    1,750,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0                  0                0         0   0          const double gamma = config_.gamma;
    3,500,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0                  0                0         0   0          const double one_minus_gamma = 1.0 - gamma;
    3,500,000 (0.0%)     5 (0.0%) 1 (0.0%)     1,750,000 (0.0%)    30,002  (0.1%)  0                  0                0         0                  0                0         0   0          const double two_minus_gamma = 2.0 - gamma;
    1,750,000 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          const double denom = gamma * two_minus_gamma;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Correct BDF2 coefficients (Ascher, Ruuth, Wetton 1995)
    1,750,000 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          const double alpha = 1.0 / denom;  // Coefficient for u^{n+γ}
    5,250,000 (0.0%)     0        0            1,750,000 (0.0%)         0          0                  0                0         0                  0                0         0   0          const double beta = -(one_minus_gamma * one_minus_gamma) / denom;  // Coefficient for u^n
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double w2 = config_.stage2_weight(dt);  // (1-γ)·dt/(2-γ)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // RHS = alpha·u^{n+γ} + beta·u^n (u_current_ currently holds u^{n+γ})
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA: alpha*u_current[i] + beta*u_old[i]
  166,750,000 (0.2%)    10 (0.0%) 2 (0.0%)     1,750,000 (0.0%)         0          0                  0                0         0         55,000,000 (0.5%) 1,750,009 (1.5%)  0   0          for (size_t i = 0; i < n_; ++i) {
  154,500,000 (0.2%)     5 (0.0%) 1 (0.0%)   252,250,000 (0.8%) 1,860,036  (5.1%) 36 (0.2%)  51,500,000 (0.6%) 1,890,041 (3.5%) 41 (0.0%)           0                0         0   0              rhs_[i] = std::fma(alpha, u_current_[i], beta * u_old_[i]);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Initial guess: u^{n+1} = u* (already in u_current_)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // (No need to copy, u_current_ already has u^{n+γ})
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Solve implicit stage
   12,250,000 (0.0%)     0        0            3,500,000 (0.0%)         0          0          1,750,000 (0.0%)         0         0                  0                0         0   0          auto result = solve_implicit_stage(t_next, w2,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{u_current_},
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{rhs_});
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    3,500,000 (0.0%)     5 (0.0%) 1 (0.0%)     1,750,000 (0.0%)         0          0                  0                0         0          1,750,000 (0.0%)         0         0   0          if (!result.converged) {
    1,750,000 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0              SolverError error{
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .code = SolverErrorCode::Stage2ConvergenceFailure,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .message = result.failure_reason.value_or("TR-BDF2 stage2 failed to converge"),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .iterations = result.iterations
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              };
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (error.message == "Singular Jacobian") {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  error.code = SolverErrorCode::LinearSolveFailure;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              return unexpected(error);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    3,500,000 (0.0%)     0        0                    0                0          0          3,500,000 (0.0%)    30,001 (0.1%)  1 (0.0%)           0                0         0   0          return {};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // ========================================================================
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // Newton-Raphson methods (for implicit stage solving)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // ========================================================================
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      //
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // NOTE: These methods are TR-BDF2-specific implementation details and NOT
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // intended as a general-purpose Newton solver. They solve the specific form:
-- line 491 ----------------------------------------
-- line 507 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solves: u = rhs + coeff_dt·L(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Equivalently: F(u) = u - rhs - coeff_dt·L(u) = 0
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param t Time at which to evaluate operators
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param coeff_dt TR-BDF2 weight (stage1_weight or stage2_weight)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param u Solution vector (input: initial guess, output: converged solution)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param rhs Right-hand side from previous stage
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @return Result with convergence status
   73,500,000 (0.1%)    28 (0.0%) 2 (0.0%)     7,000,000 (0.0%)         0          0         45,500,000 (0.5%)     2,144 (0.0%) 97 (0.1%)           0                0         0   0      RootFindingResult solve_implicit_stage(double t, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                             std::span<double> u,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                             std::span<const double> rhs) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double eps = root_config_.jacobian_fd_epsilon;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Apply BCs to initial guess
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_boundary_conditions(u, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Quasi-Newton: Build Jacobian once and reuse
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          build_jacobian(t, coeff_dt, u, eps);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Copy initial guess
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          std::copy(u.begin(), u.end(), newton_ws_.u_old().begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Newton iteration
   20,788,256 (0.0%)     5 (0.0%) 1 (0.0%)    13,841,192 (0.0%)         0          0                  0                0         0          6,947,064 (0.1%)         6 (0.0%)  0   0          for (size_t iter = 0; iter < root_config_.max_iter; ++iter) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Evaluate L(u)
   13,894,128 (0.0%)     0        0            6,947,064 (0.0%)    59,064  (0.2%)  0          6,947,064 (0.1%)         0         0                  0                0         0   0              apply_operator_with_blocking(t, u, workspace_->lu());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Compute residual: F(u) = u - rhs - coeff_dt·L(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              compute_residual(u, coeff_dt, workspace_->lu(), rhs,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                             newton_ws_.residual());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // CRITICAL FIX: Pass u explicitly to avoid reading stale workspace
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_bc_to_residual(newton_ws_.residual(), u, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Newton method: Solve J·δu = -F(u), then update u ← u + δu
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Negate residual for RHS
  525,960,216 (0.5%) 3,148 (2.1%) 2 (0.0%)    13,894,128 (0.0%)         0          0                  0                0         0        224,771,256 (1.9%) 6,947,072 (5.8%)  0   0              for (size_t i = 0; i < n_; ++i) {
  611,790,192 (0.6%) 1,662 (1.1%) 1 (0.0%)   210,877,128 (0.6%)         0          0        203,930,064 (2.5%)         0         0                  0                0         0   0                  newton_ws_.residual()[i] = -newton_ws_.residual()[i];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Solve J·δu = -F(u) using Thomas algorithm
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              auto result = solve_thomas<double>(
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.jacobian_lower(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.jacobian_diag(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.jacobian_upper(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.residual(),
-- line 552 ----------------------------------------
-- line 555 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              );
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (!result.ok()) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  return {false, iter, std::numeric_limits<double>::infinity(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                         "Singular Jacobian", std::nullopt};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Update: u ← u + δu
  750,731,472 (0.7%)     7 (0.0%) 1 (0.0%)     6,947,064 (0.0%)         0          0                  0                0         0        238,665,384 (2.0%) 6,947,097 (5.8%)  0   0              for (size_t i = 0; i < n_; ++i) {
  611,790,192 (0.6%)     9 (0.0%) 1 (0.0%)   407,860,128 (1.2%)        13  (0.0%) 13 (0.1%) 203,930,064 (2.5%)         0         0                  0                0         0   0                  u[i] += newton_ws_.delta_u()[i];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Apply obstacle projection BEFORE boundary conditions
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // This ensures complementarity: u ≥ ψ
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_obstacle(t, u);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_boundary_conditions(u, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Check convergence via step delta
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double error = compute_step_delta_error(u, newton_ws_.u_old());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
   20,841,192 (0.0%)     0        0            6,947,064 (0.0%)   119,064  (0.3%)  0                  0                0         0          6,947,064 (0.1%) 3,599,066 (3.0%)  0   0              if (error < root_config_.tolerance) {
   42,000,000 (0.0%)     9 (0.0%) 1 (0.0%)     7,000,000 (0.0%)         2  (0.0%)  0         21,000,000 (0.3%)   120,006 (0.2%)  0                  0                0         0   0                  return {true, iter + 1, error, std::nullopt, std::nullopt};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Prepare for next iteration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              std::copy(u.begin(), u.end(), newton_ws_.u_old().begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          return {false, root_config_.max_iter,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                 compute_step_delta_error(u, newton_ws_.u_old()),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                 "Max iterations reached", std::nullopt};
   38,500,000 (0.0%)    10 (0.0%) 1 (0.0%)    31,500,000 (0.1%)   120,005  (0.3%)  0                  0                0         0                  0                0         0   0      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void compute_residual(std::span<const double> u, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                           std::span<const double> Lu,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                           std::span<const double> rhs,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                           std::span<double> residual) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // F(u) = u - rhs - coeff_dt·L(u) = 0
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // We want to solve u = rhs + coeff_dt·L(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA: u[i] - rhs[i] - coeff_dt*Lu[i] = (u[i] - rhs[i]) + (-coeff_dt)*Lu[i]
  660,419,640 (0.6%)    16 (0.0%) 2 (0.0%)             0                0          0                  0                0         0        217,824,192 (1.8%) 6,947,082 (5.8%)  0   0          for (size_t i = 0; i < n_; ++i) {
  822,667,320 (0.8%)     0        0        1,209,686,256 (3.6%) 3,780,096 (10.4%)  0        203,930,064 (2.5%) 3,779,099 (7.0%) 29 (0.0%)           0                0         0   0              residual[i] = std::fma(-coeff_dt, Lu[i], u[i] - rhs[i]);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      double compute_step_delta_error(std::span<const double> u_new,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                      std::span<const double> u_old) {
   20,841,192 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          double sum_sq_error = 0.0;
    6,947,064 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          double sum_sq_norm = 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA for sum of squares: sum += x*x
2,405,478,384 (2.3%)     6 (0.0%) 1 (0.0%)             0                0          0                  0                0         0        801,826,128 (6.8%) 6,947,089 (5.8%)  0   0          for (size_t i = 0; i < n_; ++i) {
1,589,758,128 (1.5%)     0        0        1,589,758,128 (4.8%) 7,262,944 (20.0%) 40 (0.2%)           0                0         0                  0                0         0   0              double diff = u_new[i] - u_old[i];
  794,879,064 (0.8%)     0        0                    0                0          0                  0                0         0                  0                0         0   0              sum_sq_error = std::fma(diff, diff, sum_sq_error);
  794,879,064 (0.8%)     0        0                    0                0          0                  0                0         0                  0                0         0   0              sum_sq_norm = std::fma(u_new[i], u_new[i], sum_sq_norm);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
   62,523,576 (0.1%)     7 (0.0%) 1 (0.0%)             0                0          0                  0                0         0         13,894,128 (0.1%)         0         0   0          double rms_error = std::sqrt(sum_sq_error / n_);
   13,894,128 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          double rms_norm = std::sqrt(sum_sq_norm / n_);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double epsilon = 1e-12;
   34,735,320 (0.0%)     9 (0.0%) 1 (0.0%)     6,947,064 (0.0%)         0          0                  0                0         0          6,947,064 (0.1%)         0         0   0          return (rms_norm > epsilon) ? rms_error / (rms_norm + epsilon) : rms_error;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void apply_bc_to_residual(std::span<double> residual,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                std::span<const double> u,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                double t) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // For Dirichlet BC: F(u) = u - g, so residual = u - g
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Left boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryL>, bc::dirichlet_tag>) {
   13,894,128 (0.0%)     0        0            6,947,064 (0.0%)         0          0          6,947,064 (0.1%)         0         0                  0                0         0   0              double g = left_bc_.value(t, grid_[0]);
   27,788,256 (0.0%)     0        0            6,947,064 (0.0%)         0          0         13,894,128 (0.2%)         0         0                  0                0         0   0              residual[0] = u[0] - g;  // u - g (we want u = g, so F = u - g = 0)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Right boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryR>, bc::dirichlet_tag>) {
   27,788,256 (0.0%)     9 (0.0%) 1 (0.0%)    13,894,128 (0.0%)         0          0         13,894,128 (0.2%)         0         0                  0                0         0   0              double g = right_bc_.value(t, grid_[n_ - 1]);
   20,841,192 (0.0%) 1,648 (1.1%) 1 (0.0%)     6,947,064 (0.0%)         0          0          6,947,064 (0.1%)         0         0                  0                0         0   0              residual[n_ - 1] = u[n_ - 1] - g;  // u - g
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void build_jacobian(double t, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                         std::span<const double> u, double eps) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Dispatch to analytical or finite-difference Jacobian
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (HasAnalyticalJacobian<SpatialOp>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Analytical Jacobian (O(n) - fast path)
-- line 638 ----------------------------------------
-- line 686 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void build_jacobian_boundaries(double t, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                     std::span<const double> u, double eps) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Left boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryL>, bc::dirichlet_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Dirichlet: F(u) = u - g, so ∂F/∂u = 1
    3,500,000 (0.0%)     0        0                    0                0          0          3,500,000 (0.0%)         0         0                  0                0         0   0              newton_ws_.jacobian_diag()[0] = 1.0;
    3,500,000 (0.0%)     0        0                    0                0          0          3,500,000 (0.0%)         0         0                  0                0         0   0              newton_ws_.jacobian_upper()[0] = 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          } else if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryL>, bc::neumann_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Neumann: F(u) = u - rhs - coeff_dt·L(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[0] = u[0] + eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_operator_with_blocking(t, newton_ws_.u_perturb(), newton_ws_.Lu_perturb());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double dL0_du0 = (newton_ws_.Lu_perturb()[0] - workspace_->lu()[0]) / eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.jacobian_diag()[0] = 1.0 - coeff_dt * dL0_du0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[0] = u[0];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
-- line 703 ----------------------------------------
-- line 706 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double dL0_du1 = (newton_ws_.Lu_perturb()[0] - workspace_->lu()[0]) / eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.jacobian_upper()[0] = -coeff_dt * dL0_du1;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[1] = u[1];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Right boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryR>, bc::dirichlet_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Dirichlet: F(u) = u - g, so ∂F/∂u = 1
    3,500,000 (0.0%)     0        0                    0                0          0          3,500,000 (0.0%)         0         0                  0                0         0   0              newton_ws_.jacobian_diag()[n_ - 1] = 1.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          } else if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryR>, bc::neumann_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Neumann: F(u) = u - rhs - coeff_dt·L(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              size_t i = n_ - 1;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[i] = u[i] + eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_operator_with_blocking(t, newton_ws_.u_perturb(), newton_ws_.Lu_perturb());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double dLi_dui = (newton_ws_.Lu_perturb()[i] - workspace_->lu()[i]) / eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.jacobian_diag()[i] = 1.0 - coeff_dt * dLi_dui;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[i] = u[i];
-- line 722 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/thomas_solver.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr________ ILmr____ Dr__________________ D1mr_____________ DLmr_____ Dw________________ D1mw_____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 94 ----------------------------------------
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      std::span<T> workspace,
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      const ThomasConfig<T>& config = {}) noexcept
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      using Result = ThomasResult<T>;
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      const size_t n = diag.size();
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Validate dimensions
   20,841,192 (0.0%) 1,590 (1.1%) 1 (0.0%)     6,947,064 (0.0%)         0          0                  0                0          0          6,947,064 (0.1%)         2 (0.0%)  0   0      if (lower.size() != n - 1) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::error_result("Lower diagonal size must be n-1");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
   13,894,128 (0.0%)     7 (0.0%) 1 (0.0%)     6,947,064 (0.0%)         0          0                  0                0          0          6,947,064 (0.1%)         0         0   0      if (upper.size() != n - 1) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::error_result("Upper diagonal size must be n-1");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
   13,894,128 (0.0%)     9 (0.0%) 1 (0.0%)     6,947,064 (0.0%)         0          0                  0                0          0          6,947,064 (0.1%)         0         0   0      if (rhs.size() != n) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::error_result("RHS size must be n");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
   20,841,192 (0.0%)     0        0           13,894,128 (0.0%)         0          0                  0                0          0          6,947,064 (0.1%)         0         0   0      if (solution.size() != n) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::error_result("Solution size must be n");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
   20,841,192 (0.0%)     0        0            6,947,064 (0.0%)         3  (0.0%)  0                  0                0          0          6,947,064 (0.1%)         2 (0.0%)  0   0      if (workspace.size() < 2 * n) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::error_result("Workspace size must be at least 2n");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Handle trivial cases
   13,894,128 (0.0%)     0        0                    0                0          0                  0                0          0          6,947,064 (0.1%)         3 (0.0%)  0   0      if (n == 0) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::ok_result();
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
   13,894,128 (0.0%)     0        0                    0                0          0                  0                0          0          6,947,064 (0.1%)         0         0   0      if (n == 1) {
    6,947,064 (0.0%)     0        0            6,947,064 (0.0%)         0          0                  0                0          0                  0                0         0   0          if (std::abs(diag[0]) < config.singularity_tol) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .              return Result::error_result("Singular matrix (diagonal[0] ≈ 0)");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          solution[0] = rhs[0] / diag[0];
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::ok_result();
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Split workspace into c' and d' arrays
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      std::span<T> c_prime = workspace.subspan(0, n);
-- line 132 ----------------------------------------
-- line 143 ----------------------------------------
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .                  return Result::error_result("Matrix not diagonally dominant");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // ========== Forward Elimination ==========
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // First row
   20,841,192 (0.0%)     0        0            6,947,064 (0.0%)         6  (0.0%)  0                  0                0          0          6,947,064 (0.1%)         0         0   0      if (std::abs(diag[0]) < config.singularity_tol) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          return Result::error_result("Singular matrix (diagonal[0] ≈ 0)");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
   20,841,192 (0.0%)     0        0            6,947,064 (0.0%)         0          0          6,947,064 (0.1%)         0          0                  0                0         0   0      c_prime[0] = upper[0] / diag[0];
   20,841,192 (0.0%)     0        0           13,894,128 (0.0%)         0          0          6,947,064 (0.1%)    60,002  (0.1%)  2 (0.0%)           0                0         0   0      d_prime[0] = rhs[0] / diag[0];
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Middle rows
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Note: Singularity checking prevents SIMD vectorization (early return)
2,363,796,000 (2.3%)     0        0                    0                0          0                  0                0          0        787,932,000 (6.7%) 6,947,071 (5.8%)  0   0      for (size_t i = 1; i < n - 1; ++i) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          // Use FMA for denominator calculation
2,342,954,808 (2.3%) 1,540 (1.0%) 1 (0.0%) 2,342,954,808 (7.0%) 7,264,887 (20.0%) 15 (0.1%)           0                0          0                  0                0         0   0          const T denom = std::fma(-lower[i-1], c_prime[i-1], diag[i]);
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          // Singularity check
1,561,969,872 (1.5%)     0        0                    0                0          0                  0                0          0        780,984,936 (6.6%)         0         0   0          if (std::abs(denom) < config.singularity_tol) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .              return Result::error_result("Singular or ill-conditioned matrix");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
1,561,969,872 (1.5%)     0        0          780,984,936 (2.3%)         1  (0.0%)  0                  0                0          0                  0                0         0   0          const T inv_denom = static_cast<T>(1) / denom;
1,561,969,872 (1.5%)     0        0          780,984,936 (2.3%) 3,602,911  (9.9%)  7 (0.0%) 780,984,936 (9.4%) 5,551,012 (10.3%) 28 (0.0%)           0                0         0   0          c_prime[i] = upper[i] * inv_denom;
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          // Use FMA: (rhs[i] - lower[i-1]*d_prime[i-1]) * inv_denom
3,904,924,680 (3.8%) 1,590 (1.1%) 1 (0.0%) 2,342,954,808 (7.0%)         8  (0.0%)  8 (0.0%) 780,984,936 (9.4%) 6,968,552 (12.9%) 32 (0.0%)           0                0         0   0          d_prime[i] = std::fma(-lower[i-1], d_prime[i-1], rhs[i]) * inv_denom;
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Last row (no upper diagonal term)
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          const size_t i = n - 1;
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          // Use FMA for denominator calculation
   20,841,192 (0.0%)     0        0           20,841,192 (0.1%)         0          0                  0                0          0                  0                0         0   0          const T denom = std::fma(-lower[i-1], c_prime[i-1], diag[i]);
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
   13,894,128 (0.0%)    10 (0.0%) 1 (0.0%)             0                0          0                  0                0          0          6,947,064 (0.1%)         0         0   0          if (std::abs(denom) < config.singularity_tol) {
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .              return Result::error_result("Singular matrix (at last row)");
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .          // Use FMA for numerator calculation
   27,788,256 (0.0%)     0        0           13,894,128 (0.0%)         0          0          6,947,064 (0.1%)         0          0                  0                0         0   0          d_prime[i] = std::fma(-lower[i-1], d_prime[i-1], rhs[i]) / denom;
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // ========== Back Substitution ==========
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
    6,947,064 (0.0%)     0        0                    0                0          0          6,947,064 (0.1%)         1  (0.0%)  1 (0.0%)           0                0         0   0      solution[n-1] = d_prime[n-1];
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Reverse iteration (vectorization limited by data dependency)
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      // Use FMA for back substitution: d_prime[i-1] - c_prime[i-1]*solution[i]
  801,826,128 (0.8%)     0        0            6,947,064 (0.0%)         0          0                  0                0          0        787,932,000 (6.7%) 6,947,080 (5.8%)  0   0      for (size_t i = n - 1; i > 0; --i) {
3,151,728,000 (3.1%)    19 (0.0%) 1 (0.0%) 1,575,864,000 (4.7%)        12  (0.0%) 12 (0.1%) 787,932,000 (9.5%) 7,382,004 (13.7%) 36 (0.0%)           0                0         0   0          solution[i-1] = std::fma(-c_prime[i-1], solution[i], d_prime[i-1]);
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .      return Result::ok_result();
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  }
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  /// Convenience wrapper with automatic workspace allocation
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  ///
            .            .        .                    .                .          .                  .                .          .                  .                .         .   .  /// For performance-critical code, prefer the workspace version above
-- line 204 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/src/american_option.cpp
--------------------------------------------------------------------------------
Ir__________________ I1mr________ ILmr____ Dr__________________ D1mr_____________ DLmr_____ Dw___________________ D1mw_____________ DLmw________ Bc________________ Bcm_____________ Bi Bim 

-- line 28 ----------------------------------------
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  /**
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   * American put option obstacle in log-moneyness coordinates.
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   *
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   * Intrinsic value: ψ(x) = max(1 - exp(x), 0)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   * where x = ln(S/K).
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   */
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  class AmericanPutObstacle {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  public:
   76,436,030 (0.1%)     0        0                    0                0          0           34,743,650  (0.4%)   119,065  (0.2%)     1 (0.0%)           0                0         0   0      void operator()(double, std::span<const double> x,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                      std::span<double> psi) const {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          #pragma omp simd
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          for (size_t i = 0; i < x.size(); ++i) {
8,745,613,030 (8.5%)     0        0        1,590,111,460 (4.8%) 7,382,008 (20.3%) 40 (0.2%) 1,590,111,460 (19.2%) 5,678,702 (10.5%) 8,959 (6.0%) 795,055,730 (6.7%) 6,948,746 (5.8%)  0   0              psi[i] = std::max(1.0 - std::exp(x[i]), 0.0);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
   41,692,380 (0.0%)     0        0           41,692,380 (0.1%)         0          0                    0                 0             0                  0                0         0   0      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  };
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  /**
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   * American call option obstacle in log-moneyness coordinates.
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   *
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   * Intrinsic value: ψ(x) = max(exp(x) - 1, 0)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   * where x = ln(S/K).
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .   */
-- line 50 ----------------------------------------
-- line 109 ----------------------------------------
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          double dx = x[j] - x[i];
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          double weight = (x_target - x[i]) / dx;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          return (1.0 - weight) * u[i] + weight * u[j];
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  };
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  }  // anonymous namespace
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
       22,512 (0.0%)     6 (0.0%) 1 (0.0%)             0                0          0                9,648  (0.0%)       702  (0.0%)     0                  0                0         0   0  AmericanOptionSolver::AmericanOptionSolver(
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const AmericanOptionParams& params,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const AmericanOptionGrid& grid,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const TRBDF2Config& trbdf2_config,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const RootFindingConfig& root_config)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      : params_(params)
        3,216 (0.0%)     0        0                1,608 (0.0%)         0          0                1,608  (0.0%)       682  (0.0%)     0                  0                0         0   0      , grid_(grid)
        3,216 (0.0%)     0        0                1,608 (0.0%)         0          0                1,608  (0.0%)         0             0                  0                0         0   0      , trbdf2_config_(trbdf2_config)
        3,216 (0.0%)     0        0                1,608 (0.0%)         0          0                1,608  (0.0%)         0             0                  0                0         0   0      , root_config_(root_config)
        1,608 (0.0%)     0        0                    0                0          0                1,608  (0.0%)       704  (0.0%)    31 (0.0%)           0                0         0   0      , workspace_(nullptr)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Validate parameters (includes discrete dividend validation)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      params_.validate();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      grid_.validate();
       12,864 (0.0%)     0        0               11,256 (0.0%)         0          0                    0                 0             0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
        1,102 (0.0%)     8 (0.0%) 2 (0.0%)           116 (0.0%)         0          0                  522  (0.0%)         0             0                  0                0         0   0  AmericanOptionSolver::AmericanOptionSolver(
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const AmericanOptionParams& params,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const AmericanOptionGrid& grid,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      std::shared_ptr<SliceSolverWorkspace> workspace,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const TRBDF2Config& trbdf2_config,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const RootFindingConfig& root_config)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      : params_(params)
          116 (0.0%)     3 (0.0%) 1 (0.0%)            58 (0.0%)         0          0                   58  (0.0%)         0             0                  0                0         0   0      , grid_(grid)
          116 (0.0%)     0        0                   58 (0.0%)         0          0                   58  (0.0%)         0             0                  0                0         0   0      , trbdf2_config_(trbdf2_config)
          116 (0.0%)     0        0                   58 (0.0%)         0          0                   58  (0.0%)         0             0                  0                0         0   0      , root_config_(root_config)
           58 (0.0%)     0        0                    0                0          0                   58  (0.0%)         0             0                  0                0         0   0      , workspace_(std::move(workspace))
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Validate parameters
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      params_.validate();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      grid_.validate();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Validate workspace is not null
          116 (0.0%)     0        0                    0                0          0                    0                 0             0                 58 (0.0%)         0         0   0      if (!workspace_) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          throw std::invalid_argument("Workspace cannot be null");
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Validate grid matches workspace
          638 (0.0%)     0        0                  116 (0.0%)         0          0                    0                 0             0                116 (0.0%)         1 (0.0%)  0   0      if (grid_.x_min != workspace_->x_min() || grid_.x_max != workspace_->x_max() ||
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          grid_.n_space != workspace_->n_space()) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          throw std::invalid_argument(
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              "Grid parameters must match workspace "
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              "(x_min=" + std::to_string(workspace_->x_min()) +
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              ", x_max=" + std::to_string(workspace_->x_max()) +
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              ", n_space=" + std::to_string(workspace_->n_space()) + ")");
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
          812 (0.0%)     0        0                  580 (0.0%)         0          0                    0                 0             0                 58 (0.0%)         0         0   0  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
       26,656 (0.0%) 3,220 (2.2%) 2 (0.0%)         3,332 (0.0%)       703  (0.0%)  0               16,660  (0.0%)     1,406  (0.0%)    32 (0.0%)           0                0         0   0  expected<AmericanOptionResult, SolverError> AmericanOptionSolver::solve() {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 1. Acquire grid (reuse workspace grid if available)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      std::optional<GridBuffer<double>> owned_grid_buffer;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      std::span<const double> x_grid;
        1,608 (0.0%)     0        0                    0                0          0                1,608  (0.0%)         0             0                  0                0         0   0      std::shared_ptr<operators::GridSpacing<double>> shared_spacing;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      WorkspaceStorage* external_workspace = nullptr;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
        3,332 (0.0%)     0        0                    0                0          0                    0                 0             0              1,666 (0.0%)         0         0   0      if (workspace_) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          x_grid = workspace_->grid_span();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          shared_spacing = workspace_->grid_spacing();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          external_workspace = workspace_->workspace().get();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      } else {
       11,256 (0.0%)     8 (0.0%) 1 (0.0%)         3,216 (0.0%)         0          0                1,608  (0.0%)       703  (0.0%)     0                  0                0         0   0          owned_grid_buffer.emplace(GridSpec<>::uniform(grid_.x_min, grid_.x_max, grid_.n_space).generate());
        3,216 (0.0%)     0        0                1,608 (0.0%)         0          0                1,608  (0.0%)         0             0                  0                0         0   0          x_grid = owned_grid_buffer->span();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 2. Setup time domain
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // For option pricing: solve forward in PDE time (backward in calendar time)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // t=0: terminal payoff at maturity
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // t=T: present value
        9,996 (0.0%)    62 (0.0%) 2 (0.0%)         3,332 (0.0%)        34  (0.0%)  0                    0                 0             0              1,666 (0.0%)         0         0   0      TimeDomain time_domain(0.0, params_.maturity, params_.maturity / grid_.n_time);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 3. Create Black-Scholes operator in log-moneyness coordinates
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      auto make_operator = [&]() {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          auto pde = operators::BlackScholesPDE<double>(
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              params_.volatility,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              params_.rate,
        3,332 (0.0%)     5 (0.0%) 1 (0.0%)         3,332 (0.0%)         0          0                    0                 0             0                  0                0         0   0              params_.continuous_dividend_yield);
          116 (0.0%)     0        0                    0                0          0                    0                 0             0                 58 (0.0%)         0         0   0          if (shared_spacing) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              return operators::create_spatial_operator(std::move(pde), shared_spacing);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          auto grid_view = GridView<double>(x_grid);
       36,984 (0.0%)   849 (0.6%) 1 (0.0%)        14,472 (0.0%)         6  (0.0%)  0               12,864  (0.0%)         0             0                  0                0         0   0          return operators::create_spatial_operator(std::move(pde), grid_view);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      };
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      auto bs_op = make_operator();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 4. Setup boundary conditions (NORMALIZED by K=1)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // For log-moneyness: x → -∞ (S → 0), x → +∞ (S → ∞)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // IMPORTANT: Boundaries must account for time evolution via discounting
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // LEFT boundary (x → -∞, S → 0):
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      auto left_bc = DirichletBC([this](double t, double x) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          const double tau = t;  // Time to maturity (backward PDE time)
   90,429,366 (0.1%) 1,662 (1.1%) 1 (0.0%)    48,687,382 (0.1%)        13  (0.0%)  1 (0.0%)    17,397,460  (0.2%)       710  (0.0%)    32 (0.0%)           0                0         0   0          const double discount = std::exp(-params_.rate * tau);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
   41,740,318 (0.0%)     0        0           24,344,524 (0.1%)         0          0                    0                 0             0         17,395,794 (0.1%)     1,686 (0.0%)  0   0          if (params_.option_type == OptionType::PUT) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Deep ITM put: V = K·e^(-r*τ) - S ≈ K·e^(-r*τ) as S → 0
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Normalized: V/K = e^(-r*τ) - e^(x - r*τ) ≈ e^(-r*τ) as x → -∞
  100,878,096 (0.1%) 1,602 (1.1%) 3 (0.1%)    31,291,588 (0.1%)         0          0           24,346,190  (0.3%)         0             0                  0                0         0   0              return discount - std::exp(x) * discount;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          } else {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Deep OTM call: V → 0 as S → 0
   41,895,794 (0.0%)     0        0            3,500,000 (0.0%)         0          0           10,500,000  (0.1%)         0             0                  0                0         0   0              return 0.0;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      });
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // RIGHT boundary (x → +∞, S → ∞):
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      auto right_bc = DirichletBC([this](double t, double x) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          const double tau = t;  // Time to maturity (backward PDE time)
   97,426,034 (0.1%) 1,579 (1.1%) 3 (0.1%)    52,185,716 (0.2%)         0          0           45,238,652  (0.5%)         0             0                  0                0         0   0          const double discount = std::exp(-params_.rate * tau);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
   76,528,574 (0.1%)     0        0           41,736,986 (0.1%)         0          0                    0                 0             0         17,395,794 (0.1%)     1,503 (0.0%)  0   0          if (params_.option_type == OptionType::CALL) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Deep ITM call: V = S - K·e^(-r*τ)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Normalized: V/K = (S/K) - e^(-r*τ) = e^x - e^(-r*τ)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              return std::exp(x) - discount;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          } else {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Deep OTM put: V → 0 as S → ∞
   17,395,794 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0              return 0.0;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      });
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 5. Setup obstacle condition
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      AmericanOptionResult result;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
       11,662 (0.0%) 3,190 (2.2%) 1 (0.0%)         3,332 (0.0%)        10  (0.0%)  0                    0                 0             0              1,666 (0.0%)         4 (0.0%)  0   0      if (params_.option_type == OptionType::PUT) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // Create PDESolver with obstacle
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          PDESolver solver(x_grid, time_domain, trbdf2_config_, root_config_,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                          left_bc, right_bc, bs_op,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                          [](double t, auto x, auto psi) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                              AmericanPutObstacle obstacle;
   13,897,460 (0.0%)     0        0            6,948,730 (0.0%)         0          0                    0                 0             0                  0                0         0   0                              obstacle(t, x, psi);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                          },
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                          external_workspace);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 6. Register discrete dividends as temporal events
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // Convert from calendar time (years from now) to solver time (backward time)
        3,332 (0.0%)     0        0                    0                0          0                    0                 0             0              1,666 (0.0%)     1,666 (0.0%)  0   0          for (const auto& [calendar_time, amount] : params_.discrete_dividends) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Solver time: t=0 at maturity, t=T at present
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Calendar time: time=0 now, time=T at maturity
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              double solver_time = params_.maturity - calendar_time;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              // Skip dividends at or beyond maturity (solver_time <= 0)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              if (solver_time <= 1e-10) continue;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              DividendJump div_jump(amount, params_.strike);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              solver.add_temporal_event(solver_time,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                  [div_jump](double t, auto x, auto u) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                      div_jump(t, x, u);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                  });
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 6a. Register snapshots (if any requested)
        3,332 (0.0%)     0        0                    0                0          0                    0                 0             0              1,666 (0.0%)         2 (0.0%)  0   0          for (const auto& req : snapshot_requests_) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              solver.register_snapshot(req.step_index, req.user_index, req.collector);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 7. Initialize with terminal condition (payoff at maturity)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // In log-moneyness, obstacle is normalized: ψ = max(1 - exp(x), 0)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // Initial condition must match (already normalized by K=1)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          solver.initialize([](auto x, auto u) {
      536,662 (0.0%)    16 (0.0%) 2 (0.0%)             0                0          0                    0                 0             0            178,332 (0.0%)     4,795 (0.0%)  0   0              for (size_t i = 0; i < x.size(); ++i) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                  // Normalized payoff: max(1 - exp(x), 0) where x = ln(S/K)
    1,589,994 (0.0%)     0        0              353,332 (0.0%)       348  (0.0%)  0              353,332  (0.0%)       102  (0.0%)     0                  0                0         0   0                  u[i] = std::max(1.0 - std::exp(x[i]), 0.0);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          });
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 8. Solve the PDE
        6,664 (0.0%)     9 (0.0%) 1 (0.0%)             0                0          0                1,666  (0.0%)         0             0                  0                0         0   0          auto solve_status = solver.solve();
        3,332 (0.0%)     0        0                1,666 (0.0%)         0          0                    0                 0             0              1,666 (0.0%)         2 (0.0%)  0   0          if (!solve_status) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .              return unexpected(solve_status.error());
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          result.converged = true;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 9. Extract solution
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          auto solution_view = solver.solution();
        1,666 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0          solution_.assign(solution_view.begin(), solution_view.end());
        1,666 (0.0%)     0        0                    0                0          0                1,666  (0.0%)         0             0                  0                0         0   0          solved_ = true;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 10. Interpolate to current spot price and denormalize
        8,330 (0.0%)     9 (0.0%) 1 (0.0%)         3,332 (0.0%)        15  (0.0%)  0                3,332  (0.0%)         9  (0.0%)     0                  0                0         0   0          double current_moneyness = std::log(params_.spot / params_.strike);
        8,330 (0.0%)     0        0                3,332 (0.0%)         9  (0.0%)  0                1,666  (0.0%)         0             0                  0                0         0   0          double normalized_value = interpolate_solution(current_moneyness, x_grid);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
        4,998 (0.0%)     0        0                1,666 (0.0%)         0          0                1,666  (0.0%)         0             0                  0                0         0   0          result.value = normalized_value * params_.strike;  // Denormalize
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      } else {  // CALL
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // Create PDESolver with obstacle
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // Note: left_bc and right_bc already defined above with time-dependent discounting
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          PDESolver solver(x_grid, time_domain, trbdf2_config_, root_config_,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                          left_bc, right_bc, bs_op,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                          [](double t, auto x, auto psi) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                              AmericanCallObstacle obstacle;
-- line 304 ----------------------------------------
-- line 348 ----------------------------------------
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          auto solution_view = solver.solution();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          solution_.assign(solution_view.begin(), solution_view.end());
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          solved_ = true;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          // 10. Interpolate to current spot price and denormalize
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          double current_moneyness = std::log(params_.spot / params_.strike);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          double normalized_value = interpolate_solution(current_moneyness, x_grid);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          result.value = normalized_value * params_.strike;  // Denormalize
        3,332 (0.0%)     0        0                    0                0          0                1,666  (0.0%)         0             0                  0                0         0   0      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 11. Compute Greeks (stub implementation for now - Task 9)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      result.delta = compute_delta();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      result.gamma = compute_gamma();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      result.theta = compute_theta();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      return result;
       23,324 (0.0%)     3 (0.0%) 1 (0.0%)        18,326 (0.0%)        74  (0.0%)  0                    0                 0             0              1,666 (0.0%)         0         0   0  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  double AmericanOptionSolver::interpolate_solution(double x_target,
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .                                                     std::span<const double> x_grid) const {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const size_t n = solution_.size();
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Boundary cases
        4,998 (0.0%)     6 (0.0%) 1 (0.0%)         1,666 (0.0%)         0          0                    0                 0             0              1,666 (0.0%)         4 (0.0%)  0   0      if (x_target <= x_grid[0]) return solution_[0];
        3,332 (0.0%)     0        0                1,666 (0.0%)         0          0                    0                 0             0              1,666 (0.0%)         0         0   0      if (x_target >= x_grid[n-1]) return solution_[n-1];
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Find bracketing indices
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      size_t i = 0;
      873,792 (0.0%)    10 (0.0%) 2 (0.0%)        87,046 (0.0%)         0          0                    0                 0             0            174,092 (0.0%)     1,680 (0.0%)  0   0      while (i < n-1 && x_grid[i+1] < x_target) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          i++;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Linear interpolation
        4,998 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0      double t = (x_target - x_grid[i]) / (x_grid[i+1] - x_grid[i]);
        6,664 (0.0%)     2 (0.0%) 1 (0.0%)         4,998 (0.0%)         0          0                    0                 0             0                  0                0         0   0      return (1.0 - t) * solution_[i] + t * solution_[i+1];
        1,666 (0.0%)     0        0                1,666 (0.0%)         0          0                    0                 0             0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  std::vector<double> AmericanOptionSolver::get_solution() const {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      if (!solved_) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          throw std::runtime_error("Solver has not been run yet");
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      return solution_;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
       11,662 (0.0%) 3,256 (2.2%) 2 (0.0%)             0                0          0                6,664  (0.0%)         0             0                  0                0         0   0  double AmericanOptionSolver::compute_delta() const {
        9,996 (0.0%)     0        0                1,666 (0.0%)         0          0                3,332  (0.0%)         0             0              1,666 (0.0%)         0         0   0      if (!solved_) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          return 0.0;  // No solution available
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const size_t n = solution_.size();
       14,994 (0.0%)     0        0                3,332 (0.0%)         9  (0.0%)  0                1,666  (0.0%)         0             0              1,666 (0.0%)     1,609 (0.0%)  0   0      const double dx = (grid_.x_max - grid_.x_min) / (n - 1);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Find current spot in grid
       11,662 (0.0%) 1,659 (1.1%) 1 (0.0%)         3,332 (0.0%)         0          0                6,664  (0.0%)         0             0                  0                0         0   0      double current_moneyness = std::log(params_.spot / params_.strike);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Find the grid point closest to current_moneyness
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Use the same approach as interpolate_solution
        1,666 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0      size_t i = 0;
      796,742 (0.0%) 1,540 (1.0%) 1 (0.0%)         6,664 (0.0%)         0          0                    0                 0             0            175,758 (0.0%)     2,535 (0.0%)  0   0      while (i < n-1 && grid_.x_min + (i+1)*dx < current_moneyness) {
       87,046 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0          i++;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Ensure we're in valid interior range for centered differences
        4,998 (0.0%) 1,590 (1.1%) 1 (0.0%)             0                0          0                    0                 0             0                  0                0         0   0      if (i == 0) i = 1;
        3,332 (0.0%)     0        0                    0                0          0                    0                 0             0              1,666 (0.0%)         0         0   0      if (i >= n-1) i = n-2;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Compute ∂V/∂x using centered finite difference
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Note: solution_ stores V/K (normalized)
        4,998 (0.0%)    10 (0.0%) 1 (0.0%)         1,666 (0.0%)         0          0                    0                 0             0                  0                0         0   0      const double half_dx_inv = 1.0 / (2.0 * dx);
        6,664 (0.0%)     0        0                3,332 (0.0%)         0          0                    0                 0             0                  0                0         0   0      double dVdx = (solution_[i+1] - solution_[i-1]) * half_dx_inv;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Transform from log-moneyness to spot
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // V_dollar = V_norm * K
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Delta = ∂V_dollar/∂S = K * ∂V_norm/∂x * ∂x/∂S
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //       = K * dVdx * (1/S)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //       = (K/S) * dVdx
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Use FMA: (K/S) * dVdx
        1,666 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0      const double K_over_S = params_.strike / params_.spot;
        1,666 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0      double delta = K_over_S * dVdx;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      return delta;
        9,996 (0.0%)     0        0                8,330 (0.0%)         0          0                    0                 0             0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
       11,662 (0.0%)    19 (0.0%) 1 (0.0%)             0                0          0                6,664  (0.0%)         0             0                  0                0         0   0  double AmericanOptionSolver::compute_gamma() const {
        3,332 (0.0%)     0        0                1,666 (0.0%)         0          0                1,666  (0.0%)         0             0                  0                0         0   0      if (!solved_) {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .          return 0.0;  // No solution available
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      const size_t n = solution_.size();
       14,994 (0.0%)     0        0                3,332 (0.0%)         0          0                1,666  (0.0%)         0             0              1,666 (0.0%)         0         0   0      const double dx = (grid_.x_max - grid_.x_min) / (n - 1);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Find current spot in grid
       11,662 (0.0%)     0        0                3,332 (0.0%)         0          0                6,664  (0.0%)         0             0                  0                0         0   0      double current_moneyness = std::log(params_.spot / params_.strike);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Find the grid point closest to current_moneyness
        1,666 (0.0%) 1,597 (1.1%) 1 (0.0%)             0                0          0                    0                 0             0                  0                0         0   0      size_t i = 0;
      796,742 (0.0%)     0        0                6,664 (0.0%)         0          0                    0                 0             0            175,758 (0.0%)     2,536 (0.0%)  0   0      while (i < n-1 && grid_.x_min + (i+1)*dx < current_moneyness) {
       87,046 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0          i++;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Ensure we're in valid interior range for centered differences
        4,998 (0.0%) 1,597 (1.1%) 1 (0.0%)             0                0          0                    0                 0             0                  0                0         0   0      if (i == 0) i = 1;
        3,332 (0.0%) 1,610 (1.1%) 1 (0.0%)             0                0          0                    0                 0             0              1,666 (0.0%)         0         0   0      if (i >= n-1) i = n-2;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Centered second derivative: [V(i+1) - 2*V(i) + V(i-1)] / dx²
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Use FMA: (V(i+1) + V(i-1)) / dx² - 2*V(i) / dx²
        4,998 (0.0%)     0        0                1,666 (0.0%)         0          0                    0                 0             0                  0                0         0   0      const double dx2_inv = 1.0 / (dx * dx);
       13,328 (0.0%)     0        0                6,664 (0.0%)         0          0                    0                 0             0                  0                0         0   0      double d2Vdx2 = std::fma(solution_[i+1] + solution_[i-1], dx2_inv, -2.0*solution_[i]*dx2_inv);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Centered first derivative: [V(i+1) - V(i-1)] / (2*dx)
        4,998 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0      double dVdx = (solution_[i+1] - solution_[i-1]) / (2.0 * dx);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Transform from log-moneyness to spot using chain rule
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // x = ln(S/K), so ∂x/∂S = 1/S and ∂²x/∂S² = -1/S²
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // V_dollar(S) = K * V_norm(x(S))
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // First derivative:
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // dV/dS = K * dV_norm/dx * dx/dS = K * dV_norm/dx * (1/S)
-- line 465 ----------------------------------------
-- line 469 ----------------------------------------
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //         = K * d/dS[dV_norm/dx * (1/S)]
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //         = K * [d²V_norm/dx² * (dx/dS) * (1/S) + dV_norm/dx * d/dS(1/S)]
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //         = K * [d²V_norm/dx² * (1/S²) + dV_norm/dx * (-1/S²)]
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //         = (K/S²) * [d²V_norm/dx² - dV_norm/dx]
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      double S = params_.spot;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      double K = params_.strike;
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Use FMA: (K/S²) * (d2Vdx2 - dVdx) = (K/S²)*d2Vdx2 - (K/S²)*dVdx
        3,332 (0.0%)     0        0                    0                0          0                    0                 0             0                  0                0         0   0      const double K_over_S2 = K / (S * S);
        4,998 (0.0%) 1,609 (1.1%) 1 (0.0%)         1,666 (0.0%)         0          0                    0                 0             0                  0                0         0   0      double gamma = std::fma(K_over_S2, d2Vdx2, -K_over_S2 * dVdx);
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      return gamma;
        9,996 (0.0%)     0        0                8,330 (0.0%)         0          0                    0                 0             0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .  double AmericanOptionSolver::compute_theta() const {
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Theta is time decay: ∂V/∂t
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // For American options with no closed form, accurate theta requires:
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 1. Re-solving at slightly different time, or
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // 2. Evaluating the PDE operator: ∂V/∂t = L(V)
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .             .                  .                .         .   .      // Both approaches are expensive and complex. For now, return 0.0 as stub.
-- line 489 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/bits/std_abs.h
--------------------------------------------------------------------------------
Ir________________ I1mr_____ ILmr____ Dr_______________ D1mr__________ DLmr____ Dw____________ D1mw DLmw Bc Bcm Bi Bim 

-- line 64 ----------------------------------------
          .         .        .                 .              .        .              .           .    .  .   .  .   .  // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .         .        .                 .              .        .              .           .    .  .   .  .   .  // 2192. Validity and return type of std::abs(0u) is unclear
          .         .        .                 .              .        .              .           .    .  .   .  .   .  // 2294. <cstdlib> should declare abs(double)
          .         .        .                 .              .        .              .           .    .  .   .  .   .  // 2735. std::abs(short), std::abs(signed char) and others should return int
          .         .        .                 .              .        .              .           .    .  .   .  .   .  
          .         .        .                 .              .        .              .           .    .  .   .  .   .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
          .         .        .                 .              .        .              .           .    .  .   .  .   .    inline _GLIBCXX_CONSTEXPR double
          .         .        .                 .              .        .              .           .    .  .   .  .   .    abs(double __x)
807,496,870 (0.8%) 14 (0.0%) 7 (0.1%) 12,144,849 (0.0%) 119,066 (0.3%) 1 (0.0%) 267,712 (0.0%)    0    0  0   0  0   0    { return __builtin_fabs(__x); }
          .         .        .                 .              .        .              .           .    .  .   .  .   .  
          .         .        .                 .              .        .              .           .    .  .   .  .   .    inline _GLIBCXX_CONSTEXPR float
          .         .        .                 .              .        .              .           .    .  .   .  .   .    abs(float __x)
          .         .        .                 .              .        .              .           .    .  .   .  .   .    { return __builtin_fabsf(__x); }
          .         .        .                 .              .        .              .           .    .  .   .  .   .  
          .         .        .                 .              .        .              .           .    .  .   .  .   .    inline _GLIBCXX_CONSTEXPR long double
          .         .        .                 .              .        .              .           .    .  .   .  .   .    abs(long double __x)
          .         .        .                 .              .        .              .           .    .  .   .  .   .    { return __builtin_fabsl(__x); }
-- line 80 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr_____ Dr______________ D1mr____ DLmr____ Dw_______________ D1mw______ DLmw_____ Bc_______________ Bcm_______ Bi Bim 

-- line 230 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _Tp>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      inline const _Tp&
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      min(const _Tp& __a, const _Tp& __b)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        // concept requirements
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        //return __b < __a ? __b : __a;
     24,302 (0.0%)    14 (0.0%)  3 (0.1%)         0        0        0                 9 (0.0%)   0         0                 0          0         0   0        if (__b < __a)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	return __b;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        return __a;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    /**
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @brief This does what you think it does.
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @ingroup sorting_algorithms
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @param  __a  A thing of arbitrary type.
-- line 246 ----------------------------------------
-- line 254 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _Tp>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      inline const _Tp&
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      max(const _Tp& __a, const _Tp& __b)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        // concept requirements
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        //return  __a < __b ? __b : __a;
174,677,259 (0.2%)    22 (0.0%) 11 (0.2%) 3,999,516 (0.0%) 8 (0.0%) 1 (0.0%)  1,245,282 (0.0%)   0         0               117 (0.0%)   2 (0.0%)  0   0        if (__a < __b)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	return __b;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        return __a;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    /**
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @brief This does what you think it does.
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @ingroup sorting_algorithms
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @param  __a  A thing of arbitrary type.
-- line 270 ----------------------------------------
-- line 405 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	      ++__result;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	    }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	  return __result;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	}
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        template<typename _Tp, typename _Up>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	static void
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	__assign_one(_Tp* __to, _Up* __from)
          8 (0.0%)     2 (0.0%)  1 (0.0%)         2 (0.0%) 2 (0.0%) 0                 4 (0.0%)   0         0                 0          0         0   0  	{ *__to = *__from; }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      };
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      struct __copy_move<true, false, random_access_iterator_tag>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        template<typename _II, typename _OI>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
-- line 421 ----------------------------------------
-- line 442 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<bool _IsMove>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      struct __copy_move<_IsMove, true, random_access_iterator_tag>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        template<typename _Tp, typename _Up>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	static _Up*
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	__copy_m(_Tp* __first, _Tp* __last, _Up* __result)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	{
  3,500,798 (0.0%)     0         0        1,750,398 (0.0%) 0        0                 3 (0.0%)   0         0                 0          0         0   0  	  const ptrdiff_t _Num = __last - __first;
 27,849,259 (0.0%)     3 (0.0%)  3 (0.1%) 3,447,064 (0.0%) 0        0                 1 (0.0%)   0         0        10,451,097 (0.1%)  15 (0.0%)  0   0  	  if (__builtin_expect(_Num > 1, true))
 40,160,239 (0.0%)    20 (0.0%) 12 (0.2%) 3,500,050 (0.0%) 4 (0.0%) 4 (0.0%) 17,453,076 (0.2%) 711 (0.0%) 32 (0.0%)          0          0         0   0  	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
         37 (0.0%)     6 (0.0%)  1 (0.0%)         0        0        0                 0          0         0                29 (0.0%)   0         0   0  	  else if (_Num == 1)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	    std::__copy_move<_IsMove, false, random_access_iterator_tag>::
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	      __assign_one(__result, __first);
        812 (0.0%)    15 (0.0%)  3 (0.1%)        10 (0.0%) 0        0               400 (0.0%)   0         0                 0          0         0   0  	  return __result + _Num;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	}
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      };
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _Tp, typename _Ref, typename _Ptr>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      struct _Deque_iterator;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
-- line 464 ----------------------------------------
-- line 942 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _ForwardIterator, typename _Tp>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      inline typename
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	      const _Tp& __value)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
         33 (0.0%)     1 (0.0%)  1 (0.0%)        33 (0.0%) 0        0                 0          0         0                 0          0         0   0        const _Tp __tmp = __value;
        154 (0.0%)     1 (0.0%)  1 (0.0%)         0        0        0                 0          0         0                44 (0.0%)  10 (0.0%)  0   0        for (; __first != __last; ++__first)
     58,275 (0.0%) 1,576 (1.1%)  7 (0.1%)     5,546 (0.0%) 0        0            26,084 (0.0%)   0         0                 0          0         0   0  	*__first = __tmp;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    // Specialization: for char types we can use memset.
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _Tp>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      inline typename
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
-- line 960 ----------------------------------------
-- line 1094 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _OutputIterator, typename _Size, typename _Tp>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      inline typename
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
          8 (0.0%)     1 (0.0%)  1 (0.0%)         0        0        0                 8 (0.0%)   0         0                 0          0         0   0        const _Tp __tmp = __value;
         32 (0.0%)     0         0                0        0        0                 0          0         0                16 (0.0%)   4 (0.0%)  0   0        for (; __n > 0; --__n, (void) ++__first)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	*__first = __tmp;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        return __first;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	   typename _Tp>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
-- line 1111 ----------------------------------------
-- line 1141 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      inline _OutputIterator
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	       std::random_access_iterator_tag)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  #endif
     18,105 (0.0%) 1,631 (1.1%)  4 (0.1%)     5,089 (0.0%) 0        0                 0          0         0             7,341 (0.0%) 129 (0.0%)  0   0        if (__n <= 0)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	return __first;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        __glibcxx_requires_can_increment(__first, __n);
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          8 (0.0%)     1 (0.0%)  1 (0.0%)         0        0        0                 0          0         0                 0          0         0   0        std::__fill_a(__first, __first + __n, __value);
      8,015 (0.0%)     5 (0.0%)  2 (0.0%)     3,956 (0.0%) 0        0                 0          0         0                 0          0         0   0        return __first + __n;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    /**
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @brief Fills the range [first,first+n) with copies of value.
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @ingroup mutating_algorithms
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @param  __first  An output iterator.
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @param  __n      The count of copies to perform.
          .            .         .                .        .        .                 .          .         .                 .          .         .   .     *  @param  __value  A reference-to-const of arbitrary type.
-- line 1163 ----------------------------------------
-- line 2153 ----------------------------------------
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  		       std::__iterator_category(__first));
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _InputIterator, typename _Predicate>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      typename iterator_traits<_InputIterator>::difference_type
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      {
         24 (0.0%)     0         0                0        0        0                 0          0         0                 0          0         0   0        typename iterator_traits<_InputIterator>::difference_type __n = 0;
         40 (0.0%)     0         0                0        0        0                 0          0         0                16 (0.0%)   3 (0.0%)  0   0        for (; __first != __last; ++__first)
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  	if (__pred(__first))
         16 (0.0%)     0         0                8 (0.0%) 0        0                 0          0         0                 0          0         0   0  	  ++__n;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .        return __n;
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      }
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  
          .            .         .                .        .        .                 .          .         .                 .          .         .   .    template<typename _ForwardIterator, typename _Predicate>
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      _ForwardIterator
          .            .         .                .        .        .                 .          .         .                 .          .         .   .      __remove_if(_ForwardIterator __first, _ForwardIterator __last,
          .            .         .                .        .        .                 .          .         .                 .          .         .   .  		_Predicate __pred)
-- line 2172 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir_______________ I1mr________ ILmr_____ Dr_______________ D1mr_________ DLmr Dw___________ D1mw________ DLmw______ Bc_______________ Bcm_____________ Bi Bim 

-- line 91 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        struct _Vector_impl_data
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	pointer _M_start;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	pointer _M_finish;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	pointer _M_end_of_storage;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_Vector_impl_data() _GLIBCXX_NOEXCEPT
    61,205 (0.0%) 4,122 (2.8%) 20 (0.4%)        204 (0.0%)      0           0 59,048 (0.0%) 2,142 (0.0%) 102 (0.1%)          0                0         0   0  	: _M_start(), _M_finish(), _M_end_of_storage()
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	{ }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #if __cplusplus >= 201103L
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
    11,641 (0.0%)    16 (0.0%)  9 (0.2%)      4,879 (0.0%)      0           0  3,522 (0.0%)    53 (0.0%)   0                 0                0         0   0  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
     4,981 (0.0%)     4 (0.0%)  3 (0.1%)      1,620 (0.0%)      0           0  3,361 (0.0%)   709 (0.0%)  31 (0.0%)          0                0         0   0  	  _M_end_of_storage(__x._M_end_of_storage)
        75 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0     65 (0.0%)     0          0                 0                0         0   0  	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #endif
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	{
        77 (0.0%)     6 (0.0%)  6 (0.1%)         36 (0.0%)      0           0     30 (0.0%)     0          0                 0                0         0   0  	  _M_start = __x._M_start;
         9 (0.0%)     1 (0.0%)  1 (0.0%)          9 (0.0%)      0           0      0            0          0                 0                0         0   0  	  _M_finish = __x._M_finish;
        67 (0.0%)     8 (0.0%)  1 (0.0%)         35 (0.0%)      0           0     32 (0.0%)     0          0                 0                0         0   0  	  _M_end_of_storage = __x._M_end_of_storage;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	}
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	{
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  // information used by TBAA.
-- line 124 ----------------------------------------
-- line 361 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        { }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #endif
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        ~_Vector_base() _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_M_deallocate(_M_impl._M_start,
    46,763 (0.0%) 3,363 (2.3%) 29 (0.5%)     33,084 (0.0%)    141 (0.0%)    0    572 (0.0%)     0          0                 0                0         0   0  		      _M_impl._M_end_of_storage - _M_impl._M_start);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .      public:
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _Vector_impl _M_impl;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        pointer
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_allocate(size_t __n)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
    27,592 (0.0%)    42 (0.0%) 14 (0.3%)      2,541 (0.0%)      0           0     67 (0.0%)     1 (0.0%)   0            11,438 (0.0%)        76 (0.0%)  0   0  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_deallocate(pointer __p, size_t __n)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
    60,774 (0.0%)    44 (0.0%) 18 (0.3%)      1,624 (0.0%)      0           0      5 (0.0%)     0          0            28,411 (0.0%)       403 (0.0%)  0   0  	if (__p)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  _Tr::deallocate(_M_impl, __p, __n);
         1 (0.0%)     0         0                 0             0           0      0            0          0                 0                0         0   0        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .      protected:
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_create_storage(size_t __n)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
    15,464 (0.0%)     6 (0.0%)  3 (0.1%)          1 (0.0%)      0           0 10,743 (0.0%)     0          0               100 (0.0%)         1 (0.0%)  0   0  	this->_M_impl._M_start = this->_M_allocate(__n);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	this->_M_impl._M_finish = this->_M_impl._M_start;
    27,040 (0.0%)    38 (0.0%)  9 (0.2%)      3,298 (0.0%)      0           0 11,146 (0.0%)     0          0                 0                0         0   0  	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .      };
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .    /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .     *  @brief A standard container which offers fixed time access to
         .            .         .                 .             .           .      .            .          .                 .                .         .   .     *  individual elements in any order.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .     *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .     *  @ingroup sequences
-- line 408 ----------------------------------------
-- line 593 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  All the elements of @a __x are copied, but any unused capacity in
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @a __x  will not be copied
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  (i.e. capacity() == size() in the new %vector).
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  The newly-created %vector uses a copy of the allocator object used
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  by @a __x (unless the allocator traits dictate a different object).
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
     2,888 (0.0%)     1 (0.0%)  0                 0             0           0  1,444 (0.0%)     0          0                 0                0         0   0        vector(const vector& __x)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        : _Base(__x.size(),
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
     1,666 (0.0%)     5 (0.0%)  1 (0.0%)          0             0           0  1,666 (0.0%)     0          0                 0                0         0   0  	this->_M_impl._M_finish =
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  				      this->_M_impl._M_start,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  				      _M_get_Tp_allocator());
     2,166 (0.0%)     0         0             1,805 (0.0%)      0           0      0            0          0                 0                0         0   0        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #if __cplusplus >= 201103L
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  %Vector move constructor.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  The newly-created %vector contains the exact contents of the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  moved instance.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  The contents of the moved instance are a valid, but unspecified
-- line 617 ----------------------------------------
-- line 670 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  Create a %vector consisting of copies of the elements in the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  initializer_list @a __l.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  This will call the element type's copy constructor N times
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  (where N is @a __l.size()) and do no memory reallocation.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
        24 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0     12 (0.0%)     0          0                 0                0         0   0        vector(initializer_list<value_type> __l,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	     const allocator_type& __a = allocator_type())
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        : _Base(__a)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_M_range_initialize(__l.begin(), __l.end(),
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  			    random_access_iterator_tag());
        16 (0.0%)     0         0                16 (0.0%)      0           0      0            0          0                 0                0         0   0        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #endif
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  Builds a %vector from a range.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __first  An input iterator.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __last  An input iterator.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __a  An allocator.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
-- line 692 ----------------------------------------
-- line 725 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  The dtor only erases the elements, and note that if the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  elements themselves are pointers, the pointed-to memory is
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  not touched in any way.  Managing the pointer is the user's
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  responsibility.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
       295 (0.0%)     8 (0.0%)  1 (0.0%)          0             0           0    196 (0.0%)     0          0                 0                0         0   0        ~vector() _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
     3,508 (0.0%)     9 (0.0%)  3 (0.1%)      3,508 (0.0%)     14 (0.0%)    0      0            0          0                 0                0         0   0  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  		      _M_get_Tp_allocator());
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
       613 (0.0%)     8 (0.0%)  1 (0.0%)        220 (0.0%)      0           0      0            0          0                 0                0         0   0        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  %Vector assignment operator.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __x  A %vector of identical element and allocator types.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  All the elements of @a __x are copied, but any unused capacity in
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @a __x will not be copied.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
-- line 746 ----------------------------------------
-- line 821 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  of elements assigned.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #if __cplusplus >= 201103L
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        template<typename _InputIterator,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	       typename = std::_RequireInputIter<_InputIterator>>
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	assign(_InputIterator __first, _InputIterator __last)
     4,998 (0.0%)     0         0             3,332 (0.0%)      6 (0.0%)    0  1,666 (0.0%)     0          0                 0                0         0   0  	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #else
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        template<typename _InputIterator>
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	assign(_InputIterator __first, _InputIterator __last)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	{
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  // Check whether it's an integral type.  If so, it's not an iterator.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  _M_assign_dispatch(__first, __last, _Integral());
-- line 837 ----------------------------------------
-- line 984 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        crend() const noexcept
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        { return const_reverse_iterator(begin()); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #endif
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // [23.2.4.2] capacity
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**  Returns the number of elements in the %vector.  */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        size_type
     3,365 (0.0%)     0         0             1,699 (0.0%)      0           0  1,666 (0.0%)     0          0                 0                0         0   0        size() const _GLIBCXX_NOEXCEPT
65,721,391 (0.1%)    96 (0.1%) 23 (0.4%) 12,280,959 (0.0%) 61,056 (0.2%)    0  3,336 (0.0%)   704 (0.0%)  31 (0.0%)      3,332 (0.0%)         1 (0.0%)  0   0        { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**  Returns the size() of the largest possible %vector.  */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        size_type
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        max_size() const _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        { return _S_max_size(_M_get_Tp_allocator()); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #if __cplusplus >= 201103L
-- line 1001 ----------------------------------------
-- line 1007 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  number of elements.  If the number is smaller than the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  %vector's current size the %vector is truncated, otherwise
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  default constructed elements are appended.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        resize(size_type __new_size)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         2 (0.0%)     0         0                 0             0           0      0            0          0                 1 (0.0%)         0         0   0  	if (__new_size > size())
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  _M_default_append(__new_size - size());
         2 (0.0%)     0         0                 0             0           0      0            0          0                 0                0         0   0  	else if (__new_size < size())
         1 (0.0%)     0         0                 0             0           0      0            0          0                 0                0         0   0  	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  Resizes the %vector to the specified number of elements.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __new_size  Number of elements the %vector should contain.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __x  Data with which new elements should be populated.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  This function will %resize the %vector to the specified
-- line 1026 ----------------------------------------
-- line 1028 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  %vector's current size the %vector is truncated, otherwise
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  the %vector is extended and new elements are populated with
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  given data.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        resize(size_type __new_size, const value_type& __x)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
        16 (0.0%)     0         0                 0             0           0      0            0          0                 8 (0.0%)         4 (0.0%)  0   0  	if (__new_size > size())
        12 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0      0            0          0                 0                0         0   0  	  _M_fill_insert(end(), __new_size - size(), __x);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	else if (__new_size < size())
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #else
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  Resizes the %vector to the specified number of elements.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __new_size  Number of elements the %vector should contain.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __x  Data with which new elements should be populated.
-- line 1045 ----------------------------------------
-- line 1073 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  Returns the total number of elements that the %vector can
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  hold before needing to allocate more memory.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        size_type
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        capacity() const _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	return size_type(this->_M_impl._M_end_of_storage
    11,220 (0.0%)     2 (0.0%)  1 (0.0%)      5,598 (0.0%)      0           0      6 (0.0%)     0          0                 0                0         0   0  			   - this->_M_impl._M_start);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  Returns true if the %vector is empty.  (Thus begin() would
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  equal end().)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        bool
-- line 1089 ----------------------------------------
-- line 1120 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  This operator allows for easy, array-style, data access.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  Note that data access with this operator is unchecked and
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  out_of_range lookups are not defined. (For checked lookups
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  see at().)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        reference
    15,614 (0.0%)     0         0            15,600 (0.0%)      0           0      0            0          0                 0                0         0   0        operator[](size_type __n) _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	__glibcxx_requires_subscript(__n);
79,132,344 (0.1%)    22 (0.0%) 10 (0.2%)  3,605,692 (0.0%) 30,008 (0.1%)    0 75,960 (0.0%)     0          0        14,000,200 (0.1%) 1,750,009 (1.5%)  0   0  	return *(this->_M_impl._M_start + __n);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  Subscript access to the data contained in the %vector.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param __n The index of the element for which data should be
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  accessed.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @return  Read-only (constant) reference to data.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
-- line 1139 ----------------------------------------
-- line 1142 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  out_of_range lookups are not defined. (For checked lookups
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  see at().)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        const_reference
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        operator[](size_type __n) const _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	__glibcxx_requires_subscript(__n);
84,836,976 (0.1%)     7 (0.0%)  5 (0.1%)     23,840 (0.0%)      0           0  4,640 (0.0%)     0          0            22,400 (0.0%)         5 (0.0%)  0   0  	return *(this->_M_impl._M_start + __n);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .      protected:
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /// Safety check used only from at().
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_range_check(size_type __n) const
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
-- line 1158 ----------------------------------------
-- line 1255 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // data access
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *   Returns a pointer such that [data(), data() + size()) is a valid
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *   range.  For a non-empty %vector, data() == &front().
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _Tp*
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        data() _GLIBCXX_NOEXCEPT
10,503,336 (0.0%)     0         0        10,503,336 (0.0%) 60,003 (0.2%)    0      0            0          0                 0                0         0   0        { return _M_data_ptr(this->_M_impl._M_start); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        const _Tp*
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        data() const _GLIBCXX_NOEXCEPT
79,605,908 (0.1%)     0         0        79,605,908 (0.2%)      0           0      0            0          0                 0                0         0   0        { return _M_data_ptr(this->_M_impl._M_start); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // [23.2.4.3] modifiers
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @brief  Add data to the end of the %vector.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  @param  __x  Data to be added.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  This is a typical stack operation.  The function creates an
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  element at the end of the %vector and assigns the given data
-- line 1276 ----------------------------------------
-- line 1277 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  to it.  Due to the nature of a %vector this operation can be
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  done in constant time if the %vector has preallocated space
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  available.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        push_back(const value_type& __x)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
     2,605 (0.0%)     7 (0.0%)  7 (0.1%)      1,490 (0.0%)      4 (0.0%)    0      0            0          0               747 (0.0%)        63 (0.0%)  0   0  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  				     __x);
     1,329 (0.0%)     0         0                 1 (0.0%)      0           0    664 (0.0%)     0          0                 0                0         0   0  	    ++this->_M_impl._M_finish;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	else
       881 (0.0%)    23 (0.0%) 14 (0.3%)        286 (0.0%)      0           0    371 (0.0%)     0          0                 0                0         0   0  	  _M_realloc_append(__x);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #if __cplusplus >= 201103L
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        push_back(value_type&& __x)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        { emplace_back(std::move(__x)); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
-- line 1302 ----------------------------------------
-- line 1600 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  Erases all the elements.  Note that this function only erases the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  elements, and that if the elements themselves are pointers, the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  pointed-to memory is not touched in any way.  Managing the pointer is
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  the user's responsibility.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        clear() _GLIBCXX_NOEXCEPT
         1 (0.0%)     0         0                 1 (0.0%)      0           0      0            0          0                 0                0         0   0        { _M_erase_at_end(this->_M_impl._M_start); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .      protected:
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        /**
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  Memory expansion handler.  Uses the member allocation function to
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         *  obtain @a n bytes of memory, and then copies [first,last) into it.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .         */
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        template<typename _ForwardIterator>
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
-- line 1616 ----------------------------------------
-- line 1686 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        template<typename _ForwardIterator>
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  			    std::forward_iterator_tag)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	{
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  const size_type __n = std::distance(__first, __last);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  this->_M_impl._M_start
         6 (0.0%)     0         0                 0             0           0      6 (0.0%)     0          0                 0                0         0   0  	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
        14 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0      6 (0.0%)     0          0                 0                0         0   0  	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
         7 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0      7 (0.0%)     0          0                 0                0         0   0  	  this->_M_impl._M_finish =
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    std::__uninitialized_copy_a(__first, __last,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  					this->_M_impl._M_start,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  					_M_get_Tp_allocator());
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	}
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Called by the first initialize_dispatch above and by the
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // vector(n,value,a) constructor.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_fill_initialize(size_type __n, const value_type& __value)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
       361 (0.0%)     0         0                 0             0           0    361 (0.0%)     0          0                 0                0         0   0  	this->_M_impl._M_finish =
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  					_M_get_Tp_allocator());
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #if __cplusplus >= 201103L
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Called by the vector(n) constructor.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_default_initialize(size_type __n)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
     8,383 (0.0%) 1,602 (1.1%)  6 (0.1%)         14 (0.0%)      0           0  8,337 (0.0%)     0          0                 0                0         0   0  	this->_M_impl._M_finish =
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  					   _M_get_Tp_allocator());
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #endif
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Internal assign functions follow.  The *_aux functions do the actual
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // assignment work for the range versions.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
-- line 1727 ----------------------------------------
-- line 1900 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        { return _M_insert_rval(__position, std::move(__v)); }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  #endif
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Called by _M_fill_insert, _M_insert_aux etc.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        size_type
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_check_len(size_type __n, const char* __s) const
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
       359 (0.0%)    13 (0.0%)  7 (0.1%)          0             0           0      0            0          0               117 (0.0%)         9 (0.0%)  0   0  	if (max_size() - size() < __n)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  __throw_length_error(__N(__s));
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	const size_type __len = size() + (std::max)(size(), __n);
       351 (0.0%)     2 (0.0%)  2 (0.0%)          0             0           0      0            0          0                 0                0         0   0  	return (__len < size() || __len > max_size()) ? max_size() : __len;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Called by constructors to check initial size.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        static _GLIBCXX20_CONSTEXPR size_type
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _S_check_init_len(size_type __n, const allocator_type& __a)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
    38,134 (0.0%)    15 (0.0%)  4 (0.1%)        720 (0.0%)      0           0      0            0          0            13,023 (0.0%)       167 (0.0%)  0   0  	if (__n > _S_max_size(_Tp_alloc_type(__a)))
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  __throw_length_error(
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	      __N("cannot create std::vector larger than max_size()"));
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	return __n;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        static _GLIBCXX20_CONSTEXPR size_type
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
-- line 1927 ----------------------------------------
-- line 1937 ----------------------------------------
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Internal erase functions follow.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        // _M_assign_aux.
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _GLIBCXX20_CONSTEXPR
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        void
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        {
         3 (0.0%)     0         0                 1 (0.0%)      0           0      0            0          0                 1 (0.0%)         1 (0.0%)  0   0  	if (size_type __n = this->_M_impl._M_finish - __pos)
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  {
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    std::_Destroy(__pos, this->_M_impl._M_finish,
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  			  _M_get_Tp_allocator());
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    this->_M_impl._M_finish = __pos;
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  	  }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .        }
         .            .         .                 .             .           .      .            .          .                 .                .         .   .  
-- line 1953 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/span
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr____ Dr_______________ D1mr____ DLmr Dw_______________ D1mw________ DLmw______ Bc______________ Bcm______ Bi Bim 

-- line 81 ----------------------------------------
          .            .        .                 .        .           .          .            .          .                .         .         .   .        };
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .      template<>
          .            .        .                 .        .           .          .            .          .                .         .         .   .        class __extent_storage<dynamic_extent>
          .            .        .                 .        .           .          .            .          .                .         .         .   .        {
          .            .        .                 .        .           .          .            .          .                .         .         .   .        public:
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	constexpr
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	__extent_storage(size_t __extent) noexcept
  3,523,060 (0.0%)    24 (0.0%) 4 (0.1%)      1,666 (0.0%) 0           0     21,334 (0.0%) 1,429 (0.0%) 712 (0.5%)        12 (0.0%)  1 (0.0%)  0   0  	: _M_extent_value(__extent)
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	{ }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	constexpr size_t
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	_M_extent() const noexcept
 31,308,484 (0.0%)     9 (0.0%) 2 (0.0%) 17,395,536 (0.1%) 1 (0.0%)    0      2,112 (0.0%)   704 (0.0%)   0        6,950,842 (0.1%) 70 (0.0%)  0   0  	{ return this->_M_extent_value; }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        private:
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	size_t _M_extent_value;
          .            .        .                 .        .           .          .            .          .                .         .         .   .        };
          .            .        .                 .        .           .          .            .          .                .         .         .   .    } // namespace __detail
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .    template<typename _Type, size_t _Extent = dynamic_extent>
          .            .        .                 .        .           .          .            .          .                .         .         .   .      class span
-- line 102 ----------------------------------------
-- line 143 ----------------------------------------
          .            .        .                 .        .           .          .            .          .                .         .         .   .        // member constants
          .            .        .                 .        .           .          .            .          .                .         .         .   .        static constexpr size_t extent = _Extent;
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        // constructors, copy and assignment
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr
          .            .        .                 .        .           .          .            .          .                .         .         .   .        span() noexcept
          .            .        .                 .        .           .          .            .          .                .         .         .   .        requires (_Extent == dynamic_extent || _Extent == 0)
     18,110 (0.0%) 1,613 (1.1%) 2 (0.0%)          0        0           0     18,110 (0.0%)   715 (0.0%)  31 (0.0%)         0         0         0   0        : _M_ptr(nullptr), _M_extent(0)
          .            .        .                 .        .           .          .            .          .                .         .         .   .        { }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        template<contiguous_iterator _It>
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	requires __is_compatible_ref<iter_reference_t<_It>>::value
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	constexpr explicit(extent != dynamic_extent)
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	span(_It __first, size_type __count)
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	noexcept
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	: _M_ptr(std::to_address(__first)), _M_extent(__count)
-- line 159 ----------------------------------------
-- line 278 ----------------------------------------
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	__glibcxx_assert(!empty());
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	return *(this->_M_ptr + (size() - 1));
          .            .        .                 .        .           .          .            .          .                .         .         .   .        }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[nodiscard]]
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr reference
          .            .        .                 .        .           .          .            .          .                .         .         .   .        operator[](size_type __idx) const noexcept
          .            .        .                 .        .           .          .            .          .                .         .         .   .        {
 15,645,794 (0.0%)     5 (0.0%) 1 (0.0%)  6,948,730 (0.0%) 7 (0.0%)    0          0            0          0                0         0         0   0  	__glibcxx_assert(__idx < size());
179,049,970 (0.2%) 1,715 (1.2%) 8 (0.1%) 48,688,790 (0.1%) 5 (0.0%)    0 27,788,256 (0.3%)     0          0                0         0         0   0  	return *(this->_M_ptr + __idx);
          .            .        .                 .        .           .          .            .          .                .         .         .   .        }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .  #if __cpp_lib_span >= 202311L // >= C++26
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[nodiscard]]
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr reference
          .            .        .                 .        .           .          .            .          .                .         .         .   .        at(size_type __idx) const
          .            .        .                 .        .           .          .            .          .                .         .         .   .        {
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	if (__idx >= size())
-- line 295 ----------------------------------------
-- line 309 ----------------------------------------
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[nodiscard]]
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr iterator
          .            .        .                 .        .           .          .            .          .                .         .         .   .        begin() const noexcept
          .            .        .                 .        .           .          .            .          .                .         .         .   .        { return iterator(this->_M_ptr); }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[nodiscard]]
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr iterator
          .            .        .                 .        .           .          .            .          .                .         .         .   .        end() const noexcept
 10,500,000 (0.0%)     9 (0.0%) 1 (0.0%)  3,500,000 (0.0%) 0           0  3,500,000 (0.0%)   706 (0.0%)  31 (0.0%)         0         0         0   0        { return iterator(this->_M_ptr + this->size()); }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[nodiscard]]
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr reverse_iterator
          .            .        .                 .        .           .          .            .          .                .         .         .   .        rbegin() const noexcept
          .            .        .                 .        .           .          .            .          .                .         .         .   .        { return reverse_iterator(this->end()); }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[nodiscard]]
          .            .        .                 .        .           .          .            .          .                .         .         .   .        constexpr reverse_iterator
-- line 325 ----------------------------------------
-- line 433 ----------------------------------------
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	__glibcxx_assert(__offset <= size());
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	if (__count == dynamic_extent)
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	  __count = this->size() - __offset;
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	else
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	  {
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	    __glibcxx_assert(__count <= size());
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	    __glibcxx_assert(__offset + __count <= size());
          .            .        .                 .        .           .          .            .          .                .         .         .   .  	  }
 20,841,192 (0.0%)     0        0                 0        0           0  6,947,064 (0.1%)     0          0                0         0         0   0  	return {this->data() + __offset, __count};
          .            .        .                 .        .           .          .            .          .                .         .         .   .        }
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .      private:
          .            .        .                 .        .           .          .            .          .                .         .         .   .        pointer _M_ptr;
          .            .        .                 .        .           .          .            .          .                .         .         .   .        [[no_unique_address]] __detail::__extent_storage<extent> _M_extent;
          .            .        .                 .        .           .          .            .          .                .         .         .   .      };
          .            .        .                 .        .           .          .            .          .                .         .         .   .  
          .            .        .                 .        .           .          .            .          .                .         .         .   .    // deduction guides
-- line 449 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir____________________ I1mr__________ ILmr_________ Dr____________________ D1mr______________ DLmr__________ Dw___________________ D1mw______________ DLmw___________ Bc___________________ Bcm________________ Bi___________________ Bim__________ 

54,201,601,203 (52.7%) 69,191 (46.9%)   446  (8.2%) 17,900,804,026 (53.8%) 32,020,904 (88.2%)    222  (1.0%) 6,151,588,697 (74.3%) 51,830,847 (96.2%)  19,455 (13.1%) 6,539,169,549 (55.5%) 115,403,438 (97.0%)             0             0            annotated: files known & above threshold & readable, line numbers known
             0              0             0                      0                  0              0                     0                  0               0                     0                   0                     0             0            annotated: files known & above threshold & readable, line numbers unknown
             0              0             0                      0                  0              0                     0                  0               0                     0                   0                     0             0          unannotated: files known & above threshold & two or more non-identical
43,617,411,599 (42.4%)  3,312  (2.2%)    25  (0.5%) 13,071,364,613 (39.3%)  3,870,725 (10.7%)     59  (0.3%) 2,032,474,658 (24.6%)  1,899,363  (3.5%)   7,739  (5.2%) 4,381,599,601 (37.2%)   2,889,034  (2.4%)             0             0          unannotated: files known & above threshold & unreadable 
   506,274,307  (0.5%) 69,371 (47.0%) 4,041 (74.4%)    208,797,420  (0.6%)    304,423  (0.8%) 21,781 (98.6%)    92,194,997  (1.1%)    136,859  (0.3%) 121,213 (81.6%)    53,738,334  (0.5%)     651,813  (0.5%)     6,960,334  (0.4%) 1,774 (21.7%)  unannotated: files known & below threshold
 4,520,678,136  (4.4%)  5,798  (3.9%)   919 (16.9%)  2,107,648,263  (6.3%)    124,439  (0.3%)     31  (0.1%)        97,845  (0.0%)      5,381  (0.0%)     186  (0.1%)   804,237,158  (6.8%)       3,025  (0.0%) 1,705,430,602 (99.6%) 6,419 (78.3%)  unannotated: files unknown

