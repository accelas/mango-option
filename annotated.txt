--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out --auto=yes
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         67108864 B, 64 B, direct-mapped
Command:          bazel-bin/benchmarks/readme_benchmarks
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir______________________ I1mr____________ ILmr__________ Dr_____________________ D1mr_______________ DLmr___________ Dw_____________________ D1mw_______________ DLmw____________ Bc_____________________ Bcm_________________ Bi____________________ Bim________________ 

105,054,679,935 (100.0%) 122,310 (100.0%) 5,740 (100.0%) 34,683,790,484 (100.0%) 38,320,331 (100.0%) 18,802 (100.0%) 10,307,779,022 (100.0%) 75,082,600 (100.0%) 191,832 (100.0%) 13,397,733,487 (100.0%) 141,806,037 (100.0%) 1,704,652,411 (100.0%) 16,771,750 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir___________________________ I1mr_________________ ILmr______________ Dr__________________________ D1mr_____________________ DLmr____________ Dw__________________________ D1mw_____________________ DLmw__________________ Bc__________________________ Bcm______________________ Bi__________________________ Bim________________________  file:function

< 26,178,598,024 (24.9%, 24.9%)    350  (0.3%,  0.3%)   4  (0.1%,  0.1%) 8,997,467,502 (25.9%, 25.9%)  3,753,800  (9.8%,  9.8%)  35 (0.2%, 0.2%)             0  (0.0%,  0.0%)          0  (0.0%,  0.0%)       0  (0.0%,  0.0%) 1,637,525,964 (12.2%, 12.2%)    991,666  (0.7%,  0.7%)             0  (0.0%,  0.0%)          0   (0.0%,   0.0%)  ./math/../sysdeps/ieee754/dbl-64/e_exp.c:__ieee754_exp_fma

< 16,920,780,600 (16.1%, 41.0%)    112  (0.1%,  0.4%)   4  (0.1%,  0.1%) 7,675,467,576 (22.1%, 48.1%) 11,584,980 (30.2%, 40.0%)   0 (0.0%, 0.2%) 2,297,962,128 (22.3%, 22.3%) 21,733,548 (28.9%, 28.9%)     156  (0.1%,  0.1%) 2,338,060,512 (17.5%, 29.7%) 13,366,577  (9.4%, 10.1%)             0  (0.0%,  0.0%)          0   (0.0%,   0.0%)  /proc/self/cwd/./src/pde/core/thomas_solver.hpp:mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

< 12,494,875,958 (11.9%, 52.9%)  7,584  (6.2%,  6.6%)  44  (0.8%,  0.9%) 4,448,363,232 (12.8%, 60.9%) 13,619,633 (35.5%, 75.6%) 199 (1.1%, 1.2%) 1,182,550,748 (11.5%, 33.8%)  9,811,730 (13.1%, 42.0%)     237  (0.1%,  0.2%) 2,005,395,664 (15.0%, 44.6%) 50,173,183 (35.4%, 45.5%)             0  (0.0%,  0.0%)          0   (0.0%,   0.0%)  /proc/self/cwd/./src/pde/core/pde_solver.hpp:
  11,762,215,458 (11.2%)         3,335  (2.7%)         19  (0.3%)        3,915,017,432 (11.3%)        11,669,415 (30.5%)        139 (0.7%)       1,064,407,548 (10.3%)         5,968,957  (7.9%)             52  (0.0%)        1,887,206,664 (14.1%)        43,411,260 (30.6%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     732,187,200  (0.7%)         3,105  (2.5%)         15  (0.3%)          533,226,400  (1.5%)         1,950,137  (5.1%)         60 (0.3%)         118,112,800  (1.1%)         3,840,758  (5.1%)             92  (0.0%)          118,095,200  (0.9%)         6,758,683  (4.8%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

< 12,281,439,720 (11.7%, 64.6%)      9  (0.0%,  6.6%)   1  (0.0%,  0.9%) 3,275,050,592  (9.4%, 70.3%)         52  (0.0%, 75.6%)   2 (0.0%, 1.3%) 1,637,525,296 (15.9%, 49.7%)        678  (0.0%, 42.0%)      31  (0.0%,  0.2%) 2,456,287,944 (18.3%, 63.0%)         16  (0.0%, 45.5%)             0  (0.0%,  0.0%)          0   (0.0%,   0.0%)  ./math/./w_exp_template.c:exp@@GLIBC_2.29

<  9,012,520,894  (8.6%, 73.2%) 15,327 (12.5%, 19.1%)  50  (0.9%,  1.8%) 1,764,906,672  (5.1%, 75.4%)  7,502,536 (19.6%, 95.1%)  53 (0.3%, 1.5%) 1,657,685,190 (16.1%, 65.7%)  7,567,861 (10.1%, 52.1%)     133  (0.1%,  0.3%)   802,556,608  (6.0%, 69.0%) 10,064,191  (7.1%, 52.6%)             0  (0.0%,  0.0%)          0   (0.0%,   0.0%)  /proc/self/cwd/src/option/american_option.cpp:
   8,565,874,992  (8.2%)            57  (0.0%)          1  (0.0%)        1,576,878,112  (4.5%)         7,382,022 (19.3%)         52 (0.3%)       1,570,193,448 (15.2%)         7,561,454 (10.1%)             40  (0.0%)          768,385,064  (5.7%)         6,684,674  (4.7%)                    0                         0                     mango::(anonymous namespace)::AmericanPutObstacle::operator()(double, std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>) const [clone .isra.0]
     428,404,264  (0.4%)         5,070  (4.1%)          7  (0.1%)          180,760,344  (0.5%)           119,070  (0.3%)          0                 87,038,640  (0.8%)               680  (0.0%)             31  (0.0%)           33,468,256  (0.2%)         3,369,291  (2.4%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<  5,053,194,494  (4.8%, 78.0%)     48  (0.0%, 19.2%)  14  (0.2%,  2.0%) 1,288,388,959  (3.7%, 79.1%)          0  (0.0%, 95.1%)   0 (0.0%, 1.5%)    77,780,059  (0.8%, 66.5%)          0  (0.0%, 52.1%)       0  (0.0%,  0.3%)   541,951,344  (4.0%, 73.0%) 26,344,904 (18.6%, 71.2%)             0  (0.0%,  0.0%)          0   (0.0%,   0.0%)  /proc/self/cwd/./src/interpolation/bspline_4d.hpp:
   5,053,194,476  (4.8%)            47  (0.0%)         13  (0.2%)        1,288,388,959  (3.7%)                 0                  0                 77,780,054  (0.8%)                 0                      0                  541,951,344  (4.0%)        26,344,904 (18.6%)                    0                         0                     mango::BSpline4D_FMA::eval(double, double, double, double) const

<  4,353,092,911  (4.1%, 82.1%) 18,380 (15.0%, 34.2%) 986 (17.2%, 19.2%) 2,062,969,571  (5.9%, 85.1%)    482,406  (1.3%, 96.4%)  46 (0.2%, 1.8%)       137,472  (0.0%, 66.5%)      5,150  (0.0%, 52.1%)     781  (0.4%,  0.7%)   763,221,146  (5.7%, 78.7%)      5,732  (0.0%, 71.2%) 1,681,217,328 (98.6%, 98.6%) 16,763,706 (100.0%, 100.0%)  ???:
   4,352,408,174  (4.1%)        13,411 (11.0%)        424  (7.4%)        2,062,832,693  (5.9%)           481,643  (1.3%)         11 (0.1%)              32,688  (0.0%)             4,327  (0.0%)             20  (0.0%)          763,168,629  (5.7%)             1,795  (0.0%)        1,681,213,489 (98.6%)        16,762,115  (99.9%)            ???

<  2,531,275,296  (2.4%, 84.6%)     40  (0.0%, 34.2%)   1  (0.0%, 19.2%)   920,463,744  (2.7%, 87.7%)          0  (0.0%, 96.4%)   0 (0.0%, 1.8%)   460,231,872  (4.5%, 71.0%)          0  (0.0%, 52.1%)       0  (0.0%,  0.7%)             0  (0.0%, 78.7%)          0  (0.0%, 71.2%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /usr/include/c++/14/experimental/bits/simd_builtin.h:
   1,380,695,616  (1.3%)             0                  0                  460,231,872  (1.3%)                 0                  0                230,115,936  (2.2%)                 0                      0                            0                         0                            0                         0                     mango::operators::SimdBackend<double>::compute_second_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]
   1,150,579,680  (1.1%)            40  (0.0%)          1  (0.0%)          460,231,872  (1.3%)                 0                  0                230,115,936  (2.2%)                 0                      0                            0                         0                            0                         0                     mango::operators::SimdBackend<double>::compute_first_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]

<  2,454,311,146  (2.3%, 86.9%)     10  (0.0%, 34.2%)   1  (0.0%, 19.3%)             0  (0.0%, 87.7%)          0  (0.0%, 96.4%)   0 (0.0%, 1.8%)             0  (0.0%, 71.0%)          0  (0.0%, 52.1%)       0  (0.0%,  0.7%)             0  (0.0%, 78.7%)          0  (0.0%, 71.2%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  ./math/../sysdeps/ieee754/dbl-64/math_config.h:
   2,454,305,546  (2.3%)            10  (0.0%)          1  (0.0%)                    0                         0                  0                          0                         0                      0                            0                         0                            0                         0                     __ieee754_exp_fma

<  2,291,331,084  (2.2%, 89.1%)    344  (0.3%, 34.5%)   5  (0.1%, 19.3%)    33,808,169  (0.1%, 87.8%)          7  (0.0%, 96.4%)   0 (0.0%, 1.8%) 1,689,362,394 (16.4%, 87.3%) 15,146,669 (20.2%, 72.3%) 157,016 (81.9%, 82.5%) 1,374,010,219 (10.3%, 89.0%)  1,454,657  (1.0%, 72.2%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<  2,225,775,480  (2.1%, 91.2%)    457  (0.4%, 34.9%)   7  (0.1%, 19.5%)   225,912,328  (0.7%, 88.5%)    148,128  (0.4%, 96.8%)   0 (0.0%, 1.8%)    83,673,840  (0.8%, 88.2%)          0  (0.0%, 72.3%)       0  (0.0%, 82.5%)   560,636,640  (4.2%, 93.1%) 16,734,165 (11.8%, 84.0%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /proc/self/cwd/./src/pde/operators/centered_difference_simd_backend.hpp:
   1,058,498,624  (1.0%)            54  (0.0%)          3  (0.1%)          100,404,768  (0.3%)                 0                  0                 25,101,192  (0.2%)                 0                      0                  271,951,256  (2.0%)         8,367,083  (5.9%)                    0                         0                     mango::operators::SimdBackend<double>::compute_second_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]
   1,033,397,432  (1.0%)           125  (0.1%)          3  (0.1%)           75,303,576  (0.2%)            59,064  (0.2%)          0                 25,101,192  (0.2%)                 0                      0                  271,951,256  (2.0%)         8,367,080  (5.9%)                    0                         0                     mango::operators::SimdBackend<double>::compute_first_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]

<  2,200,096,576  (2.1%, 93.3%)    671  (0.5%, 35.4%)  19  (0.3%, 19.8%)    92,149,928  (0.3%, 88.8%)    149,827  (0.4%, 97.2%)   4 (0.0%, 1.8%)   560,663,544  (5.4%, 93.6%) 18,661,926 (24.9%, 97.1%)     252  (0.1%, 82.7%)   430,194,576  (3.2%, 96.4%) 15,103,135 (10.7%, 94.7%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /proc/self/cwd/./src/pde/operators/spatial_operator.hpp:
   1,968,951,584  (1.9%)           557  (0.5%)         14  (0.2%)           83,723,576  (0.2%)           119,072  (0.3%)          4 (0.0%)         509,189,128  (4.9%)        16,771,253 (22.3%)            221  (0.1%)          373,674,576  (2.8%)        13,419,097  (9.5%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     231,132,416  (0.2%)            78  (0.1%)          4  (0.1%)            8,420,064  (0.0%)            30,734  (0.1%)          0                 51,468,128  (0.5%)         1,890,001  (2.5%)              0                   56,520,000  (0.4%)         1,684,038  (1.2%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

<  1,592,732,174  (1.5%, 94.8%)    122  (0.1%, 35.5%)  42  (0.7%, 20.5%)   360,056,288  (1.0%, 89.8%)          1  (0.0%, 97.2%)   1 (0.0%, 1.8%)   101,641,835  (1.0%, 94.6%)          0  (0.0%, 97.1%)       0  (0.0%, 82.7%)   200,773,064  (1.5%, 97.9%)  5,973,890  (4.2%, 98.9%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /proc/self/cwd/./src/interpolation/bspline_utils.hpp:
   1,518,696,709  (1.4%)            98  (0.1%)         31  (0.5%)          346,250,641  (1.0%)                 1  (0.0%)          1 (0.0%)         100,386,520  (1.0%)                 0                      0                  190,734,064  (1.4%)         5,973,673  (4.2%)                    0                         0                     mango::cubic_basis_nonuniform(std::vector<double, std::allocator<double> > const&, int, double, double*) [clone .isra.0]

<  1,229,598,613  (1.2%, 96.0%)    143  (0.1%, 35.6%)  19  (0.3%, 20.9%)   356,310,814  (1.0%, 90.8%)    238,258  (0.6%, 97.8%)  25 (0.1%, 1.9%)   326,148,498  (3.2%, 97.7%)  1,961,543  (2.6%, 99.7%)   7,867  (4.1%, 86.8%)   139,349,382  (1.0%, 98.9%)  1,010,731  (0.7%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
   1,229,594,548  (1.2%)           112  (0.1%)         10  (0.2%)          356,310,222  (1.0%)           238,214  (0.6%)          9 (0.0%)         326,148,149  (3.2%)         1,961,456  (2.6%)          7,780  (4.1%)          139,348,533  (1.0%)         1,010,570  (0.7%)                    0                         0                     __memcpy_avx_unaligned_erms

<    910,648,577  (0.9%, 96.8%)  7,307  (6.0%, 41.6%) 245  (4.3%, 25.1%)   274,707,003  (0.8%, 91.6%)    121,331  (0.3%, 98.1%)   0 (0.0%, 1.9%)       180,886  (0.0%, 97.7%)      2,143  (0.0%, 99.7%)     720  (0.4%, 87.2%)    73,747,448  (0.6%, 99.4%)      1,310  (0.0%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /usr/include/c++/14/bits/stl_vector.h:
     501,229,800  (0.5%)         1,019  (0.8%)          6  (0.1%)          147,027,408  (0.4%)                 0                  0                          0                         0                      0                   53,464,512  (0.4%)                 8  (0.0%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     218,920,634  (0.2%)         2,768  (2.3%)         15  (0.3%)           47,152,067  (0.1%)           120,002  (0.3%)          0                         68  (0.0%)                 0                      0                   20,207,999  (0.2%)               243  (0.0%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

<    800,867,664  (0.8%, 97.6%)  1,573  (1.3%, 42.9%)   5  (0.1%, 25.2%) 2,198,289,520  (6.3%, 98.0%)         10  (0.0%, 98.1%)   0 (0.0%, 1.9%)         1,544  (0.0%, 97.7%)          0  (0.0%, 99.7%)       0  (0.0%, 87.2%)             0  (0.0%, 99.4%)          0  (0.0%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /proc/self/cwd/./src/pde/operators/black_scholes_pde.hpp:
     641,400,576  (0.6%)            46  (0.0%)          2  (0.0%)        1,756,966,320  (5.1%)                 0                  0                          0                         0                      0                            0                         0                            0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]
     159,456,000  (0.2%)             9  (0.0%)          1  (0.0%)          441,320,000  (1.3%)                 0                  0                          0                         0                      0                            0                         0                            0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve()

<    780,612,187  (0.7%, 98.3%)  1,633  (1.3%, 44.2%)   7  (0.1%, 25.3%)    11,927,201  (0.0%, 98.0%)    119,066  (0.3%, 98.4%)   1 (0.0%, 1.9%)       271,876  (0.0%, 97.7%)          0  (0.0%, 99.7%)       0  (0.0%, 87.2%)             0  (0.0%, 99.4%)          0  (0.0%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /usr/include/c++/14/bits/std_abs.h:
     774,898,128  (0.7%)         1,551  (1.3%)          2  (0.0%)            6,683,064  (0.0%)           119,064  (0.3%)          0                          0                         0                      0                            0                         0                            0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<    363,981,625  (0.3%, 98.7%)  2,167  (1.8%, 46.0%)  48  (0.8%, 26.2%)    49,252,164  (0.1%, 98.1%)         11  (0.0%, 98.4%)   2 (0.0%, 2.0%)    54,916,697  (0.5%, 98.3%)          7  (0.0%, 99.7%)       1  (0.0%, 87.2%)    18,438,810  (0.1%, 99.6%)      1,577  (0.0%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /usr/include/c++/14/bits/stl_algobase.h:
     175,632,380  (0.2%)             6  (0.0%)          2  (0.0%)            3,763,551  (0.0%)                 1  (0.0%)          0                  1,254,517  (0.0%)                 0                      0                            0                         0                            0                         0                     mango::BSpline4D_FMA::eval(double, double, double, double) const
     143,818,216  (0.1%)           214  (0.2%)          2  (0.0%)           36,783,320  (0.1%)                 0                  0                 40,151,320  (0.4%)                 0                      0                   13,366,128  (0.1%)                 1  (0.0%)                    0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<    282,756,092  (0.3%, 99.0%)  3,972  (3.2%, 49.3%)  13  (0.2%, 26.4%)    71,946,212  (0.2%, 98.3%)         55  (0.0%, 98.4%)   0 (0.0%, 2.0%)    45,158,800  (0.4%, 98.7%)    149,766  (0.2%, 99.9%)       0  (0.0%, 87.2%)     6,691,324  (0.0%, 99.6%)         41  (0.0%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /usr/include/c++/14/span:
     234,118,984  (0.2%)         1,761  (1.4%)          7  (0.1%)           70,251,576  (0.2%)                 8  (0.0%)          0                 43,466,384  (0.4%)           119,068  (0.2%)              0                            0                         0                            0                         0                     mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

<    230,115,936  (0.2%, 99.2%)     58  (0.0%, 49.3%)   1  (0.0%, 26.4%)   230,115,936  (0.7%, 99.0%)          0  (0.0%, 98.4%)   0 (0.0%, 2.0%)             0  (0.0%, 98.7%)          0  (0.0%, 99.9%)       0  (0.0%, 87.2%)             0  (0.0%, 99.6%)          0  (0.0%, 99.6%)             0  (0.0%, 98.6%)          0   (0.0%, 100.0%)  /usr/include/c++/14/experimental/bits/simd_x86.h:mango::operators::SimdBackend<double>::compute_second_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]

<    184,093,232  (0.2%, 99.4%)  1,750  (1.4%, 50.7%)   6  (0.1%, 26.5%)    50,202,384  (0.1%, 99.1%)    238,134  (0.6%, 99.1%)   0 (0.0%, 2.0%)    33,469,912  (0.3%, 99.0%)          0  (0.0%, 99.9%)       0  (0.0%, 87.2%)         3,200  (0.0%, 99.6%)      1,543  (0.0%, 99.6%)    16,734,128  (1.0%, 99.6%)         12   (0.0%, 100.0%)  /proc/self/cwd/./src/pde/operators/centered_difference_facade.hpp:
     120,295,152  (0.1%)             0                  0                   40,098,384  (0.1%)           178,128  (0.5%)          0                 26,732,256  (0.3%)                 0                      0                            0                         0                   13,366,128  (0.8%)                10   (0.0%)            mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir___________________________ I1mr_________________ ILmr_____________ Dr___________________________ D1mr_____________________ DLmr____________ Dw__________________________ D1mw_____________________ DLmw__________________ Bc__________________________ Bcm______________________ Bi___________________________ Bim______________________  function:file

> 33,844,373,194 (32.2%, 32.2%) 15,469 (12.6%, 12.6%)  72 (1.3%,  1.3%) 14,096,748,536 (40.6%, 40.6%) 24,057,892 (62.8%, 62.8%) 156 (0.8%, 0.8%) 4,152,776,852 (40.3%, 40.3%) 44,594,187 (59.4%, 59.4%)     491  (0.3%,  0.3%) 4,705,923,712 (35.1%, 35.1%) 73,566,234 (51.9%, 51.9%)    20,049,192  (1.2%,   1.2%)         11  (0.0%,  0.0%)  mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve_implicit_stage(double, double, std::span<double, 18446744073709551615ul>, std::span<double const, 18446744073709551615ul>) [clone .isra.0]:
  16,920,780,600 (16.1%)           112  (0.1%)          4 (0.1%)         7,675,467,576 (22.1%)        11,584,980 (30.2%)          0              2,297,962,128 (22.3%)        21,733,548 (28.9%)            156  (0.1%)        2,338,060,512 (17.5%)        13,366,577  (9.4%)                    0                          0                   /proc/self/cwd/./src/pde/core/thomas_solver.hpp
  11,762,215,458 (11.2%)         3,335  (2.7%)         19 (0.3%)         3,915,017,432 (11.3%)        11,669,415 (30.5%)        139 (0.7%)       1,064,407,548 (10.3%)         5,968,957  (7.9%)             52  (0.0%)        1,887,206,664 (14.1%)        43,411,260 (30.6%)                    0                          0                   /proc/self/cwd/./src/pde/core/pde_solver.hpp
   1,968,951,584  (1.9%)           557  (0.5%)         14 (0.2%)            83,723,576  (0.2%)           119,072  (0.3%)          4 (0.0%)         509,189,128  (4.9%)        16,771,253 (22.3%)            221  (0.1%)          373,674,576  (2.8%)        13,419,097  (9.5%)                    0                          0                   /proc/self/cwd/./src/pde/operators/spatial_operator.hpp
     774,898,128  (0.7%)         1,551  (1.3%)          2 (0.0%)             6,683,064  (0.0%)           119,064  (0.3%)          0                          0                         0                      0                            0                         0                            0                          0                   /usr/include/c++/14/bits/std_abs.h
     641,400,576  (0.6%)            46  (0.0%)          2 (0.0%)         1,756,966,320  (5.1%)                 0                  0                          0                         0                      0                            0                         0                            0                          0                   /proc/self/cwd/./src/pde/operators/black_scholes_pde.hpp
     501,229,800  (0.5%)         1,019  (0.8%)          6 (0.1%)           147,027,408  (0.4%)                 0                  0                          0                         0                      0                   53,464,512  (0.4%)                 8  (0.0%)                    0                          0                   /usr/include/c++/14/bits/stl_vector.h
     428,404,264  (0.4%)         5,070  (4.1%)          7 (0.1%)           180,760,344  (0.5%)           119,070  (0.3%)          0                 87,038,640  (0.8%)               680  (0.0%)             31  (0.0%)           33,468,256  (0.2%)         3,369,291  (2.4%)                    0                          0                   /proc/self/cwd/src/option/american_option.cpp
     234,118,984  (0.2%)         1,761  (1.4%)          7 (0.1%)            70,251,576  (0.2%)                 8  (0.0%)          0                 43,466,384  (0.4%)           119,068  (0.2%)              0                            0                         0                            0                          0                   /usr/include/c++/14/span
     143,818,216  (0.1%)           214  (0.2%)          2 (0.0%)            36,783,320  (0.1%)                 0                  0                 40,151,320  (0.4%)                 0                      0                   13,366,128  (0.1%)                 1  (0.0%)                    0                          0                   /usr/include/c++/14/bits/stl_algobase.h
     120,295,152  (0.1%)             0                  0                   40,098,384  (0.1%)           178,128  (0.5%)          0                 26,732,256  (0.3%)                 0                      0                            0                         0                   13,366,128  (0.8%)                 10  (0.0%)           /proc/self/cwd/./src/pde/operators/centered_difference_facade.hpp

> 28,632,903,570 (27.3%, 59.5%)    360  (0.3%, 12.9%)   5 (0.1%,  1.3%)  8,997,467,502 (25.9%, 66.6%)  3,753,800  (9.8%, 72.6%)  35 (0.2%, 1.0%)             0  (0.0%, 40.3%)          0  (0.0%, 59.4%)       0  (0.0%,  0.3%) 1,637,525,964 (12.2%, 47.3%)    991,666  (0.7%, 52.6%)             0  (0.0%,   1.2%)          0  (0.0%,  0.0%)  __ieee754_exp_fma:
  26,178,598,024 (24.9%)           350  (0.3%)          4 (0.1%)         8,997,467,502 (25.9%)         3,753,800  (9.8%)         35 (0.2%)                   0                         0                      0                1,637,525,964 (12.2%)           991,666  (0.7%)                    0                          0                   ./math/../sysdeps/ieee754/dbl-64/e_exp.c
   2,454,305,546  (2.3%)            10  (0.0%)          1 (0.0%)                     0                         0                  0                          0                         0                      0                            0                         0                            0                          0                   ./math/../sysdeps/ieee754/dbl-64/math_config.h

> 12,281,439,720 (11.7%, 71.2%)      9  (0.0%, 12.9%)   1 (0.0%,  1.4%)  3,275,050,592  (9.4%, 76.0%)         52  (0.0%, 72.6%)   2 (0.0%, 1.0%) 1,637,525,296 (15.9%, 56.2%)        678  (0.0%, 59.4%)      31  (0.0%,  0.3%) 2,456,287,944 (18.3%, 65.7%)         16  (0.0%, 52.6%)             0  (0.0%,   1.2%)          0  (0.0%,  0.0%)  exp@@GLIBC_2.29:./math/./w_exp_template.c

>  8,579,244,320  (8.2%, 79.3%)     66  (0.1%, 13.0%)   2 (0.0%,  1.4%)  1,576,878,112  (4.5%, 80.6%)  7,382,022 (19.3%, 91.8%)  52 (0.3%, 1.3%) 1,570,193,448 (15.2%, 71.4%)  7,561,454 (10.1%, 69.5%)      40  (0.0%,  0.3%)   775,069,728  (5.8%, 71.5%)  6,684,682  (4.7%, 57.3%)             0  (0.0%,   1.2%)          0  (0.0%,  0.0%)  mango::(anonymous namespace)::AmericanPutObstacle::operator()(double, std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>) const [clone .isra.0]:
   8,565,874,992  (8.2%)            57  (0.0%)          1 (0.0%)         1,576,878,112  (4.5%)         7,382,022 (19.3%)         52 (0.3%)       1,570,193,448 (15.2%)         7,561,454 (10.1%)             40  (0.0%)          768,385,064  (5.7%)         6,684,674  (4.7%)                    0                          0                   /proc/self/cwd/src/option/american_option.cpp

>  5,556,255,793  (5.3%, 84.6%)     90  (0.1%, 13.1%)  28 (0.5%,  1.9%)  1,397,531,938  (4.0%, 84.6%)          1  (0.0%, 91.8%)   0 (0.0%, 1.3%)    81,543,605  (0.8%, 72.2%)          0  (0.0%, 69.5%)       0  (0.0%,  0.3%)   577,077,820  (4.3%, 75.8%) 26,695,056 (18.8%, 76.1%)             0  (0.0%,   1.2%)          0  (0.0%,  0.0%)  mango::BSpline4D_FMA::eval(double, double, double, double) const:
   5,053,194,476  (4.8%)            47  (0.0%)         13 (0.2%)         1,288,388,959  (3.7%)                 0                  0                 77,780,054  (0.8%)                 0                      0                  541,951,344  (4.0%)        26,344,904 (18.6%)                    0                          0                   /proc/self/cwd/./src/interpolation/bspline_4d.hpp
     175,632,380  (0.2%)             6  (0.0%)          2 (0.0%)             3,763,551  (0.0%)                 1  (0.0%)          0                  1,254,517  (0.0%)                 0                      0                            0                         0                            0                          0                   /usr/include/c++/14/bits/stl_algobase.h

>  4,352,408,269  (4.1%, 88.8%) 13,411 (11.0%, 24.0%) 424 (7.4%,  9.3%)  2,062,832,693  (5.9%, 90.6%)    481,643  (1.3%, 93.1%)  11 (0.1%, 1.4%)        32,688  (0.0%, 72.2%)      4,327  (0.0%, 69.5%)      20  (0.0%,  0.3%)   763,168,629  (5.7%, 81.5%)      1,795  (0.0%, 76.1%) 1,681,213,489 (98.6%,  99.8%) 16,762,115 (99.9%, 99.9%)  ???:
   4,352,408,174  (4.1%)        13,411 (11.0%)        424 (7.4%)         2,062,832,693  (5.9%)           481,643  (1.3%)         11 (0.1%)              32,688  (0.0%)             4,327  (0.0%)             20  (0.0%)          763,168,629  (5.7%)             1,795  (0.0%)        1,681,213,489 (98.6%)         16,762,115 (99.9%)           ???

>  2,694,411,368  (2.6%, 91.3%)    112  (0.1%, 24.1%)   4 (0.1%,  9.3%)    807,486,704  (2.3%, 92.9%)          0  (0.0%, 93.1%)   0 (0.0%, 1.4%)   255,217,128  (2.5%, 74.7%)          0  (0.0%, 69.5%)       0  (0.0%,  0.3%)   271,951,256  (2.0%, 83.5%)  8,367,083  (5.9%, 82.0%)             0  (0.0%,  99.8%)          0  (0.0%, 99.9%)  mango::operators::SimdBackend<double>::compute_second_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]:
   1,380,695,616  (1.3%)             0                  0                  460,231,872  (1.3%)                 0                  0                230,115,936  (2.2%)                 0                      0                            0                         0                            0                          0                   /usr/include/c++/14/experimental/bits/simd_builtin.h
   1,058,498,624  (1.0%)            54  (0.0%)          3 (0.1%)           100,404,768  (0.3%)                 0                  0                 25,101,192  (0.2%)                 0                      0                  271,951,256  (2.0%)         8,367,083  (5.9%)                    0                          0                   /proc/self/cwd/./src/pde/operators/centered_difference_simd_backend.hpp
     230,115,936  (0.2%)            58  (0.0%)          1 (0.0%)           230,115,936  (0.7%)                 0                  0                          0                         0                      0                            0                         0                            0                          0                   /usr/include/c++/14/experimental/bits/simd_x86.h

>  2,291,331,084  (2.2%, 93.5%)    344  (0.3%, 24.4%)   5 (0.1%,  9.4%)     33,808,169  (0.1%, 93.0%)          7  (0.0%, 93.1%)   0 (0.0%, 1.4%) 1,689,362,394 (16.4%, 91.1%) 15,146,669 (20.2%, 89.6%) 157,016 (81.9%, 82.2%) 1,374,010,219 (10.3%, 93.8%)  1,454,657  (1.0%, 83.0%)             0  (0.0%,  99.8%)          0  (0.0%, 99.9%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>  2,209,078,304  (2.1%, 95.6%)    165  (0.1%, 24.5%)   4 (0.1%,  9.5%)    543,902,512  (1.6%, 94.5%)     59,064  (0.2%, 93.3%)   0 (0.0%, 1.4%)   255,217,128  (2.5%, 93.5%)          0  (0.0%, 89.6%)       0  (0.0%, 82.2%)   271,951,256  (2.0%, 95.8%)  8,367,080  (5.9%, 88.9%)             0  (0.0%,  99.8%)          0  (0.0%, 99.9%)  mango::operators::SimdBackend<double>::compute_first_derivative_uniform(std::span<double const, 18446744073709551615ul>, std::span<double, 18446744073709551615ul>, unsigned long, unsigned long) const [clone .avx2]:
   1,150,579,680  (1.1%)            40  (0.0%)          1 (0.0%)           460,231,872  (1.3%)                 0                  0                230,115,936  (2.2%)                 0                      0                            0                         0                            0                          0                   /usr/include/c++/14/experimental/bits/simd_builtin.h
   1,033,397,432  (1.0%)           125  (0.1%)          3 (0.1%)            75,303,576  (0.2%)            59,064  (0.2%)          0                 25,101,192  (0.2%)                 0                      0                  271,951,256  (2.0%)         8,367,080  (5.9%)                    0                          0                   /proc/self/cwd/./src/pde/operators/centered_difference_simd_backend.hpp

>  1,614,063,921  (1.5%, 97.1%)    101  (0.1%, 24.6%)  32 (0.6%, 10.1%)    351,270,309  (1.0%, 95.6%)          1  (0.0%, 93.3%)   1 (0.0%, 1.4%)   100,386,520  (1.0%, 94.5%)          0  (0.0%, 89.6%)       0  (0.0%, 82.2%)   190,734,064  (1.4%, 97.2%)  5,973,673  (4.2%, 93.2%)             0  (0.0%,  99.8%)          0  (0.0%, 99.9%)  mango::cubic_basis_nonuniform(std::vector<double, std::allocator<double> > const&, int, double, double*) [clone .isra.0]:
   1,518,696,709  (1.4%)            98  (0.1%)         31 (0.5%)           346,250,641  (1.0%)                 1  (0.0%)          1 (0.0%)         100,386,520  (1.0%)                 0                      0                  190,734,064  (1.4%)         5,973,673  (4.2%)                    0                          0                   /proc/self/cwd/./src/interpolation/bspline_utils.hpp

>  1,506,741,161  (1.4%, 98.6%)  8,330  (6.8%, 31.4%)  58 (1.0%, 11.1%)  1,080,642,439  (3.1%, 98.7%)  2,220,945  (5.8%, 99.0%)  60 (0.3%, 1.7%)   198,214,578  (1.9%, 96.4%)  5,762,119  (7.7%, 97.3%)     158  (0.1%, 82.2%)   211,663,465  (1.6%, 98.8%)  8,443,010  (6.0%, 99.1%)     3,368,000  (0.2%, 100.0%)          2  (0.0%, 99.9%)  mango::PDESolver<mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#1}>, mango::DirichletBC<mango::AmericanOptionSolver::solve()::{lambda(double, double)#2}>, mango::operators::SpatialOperator<mango::operators::BlackScholesPDE<double>, double> >::solve():
     732,187,200  (0.7%)         3,105  (2.5%)         15 (0.3%)           533,226,400  (1.5%)         1,950,137  (5.1%)         60 (0.3%)         118,112,800  (1.1%)         3,840,758  (5.1%)             92  (0.0%)          118,095,200  (0.9%)         6,758,683  (4.8%)                    0                          0                   /proc/self/cwd/./src/pde/core/pde_solver.hpp
     231,132,416  (0.2%)            78  (0.1%)          4 (0.1%)             8,420,064  (0.0%)            30,734  (0.1%)          0                 51,468,128  (0.5%)         1,890,001  (2.5%)              0                   56,520,000  (0.4%)         1,684,038  (1.2%)                    0                          0                   /proc/self/cwd/./src/pde/operators/spatial_operator.hpp
     218,920,634  (0.2%)         2,768  (2.3%)         15 (0.3%)            47,152,067  (0.1%)           120,002  (0.3%)          0                         68  (0.0%)                 0                      0                   20,207,999  (0.2%)               243  (0.0%)                    0                          0                   /usr/include/c++/14/bits/stl_vector.h
     159,456,000  (0.2%)             9  (0.0%)          1 (0.0%)           441,320,000  (1.3%)                 0                  0                          0                         0                      0                            0                         0                            0                          0                   /proc/self/cwd/./src/pde/operators/black_scholes_pde.hpp

>  1,229,594,548  (1.2%, 99.7%)    112  (0.1%, 31.5%)  10 (0.2%, 11.2%)    356,310,222  (1.0%, 99.7%)    238,214  (0.6%, 99.7%)   9 (0.0%, 1.7%)   326,148,149  (3.2%, 99.6%)  1,961,456  (2.6%, 99.9%)   7,780  (4.1%, 86.3%)   139,348,533  (1.0%, 99.8%)  1,010,570  (0.7%, 99.8%)             0  (0.0%, 100.0%)          0  (0.0%, 99.9%)  __memcpy_avx_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./math/../sysdeps/ieee754/dbl-64/e_exp.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./math/../sysdeps/ieee754/dbl-64/e_exp.c

--------------------------------------------------------------------------------
-- Annotated source file: ./math/../sysdeps/ieee754/dbl-64/math_config.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./math/../sysdeps/ieee754/dbl-64/math_config.h

--------------------------------------------------------------------------------
-- Annotated source file: ./math/./w_exp_template.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./math/./w_exp_template.c

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/interpolation/bspline_4d.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr_____ ILmr____ Dr________________ D1mr DLmr Dw_______________ D1mw DLmw Bc________________ Bcm_______________ Bi Bim 

-- line 48 ----------------------------------------
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// For right boundary, uses nextafter to ensure x < xmax (not x <= xmax)
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// to avoid issues with half-open interval [xmin, xmax)
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  ///
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// @param x Query point
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// @param xmin Minimum value
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// @param xmax Maximum value
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// @return Clamped value
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  inline double clamp_query(double x, double xmin, double xmax) {
   10,036,136 (0.0%)  3 (0.0%) 1 (0.0%)           0           0    0          0           0    0   5,018,068 (0.0%)          6  (0.0%)  0   0      if (x <= xmin) return xmin;
   10,036,136 (0.0%)  0        0                  0           0    0          0           0    0   5,018,068 (0.0%)         14  (0.0%)  0   0      if (x >= xmax) {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          return std::nextafter(xmax, -std::numeric_limits<double>::infinity());
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      return x;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// 4D Tensor-Product B-Spline with FMA Optimization
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  ///
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  /// Evaluates 4D B-spline surfaces using tensor-product structure:
-- line 65 ----------------------------------------
-- line 84 ----------------------------------------
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> t,
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> v,
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> r,
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                    std::vector<double> coeff)
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          : m_(std::move(m)),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            t_(std::move(t)),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            v_(std::move(v)),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            r_(std::move(r)),
            3 (0.0%)  0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            tm_(clamped_knots_cubic(m_)),
            3 (0.0%)  1 (0.0%) 1 (0.0%)           0           0    0          1 (0.0%)    0    0           0                 0          0   0            tt_(clamped_knots_cubic(t_)),
            3 (0.0%)  0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            tv_(clamped_knots_cubic(v_)),
            3 (0.0%)  0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            tr_(clamped_knots_cubic(r_)),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            c_(std::move(coeff)),
            6 (0.0%)  0        0                  0           0    0          1 (0.0%)    0    0           0                 0          0   0            Nm_(static_cast<int>(m_.size())),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            Nt_(static_cast<int>(t_.size())),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            Nv_(static_cast<int>(v_.size())),
            .         .        .                  .           .    .          .           .    .           .                 .          .   .            Nr_(static_cast<int>(r_.size()))
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nm_ >= 4 && "Moneyness grid must have 4 points");
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nt_ >= 4 && "Maturity grid must have 4 points");
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nv_ >= 4 && "Volatility grid must have 4 points");
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          assert(Nr_ >= 4 && "Rate grid must have 4 points");
-- line 105 ----------------------------------------
-- line 109 ----------------------------------------
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// Evaluate B-spline at query point
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      ///
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param mq Moneyness query
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param tq Maturity query
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param vq Volatility query
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// @param rq Rate query
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// @return Interpolated value
   13,799,687 (0.0%) 11 (0.0%) 1 (0.0%)           0           0    0  7,527,102 (0.1%)    0    0           0                 0          0   0      double eval(double mq, double tq, double vq, double rq) const {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          // Clamp queries to domain
    5,018,068 (0.0%)  0        0          5,018,068 (0.0%)    0    0          0           0    0           0                 0          0   0          mq = clamp_query(mq, m_.front(), m_.back());
    5,018,068 (0.0%)  0        0          5,018,068 (0.0%)    0    0          0           0    0           0                 0          0   0          tq = clamp_query(tq, t_.front(), t_.back());
    5,018,068 (0.0%)  0        0          5,018,068 (0.0%)    0    0          0           0    0           0                 0          0   0          vq = clamp_query(vq, v_.front(), v_.back());
    5,018,068 (0.0%)  3 (0.0%) 1 (0.0%)   5,018,068 (0.0%)    0    0          0           0    0           0                 0          0   0          rq = clamp_query(rq, r_.front(), r_.back());
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          // Find knot spans
    2,509,034 (0.0%)  0        0          2,509,034 (0.0%)    0    0          0           0    0           0                 0          0   0          int im = find_span_cubic(tm_, mq);
    2,509,034 (0.0%)  0        0          2,509,034 (0.0%)    0    0          0           0    0           0                 0          0   0          int jt = find_span_cubic(tt_, tq);
    2,509,034 (0.0%)  0        0          2,509,034 (0.0%)    0    0          0           0    0           0                 0          0   0          int kv = find_span_cubic(tv_, vq);
    3,763,551 (0.0%)  0        0          2,509,034 (0.0%)    0    0  1,254,517 (0.0%)    0    0           0                 0          0   0          int lr = find_span_cubic(tr_, rq);
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          // Evaluate basis functions
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          double wm[4], wt[4], wv[4], wr[4];
   16,308,721 (0.0%)  3 (0.0%) 1 (0.0%)           0           0    0 11,290,653 (0.1%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tm_, im, mq, wm);
   11,290,653 (0.0%)  3 (0.0%) 1 (0.0%)   3,763,551 (0.0%)    0    0  2,509,034 (0.0%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tt_, jt, tq, wt);
   11,290,653 (0.0%)  3 (0.0%) 1 (0.0%)   5,018,068 (0.0%)    0    0  2,509,034 (0.0%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tv_, kv, vq, wv);
    8,781,619 (0.0%)  0        0          2,509,034 (0.0%)    0    0  1,254,517 (0.0%)    0    0           0                 0          0   0          cubic_basis_nonuniform(tr_, lr, rq, wr);
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          // Tensor-product evaluation with FMA
    2,509,034 (0.0%)  3 (0.0%) 1 (0.0%)   1,254,517 (0.0%)    0    0          0           0    0           0                 0          0   0          double sum = 0.0;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
   20,072,272 (0.0%)  0        0                  0           0    0          0           0    0   5,018,068 (0.0%)  1,254,519  (0.9%)  0   0          for (int a = 0; a < 4; ++a) {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .              int im_idx = im - a;
   12,545,170 (0.0%)  0        0          1,254,517 (0.0%)    0    0          0           0    0   5,018,068 (0.0%)          5  (0.0%)  0   0              if (static_cast<unsigned>(im_idx) >= static_cast<unsigned>(Nm_)) continue;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
    5,018,068 (0.0%)  0        0          5,018,068 (0.0%)    0    0          0           0    0           0                 0          0   0              double wma = wm[a];
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
  105,379,428 (0.1%)  0        0         60,216,816 (0.2%)    0    0          0           0    0  20,072,272 (0.1%)  5,018,070  (3.5%)  0   0              for (int b = 0; b < 4; ++b) {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                  int jt_idx = jt - b;
  110,397,496 (0.1%)  3 (0.0%) 1 (0.0%)  25,090,340 (0.1%)    0    0          0           0    0  20,072,272 (0.1%)          3  (0.0%)  0   0                  if (static_cast<unsigned>(jt_idx) >= static_cast<unsigned>(Nt_)) continue;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
   61,471,333 (0.1%)  3 (0.0%) 1 (0.0%)  40,144,544 (0.1%)    0    0          0           0    0           0                 0          0   0                  double wtab = std::fma(wma, wt[b], 0.0);  // wma * wt[b]
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
  281,011,808 (0.3%)  0        0         20,072,272 (0.1%)    0    0          0           0    0  80,289,088 (0.6%) 20,072,277 (14.2%)  0   0                  for (int c = 0; c < 4; ++c) {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      int kv_idx = kv - c;
  361,300,896 (0.3%)  0        0        100,361,360 (0.3%)    0    0          0           0    0  80,289,088 (0.6%)          8  (0.0%)  0   0                      if (static_cast<unsigned>(kv_idx) >= static_cast<unsigned>(Nv_)) continue;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
  240,867,264 (0.2%)  3 (0.0%) 1 (0.0%) 160,578,176 (0.5%)    0    0          0           0    0           0                 0          0   0                      double wtabc = std::fma(wtab, wv[c], 0.0);  // wtab * wv[c]
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // Compute base index for coefficient array
   80,289,088 (0.1%)  0        0                  0           0    0          0           0    0           0                 0          0   0                      const std::size_t base =
  509,333,902 (0.5%)  3 (0.0%) 1 (0.0%) 101,615,877 (0.3%)    0    0 50,180,680 (0.5%)    0    0           0                 0          0   0                          (((std::size_t)im_idx * Nt_ + jt_idx) * Nv_ + kv_idx) * Nr_;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // Compute valid range for rate dimension (d  [0,3])
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // We access coefficient at index (lr - d), which must satisfy 0 <= lr - d < Nr_
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // This gives: max(0, lr - Nr_ + 1) <= d <= min(3, lr)
  240,867,264 (0.2%)  0        0                  0           0    0          0           0    0           0                 0          0   0                      const int d_min = std::max(0, lr - (Nr_ - 1));
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      const int d_max = std::min(3, lr);
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // Get pointer to coefficient block for efficient streaming
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      const double* coeff_block = c_.data() + base;
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // Stream coefficients with no per-iteration branches
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // This replaces 4 separate if blocks with a tight loop,
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      // improving ILP and enabling CPU prefetching
  883,179,968 (0.8%)  0        0                  0           0    0          0           0    0 321,156,352 (2.4%)          2  (0.0%)  0   0                      for (int d = d_min; d <= d_max; ++d) {
  484,243,562 (0.5%)  0        0                  0           0    0          0           0    0           0                 0          0   0                          const int lr_idx = lr - d;
1,531,765,257 (1.5%)  6 (0.0%) 2 (0.0%) 722,601,792 (2.1%)    0    0  1,254,517 (0.0%)    0    0           0                 0          0   0                          sum = std::fma(coeff_block[lr_idx], wtabc * wr[d], sum);
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                      }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .                  }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .              }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          return sum;
   10,036,136 (0.0%)  0        0          8,781,619 (0.0%)    0    0          0           0    0           0                 0          0   0      }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// Get grid dimensions
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      [[nodiscard]] std::tuple<int, int, int, int> dimensions() const noexcept {
            .         .        .                  .           .    .          .           .    .           .                 .          .   .          return {Nm_, Nt_, Nv_, Nr_};
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      }
            .         .        .                  .           .    .          .           .    .           .                 .          .   .  
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      /// Get moneyness grid
            .         .        .                  .           .    .          .           .    .           .                 .          .   .      [[nodiscard]] const std::vector<double>& moneyness_grid() const noexcept { return m_; }
-- line 191 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/interpolation/bspline_utils.hpp
--------------------------------------------------------------------------------
Ir________________ I1mr_____ ILmr____ Dr_______________ D1mr____ DLmr____ Dw_______________ D1mw DLmw Bc_______________ Bcm_____________ Bi Bim 

-- line 20 ----------------------------------------
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// For n data points, creates n+4 knots with repeated endpoints:
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// [x[0], x[0], x[0], x[0], x[1], ..., x[n-4], x[n-1], x[n-1], x[n-1], x[n-1]]
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// The interior knots x[1] through x[n-4] are placed between the clamped endpoints.
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// This ensures the collocation matrix is non-singular (Schoenberg-Whitney condition).
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param x Grid points (must be sorted)
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @return Clamped knot vector
         96 (0.0%)  2 (0.0%) 1 (0.0%)          0        0        0                72 (0.0%)    0    0          0                0         0   0  inline std::vector<double> clamped_knots_cubic(const std::vector<double>& x) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      const int n = static_cast<int>(x.size());
         24 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0      std::vector<double> t(n + 4);
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Left clamp: repeat first point 4 times
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      std::fill_n(t.begin(), 4, x.front());
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Interior knots positioned strictly between data sites (midpoints)
         24 (0.0%)  0        0                 0        0        0                 0           0    0         12 (0.0%)         6 (0.0%)  0   0      if (n > 4) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          const int interior = n - 4;
          6 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0          const int intervals = n - 1;
         18 (0.0%)  0        0                 0        0        0                 0           0    0          6 (0.0%)         0         0   0          for (int idx = 0; idx < interior; ++idx) {
         12 (0.0%)  1 (0.0%) 1 (0.0%)          0        0        0                 0           0    0          0                0         0   0              const double ratio = static_cast<double>(idx + 1) /
         30 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0                                   static_cast<double>(interior + 1);
         48 (0.0%)  0        0                18 (0.0%) 0        0                 0           0    0          0                0         0   0              double pos = ratio * static_cast<double>(intervals);
         12 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0              int low = static_cast<int>(std::floor(pos));
         12 (0.0%)  0        0                 0        0        0                 0           0    0          6 (0.0%)         4 (0.0%)  0   0              if (low >= intervals) {
         12 (0.0%)  1 (0.0%) 1 (0.0%)          6 (0.0%) 0        0                 0           0    0          0                0         0   0                  low = intervals - 1;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .              }
         12 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0              const double frac = pos - static_cast<double>(low);
         12 (0.0%)  0        0                 6 (0.0%) 0        0                 0           0    0          0                0         0   0              const double left = x[low];
         18 (0.0%)  1 (0.0%) 1 (0.0%)          6 (0.0%) 0        0                 0           0    0          0                0         0   0              const double right = x[low + 1];
         18 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0              double knot = (1.0 - frac) * left + frac * right;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          6 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0              const double spacing = right - left;
          6 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0              const double eps = std::max(1e-12 * spacing,
         18 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0                                          std::numeric_limits<double>::epsilon() *
          .         .        .                 .        .        .                 .           .    .          .                .         .   .                                              std::max(std::abs(right), 1.0));
         18 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0              knot = std::clamp(knot, left + eps, right - eps);
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
         12 (0.0%)  1 (0.0%) 1 (0.0%)          0        0        0                 6 (0.0%)    0    0          0                0         0   0              t[4 + idx] = knot;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Right clamp: repeat last point 4 times
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      std::fill_n(t.end() - 4, 4, x.back());
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      return t;
        108 (0.0%)  0        0                84 (0.0%) 0        0                 0           0    0          0                0         0   0  }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// Find knot span containing x using binary search
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// Returns index i such that t[i] <= x < t[i+1]
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param t Knot vector
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param x Query point
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @return Knot span index
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  inline int find_span_cubic(const std::vector<double>& t, double x) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      constexpr int DEGREE = 3;
  5,018,788 (0.0%)  3 (0.0%) 1 (0.0%)          0        0        0                 0           0    0          0                0         0   0      const int n_ctrl = static_cast<int>(t.size()) - DEGREE - 1;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      const int min_span = DEGREE;
  8,781,979 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0      const int max_span = std::max(min_span, n_ctrl - 1);
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
 15,059,004 (0.0%)  3 (0.0%) 1 (0.0%)  5,019,668 (0.0%) 0        0                 0           0    0  5,019,668 (0.0%)         3 (0.0%)  0   0      if (x <= t[min_span]) {
      1,080 (0.0%)  0        0                 0        0        0               360 (0.0%)    0    0          0                0         0   0          return min_span;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
 15,059,524 (0.0%)  0        0         5,021,428 (0.0%) 0        0               360 (0.0%)    0    0  5,019,308 (0.0%)       204 (0.0%)  0   0      if (x >= t[n_ctrl]) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          return max_span;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      auto it = std::upper_bound(t.begin() + min_span, t.begin() + n_ctrl + 1, x);
  8,782,499 (0.0%)  9 (0.0%) 3 (0.1%)          0        0        0                 0           0    0          0                0         0   0      int i = static_cast<int>(std::distance(t.begin(), it)) - 1;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
 11,293,293 (0.0%)  3 (0.0%) 1 (0.0%)  3,763,551 (0.0%) 0        0                 0           0    0          0                0         0   0      if (i < min_span) i = min_span;
 10,038,776 (0.0%)  0        0               880 (0.0%) 0        0         1,254,517 (0.0%)    0    0          0                0         0   0      if (i > max_span) i = max_span;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      return i;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// Evaluate cubic basis functions using Cox-de Boor recursion
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// Computes the 4 nonzero cubic basis functions at x for knot span i.
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// Uses de Boor's recursive formula with proper handling of zero denominators.
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param t Knot vector
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param i Knot span index
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param x Evaluation point
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  /// @param N Output: 4 basis function values N[0..3]
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  ///          N[0] corresponds to basis i, N[1] to i-1, N[2] to i-2, N[3] to i-3
 25,097,260 (0.0%)  0        0                 0        0        0         5,019,308 (0.0%)    0    0          0                0         0   0  inline void cubic_basis_nonuniform(const std::vector<double>& t, int i, double x, double N[4]) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      const int n = static_cast<int>(t.size());
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Ensure exact interpolation at the right boundary.
 20,078,672 (0.0%)  5 (0.0%) 2 (0.0%) 10,039,336 (0.0%) 0        0                 0           0    0  5,019,668 (0.0%)         2 (0.0%)  0   0      if (std::abs(x - t.back()) < 1e-14) {
      1,440 (0.0%)  0        0               720 (0.0%) 0        0               360 (0.0%)    0    0          0                0         0   0          N[0] = 1.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          N[1] = 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          N[2] = 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          N[3] = 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          return;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Degree 0: piecewise constants
 10,038,616 (0.0%)  0        0                 0        0        0         5,019,308 (0.0%)    0    0          0                0         0   0      double N0[4] = {0, 0, 0, 0};
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      for (int k = 0; k < 4; ++k) {
 15,057,924 (0.0%)  0        0                 0        0        0                 0           0    0          0                0         0   0          int idx = i - k;
 35,135,156 (0.0%)  3 (0.0%) 1 (0.0%)          0        0        0                 0           0    0 15,057,924 (0.1%)         5 (0.0%)  0   0          if (idx >= 0 && idx + 1 < n) {
185,714,396 (0.2%) 19 (0.0%) 5 (0.1%) 60,231,696 (0.2%) 1 (0.0%) 1 (0.0%) 20,077,232 (0.2%)    0    0 20,077,232 (0.1%)        20 (0.0%)  0   0              N0[k] = (t[idx] <= x && x < t[idx + 1]) ? 1.0 : 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Degree 1: linear combination
 10,038,616 (0.0%)  0        0                 0        0        0         5,019,308 (0.0%)    0    0          0                0         0   0      double N1[4] = {0, 0, 0, 0};
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      for (int k = 0; k < 4; ++k) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          int idx = i - k;
 25,096,540 (0.0%)  3 (0.0%) 1 (0.0%)          0        0        0                 0           0    0 10,038,616 (0.1%)         0         0   0          if (idx >= 0 && idx + 2 < n) {
 80,308,928 (0.1%)  3 (0.0%) 1 (0.0%) 40,154,464 (0.1%) 0        0                 0           0    0          0                0         0   0              double leftDen  = t[idx + 1] - t[idx];
 30,115,848 (0.0%)  0        0        15,057,924 (0.0%) 0        0                 0           0    0          0                0         0   0              double rightDen = t[idx + 2] - t[idx + 1];
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
107,396,581 (0.1%)  9 (0.0%) 3 (0.1%)  7,010,421 (0.0%) 0        0                 0           0    0 20,077,232 (0.1%) 1,991,284 (1.4%)  0   0              double left  = (leftDen > 0.0) ? (x - t[idx]) / leftDen * N0[k] : 0.0;
 81,262,959 (0.1%)  8 (0.0%) 2 (0.0%)  7,010,421 (0.0%) 0        0                 0           0    0 15,057,924 (0.1%)        87 (0.0%)  0   0              double right = (rightDen > 0.0 && k > 0) ? (t[idx + 2] - x) / rightDen * N0[k - 1] : 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
 50,193,080 (0.0%)  0        0                 0        0        0        20,077,232 (0.2%)    0    0          0                0         0   0              N1[k] = left + right;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Degree 2: quadratic
 10,038,616 (0.0%)  0        0                 0        0        0         5,019,308 (0.0%)    0    0          0                0         0   0      double N2[4] = {0, 0, 0, 0};
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      for (int k = 0; k < 4; ++k) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          int idx = i - k;
 35,135,156 (0.0%)  4 (0.0%) 1 (0.0%)          0        0        0                 0           0    0 15,057,924 (0.1%)         0         0   0          if (idx >= 0 && idx + 3 < n) {
 80,308,928 (0.1%)  5 (0.0%) 2 (0.0%) 40,154,464 (0.1%) 0        0                 0           0    0          0                0         0   0              double leftDen  = t[idx + 2] - t[idx];
 30,115,848 (0.0%)  0        0        30,115,848 (0.1%) 0        0                 0           0    0          0                0         0   0              double rightDen = t[idx + 3] - t[idx + 1];
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
112,415,889 (0.1%) 10 (0.0%) 3 (0.1%) 12,029,729 (0.0%) 0        0                 0           0    0 20,077,232 (0.1%) 1,991,143 (1.4%)  0   0              double left  = (leftDen > 0.0) ? (x - t[idx]) / leftDen * N1[k] : 0.0;
 96,320,883 (0.1%)  7 (0.0%) 3 (0.1%) 12,029,729 (0.0%) 0        0                 0           0    0 15,057,924 (0.1%)         7 (0.0%)  0   0              double right = (rightDen > 0.0 && k > 0) ? (t[idx + 3] - x) / rightDen * N1[k - 1] : 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
 45,173,772 (0.0%)  4 (0.0%) 1 (0.0%)          0        0        0        20,077,232 (0.2%)    0    0          0                0         0   0              N2[k] = left + right;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      // Degree 3: cubic
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      for (int k = 0; k < 4; ++k) {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          int idx = i - k;
 60,231,696 (0.1%)  3 (0.0%) 1 (0.0%)          0        0        0                 0           0    0 20,077,232 (0.1%)         2 (0.0%)  0   0          if (idx >= 0 && idx + 4 < n) {
 75,289,620 (0.1%)  6 (0.0%) 2 (0.0%) 40,154,464 (0.1%) 0        0                 0           0    0          0                0         0   0              double leftDen  = t[idx + 3] - t[idx];
 30,115,848 (0.0%)  3 (0.0%) 1 (0.0%) 30,115,848 (0.1%) 0        0                 0           0    0          0                0         0   0              double rightDen = t[idx + 4] - t[idx + 1];
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
 97,357,965 (0.1%)  3 (0.0%) 1 (0.0%) 17,049,037 (0.0%) 0        0                 0           0    0 20,077,232 (0.1%) 1,991,117 (1.4%)  0   0              double left  = (leftDen > 0.0) ? (x - t[idx]) / leftDen * N2[k] : 0.0;
100,386,160 (0.1%)  0        0        15,057,924 (0.0%) 0        0                 0           0    0 15,057,924 (0.1%)         6 (0.0%)  0   0              double right = (rightDen > 0.0 && k > 0) ? (t[idx + 4] - x) / rightDen * N2[k - 1] : 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
 60,231,696 (0.1%)  3 (0.0%) 1 (0.0%)          0        0        0        20,077,232 (0.2%)    0    0          0                0         0   0              N[k] = left + right;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          } else {
          .         .        .                 .        .        .                 .           .    .          .                .         .   .              N[k] = 0.0;
          .         .        .                 .        .        .                 .           .    .          .                .         .   .          }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .      }
 10,038,616 (0.0%)  0        0        10,038,616 (0.0%) 0        0                 0           0    0          0                0         0   0  }
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  
          .         .        .                 .        .        .                 .           .    .          .                .         .   .  }  // namespace mango

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde/core/pde_solver.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr________ ILmr____ Dr__________________ D1mr_____________ DLmr_____ Dw________________ D1mw____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 63 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// Cache blocking is automatically applied for large grids (n  threshold)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// to improve cache locality and reduce memory bandwidth.
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// @tparam BoundaryL Left boundary condition type
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// @tparam BoundaryR Right boundary condition type
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  /// @tparam SpatialOp Spatial operator type
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  template<typename BoundaryL, typename BoundaryR, typename SpatialOp>
       20,800 (0.0%)    59 (0.0%) 1 (0.0%)         8,000 (0.0%)         0          0              6,400 (0.0%)         0         0                  0                0         0   0  class PDESolver {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  public:
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Constructor
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param grid Spatial grid (x coordinates)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param time Time domain configuration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param config TR-BDF2 configuration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param root_config Root-finding configuration for Newton solver
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param left_bc Left boundary condition
-- line 79 ----------------------------------------
-- line 84 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const TimeDomain& time,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const TRBDF2Config& config,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const RootFindingConfig& root_config,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const BoundaryL& left_bc,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                const BoundaryR& right_bc,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                SpatialOp spatial_op,  // Pass by value, move into member
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                std::optional<ObstacleCallback> obstacle = std::nullopt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                PDEWorkspace* external_workspace = nullptr)
        6,400 (0.0%)    62 (0.1%) 1 (0.0%)         3,200 (0.0%)         0          0              3,200 (0.0%)         0         0                  0                0         0   0          : grid_(grid)
        9,600 (0.0%)   681 (0.6%) 1 (0.0%)         3,200 (0.0%)         0          0              6,400 (0.0%)       671 (0.0%) 31 (0.0%)           0                0         0   0          , time_(time)
        3,200 (0.0%)     0        0                1,600 (0.0%)        38  (0.0%)  0              1,600 (0.0%)         0         0                  0                0         0   0          , config_(config)
        3,200 (0.0%)    76 (0.1%) 1 (0.0%)         1,600 (0.0%)        37  (0.0%)  0              1,600 (0.0%)         0         0                  0                0         0   0          , root_config_(root_config)
        1,600 (0.0%)     0        0                    0                0          0              1,600 (0.0%)       672 (0.0%) 31 (0.0%)           0                0         0   0          , left_bc_(left_bc)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , right_bc_(right_bc)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , spatial_op_(std::move(spatial_op))
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , obstacle_(std::move(obstacle))
        3,200 (0.0%)   146 (0.1%) 1 (0.0%)         1,600 (0.0%)         0          0              1,600 (0.0%)         0         0                  0                0         0   0          , n_(grid.size())
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , workspace_owner_(nullptr)
        1,600 (0.0%)     0        0                    0                0          0              1,600 (0.0%)         0         0                  0                0         0   0          , workspace_(nullptr)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          , u_current_(n_)
        1,600 (0.0%)    23 (0.0%) 1 (0.0%)         1,600 (0.0%)         0          0                  0                0         0                  0                0         0   0          , u_old_(n_)
        1,600 (0.0%)     0        0                1,600 (0.0%)         0          0                  0                0         0                  0                0         0   0          , rhs_(n_)
        1,600 (0.0%)     0        0                1,600 (0.0%)         0          0                  0                0         0                  0                0         0   0          , newton_ws_(n_, acquire_workspace(grid, external_workspace))
        4,800 (0.0%)     8 (0.0%) 1 (0.0%)             0                0          0              4,800 (0.0%)       672 (0.0%) 31 (0.0%)           0                0         0   0          , isa_target_(cpu::select_isa_target())
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          #ifndef NDEBUG
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          std::cout << "PDESolver ISA target: " << cpu::isa_target_name(isa_target_) << "\n";
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          #endif
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Initialize grid information for legacy operators that need it
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // (e.g., LaplacianOperator) via set_grid() if present
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (requires { spatial_op_.set_grid(grid, workspace_->dx()); }) {
-- line 115 ----------------------------------------
-- line 128 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double t = time_.t_start();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_obstacle(t, std::span{u_current_});
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_boundary_conditions(std::span{u_current_}, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solve PDE from t_start to t_end
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @return expected success or solver error diagnostic
       25,600 (0.0%) 1,650 (1.3%) 2 (0.0%)         3,200 (0.0%)        31  (0.0%)  0             16,000 (0.0%)       680 (0.0%) 32 (0.0%)           0                0         0   0      expected<void, SolverError> solve() {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double t = time_.t_start();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double dt = time_.dt();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
   13,476,800 (0.0%)    45 (0.0%) 1 (0.0%)     6,736,000 (0.0%)    30,000  (0.1%)  0          1,685,600 (0.0%)         0         0          1,685,600 (0.0%)     1,602 (0.0%)  0   0          for (size_t step = 0; step < time_.n_steps(); ++step) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double t_old = t;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Store u^n for TR-BDF2
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              std::copy(u_current_.begin(), u_current_.end(), u_old_.begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Stage 1: Trapezoidal rule to t_n + dt
    6,736,000 (0.0%)    23 (0.0%) 1 (0.0%)     5,052,000 (0.0%)         0          0          1,684,000 (0.0%)         0         0                  0                0         0   0              double t_stage1 = t + config_.gamma * dt;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              auto stage1_ok = solve_stage1(t, t_stage1, dt);
    3,368,000 (0.0%)     0        0            1,684,000 (0.0%)         0          0                  0                0         0          1,684,000 (0.0%)        31 (0.0%)  0   0              if (!stage1_ok) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  return unexpected(stage1_ok.error());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Stage 2: BDF2 from t_n to t_n+1
    5,052,000 (0.0%)     0        0            3,368,000 (0.0%)    30,008  (0.1%)  0          1,684,000 (0.0%)         0         0                  0                0         0   0              double t_next = t + dt;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              auto stage2_ok = solve_stage2(t_stage1, t_next, dt);
    3,368,000 (0.0%)     0        0            1,684,000 (0.0%)         0          0                  0                0         0          1,684,000 (0.0%)         0         0   0              if (!stage2_ok) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  return unexpected(stage2_ok.error());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Update time
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              t = t_next;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Process temporal events AFTER completing the step
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              process_temporal_events(t_old, t_next, step);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Process snapshots (CHANGED: pass step index)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              process_snapshots(step, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
        6,400 (0.0%)    40 (0.0%) 1 (0.0%)         1,600 (0.0%)         6  (0.0%)  0              3,200 (0.0%)        10 (0.0%)  0                  0                0         0   0          return {};
       22,400 (0.0%)    56 (0.0%) 1 (0.0%)        17,600 (0.0%)        26  (0.0%)  0                  0                0         0              1,600 (0.0%)         0         0   0      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Get current solution
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::span<const double> solution() const {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          return std::span{u_current_};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Check if obstacle condition is present
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      bool has_obstacle() const {
-- line 179 ----------------------------------------
-- line 248 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::vector<TemporalEvent> events_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      size_t next_event_idx_ = 0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // Workspace for derivatives
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::vector<double> du_dx_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      std::vector<double> d2u_dx2_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      PDEWorkspace& acquire_workspace(std::span<const double> grid, PDEWorkspace* external_workspace) {
        3,200 (0.0%)     0        0                    0                0          0                  0                0         0              1,600 (0.0%)         4 (0.0%)  0   0          if (external_workspace) {
        1,600 (0.0%)     0        0                    0                0          0              1,600 (0.0%)         0         0                  0                0         0   0              workspace_ = external_workspace;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              return *workspace_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          workspace_owner_ = std::make_unique<PDEWorkspace>(n_, grid);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          workspace_ = workspace_owner_.get();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          return *workspace_;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Process snapshots at current step index
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void process_snapshots(size_t step_idx, double t_current) {
    6,736,000 (0.0%)     0        0            1,684,000 (0.0%)         0          0                  0                0         0          1,684,000 (0.0%)         0         0   0          while (next_snapshot_idx_ < snapshot_requests_.size()) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              const auto& req = snapshot_requests_[next_snapshot_idx_];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Check if this step index matches
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (req.step_index > step_idx) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  break;  // Future snapshot
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (req.step_index != step_idx) {
-- line 275 ----------------------------------------
-- line 312 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Events are applied AFTER the TR-BDF2 step completes.
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// This ensures proper ordering: PDE evolution happens first,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// then events modify the solution (e.g., dividend jumps).
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// CRITICAL: After each event, obstacle and boundary conditions
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// must be re-applied to maintain consistency. Dividend jumps
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// interpolate the solution, which can violate constraints.
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void process_temporal_events(double t_old, double t_new, [[maybe_unused]] size_t step) {
    5,052,000 (0.0%)     0        0            1,684,000 (0.0%)         6  (0.0%)  0                  0                0         0          1,684,000 (0.0%) 1,684,000 (1.2%)  0   0          while (next_event_idx_ < events_.size()) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              const auto& event = events_[next_event_idx_];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (event.time <= t_old) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  next_event_idx_++;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  continue;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (event.time > t_new) {
-- line 328 ----------------------------------------
-- line 350 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Apply obstacle condition: u(x,t)  (x,t)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Projects solution onto obstacle constraint via complementarity:
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// u[i] = max(u[i], [i]) for all i
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// This is called AFTER each Newton update to enforce variational
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// inequality constraints (e.g., American option early exercise).
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void apply_obstacle(double t, std::span<double> u) {
   13,369,328 (0.0%)     7 (0.0%) 1 (0.0%)     6,684,664 (0.0%)   119,070  (0.3%)  0                  0                0         0          6,684,664 (0.0%)        23 (0.0%)  0   0          if (!obstacle_) return;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
        1,600 (0.0%)     0        0                1,600 (0.0%)         0          0                  0                0         0                  0                0         0   0          auto psi = workspace_->psi_buffer();
   40,098,384 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          (*obstacle_)(t, grid_, psi);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Project: u[i] = max(u[i], psi[i])
  882,011,552 (0.8%)     6 (0.0%) 1 (0.0%)    20,050,792 (0.1%)         4  (0.0%)  0                  0                0         0        217,162,156 (1.6%) 6,684,669 (4.7%)  0   0          for (size_t i = 0; i < u.size(); ++i) {
  972,181,092 (0.9%)    89 (0.1%) 3 (0.1%)   394,219,528 (1.1%)        69  (0.0%) 69 (0.4%)           0                0         0        197,109,764 (1.5%) 6,498,395 (4.6%)  0   0              if (u[i] < psi[i]) {
   86,928,474 (0.1%)     0        0                    0                0          0        338,965,780 (3.3%)         0         0                  0                0         0   0                  u[i] = psi[i];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Apply boundary conditions
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void apply_boundary_conditions(std::span<double> u, double t) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          auto dx_span = workspace_->dx();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Left boundary
   16,735,728 (0.0%)     0        0           16,735,728 (0.0%)         4  (0.0%)  4 (0.0%)           0                0         0                  0                0         0   0          double x_left = grid_[0];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double dx_left = (n_ > 1) ? dx_span[0] : 1.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double u_interior_left = (n_ > 1) ? u[1] : 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          left_bc_.apply(u[0], x_left, t, dx_left, u_interior_left, 0.0, bc::BoundarySide::Left);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Right boundary
   40,152,920 (0.0%)    50 (0.0%) 2 (0.0%)    33,469,856 (0.1%)   119,068  (0.3%)  0          6,683,064 (0.1%)         0         0                  0                0         0   0          double x_right = grid_[n_ - 1];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double dx_right = (n_ > 1) ? dx_span[n_ - 2] : 1.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          double u_interior_right = (n_ > 1) ? u[n_ - 2] : 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          right_bc_.apply(u[n_ - 1], x_right, t, dx_right, u_interior_right, 0.0, bc::BoundarySide::Right);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Apply spatial operator (single-pass evaluation)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Note: Cache blocking was previously attempted but removed because it was
-- line 390 ----------------------------------------
-- line 396 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                        std::span<const double> u,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                        std::span<double> Lu) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const size_t n = grid_.size();
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Direct evaluation (no blocking)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          spatial_op_.apply(t, u, Lu);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Zero boundary values (BCs will override after)
   25,101,192 (0.0%)   797 (0.7%) 1 (0.0%)     8,367,064 (0.0%)         0          0         16,734,128 (0.2%)         0         0                  0                0         0   0          Lu[0] = Lu[n-1] = 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// TR-BDF2 Stage 1: Trapezoidal rule
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// u^{n+} = u^n + (dt/2)  [L(u^n) + L(u^{n+})]
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solved via Newton-Raphson iteration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      expected<void, SolverError> solve_stage1(double t_n, double t_stage, double dt) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double w1 = config_.stage1_weight(dt);  // dt/2
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Compute L(u^n)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_operator_with_blocking(t_n, std::span{u_old_}, workspace_->lu());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // RHS = u^n + w1L(u^n)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA for SAXPY-style loop
  161,140,000 (0.2%)    45 (0.0%) 1 (0.0%)     1,684,000 (0.0%)         0          0                  0                0         0         53,152,000 (0.4%) 3,368,017 (2.4%)  0   0          for (size_t i = 0; i < n_; ++i) {
  151,036,000 (0.1%)     9 (0.0%) 1 (0.0%)   245,552,000 (0.7%)         0          0         49,784,000 (0.5%) 1,890,000 (2.5%)  0                  0                0         0   0              rhs_[i] = std::fma(w1, workspace_->lu()[i], u_old_[i]);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Initial guess: u* = u^n
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          std::copy(u_old_.begin(), u_old_.end(), u_current_.begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Solve implicit stage
   15,156,000 (0.0%)     0        0            5,052,000 (0.0%)         0          0          1,684,000 (0.0%)         0         0                  0                0         0   0          auto result = solve_implicit_stage(t_stage, w1,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{u_current_},
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{rhs_});
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    3,368,000 (0.0%)    39 (0.0%) 1 (0.0%)     1,684,000 (0.0%)         0          0                  0                0         0          1,684,000 (0.0%)         0         0   0          if (!result.converged) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              SolverError error{
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .code = SolverErrorCode::Stage1ConvergenceFailure,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .message = result.failure_reason.value_or("TR-BDF2 stage1 failed to converge"),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .iterations = result.iterations
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              };
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (error.message == "Singular Jacobian") {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  error.code = SolverErrorCode::LinearSolveFailure;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              return unexpected(error);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    5,052,000 (0.0%)     0        0                    0                0          0          3,368,000 (0.0%)    30,008 (0.0%)  0                  0                0         0   0          return {};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// TR-BDF2 Stage 2: BDF2
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Standard TR-BDF2 formulation (Ascher, Ruuth, Wetton 1995):
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// u^{n+1} - [(1-)dt/(2-)]L(u^{n+1}) = [1/((2-))]u^{n+} - [(1-)/((2-))]u^n
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solved via Newton-Raphson iteration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      expected<void, SolverError> solve_stage2([[maybe_unused]] double t_stage, double t_next, double dt) {
    1,684,000 (0.0%)     0        0            1,684,000 (0.0%)         0          0                  0                0         0                  0                0         0   0          const double gamma = config_.gamma;
    3,368,000 (0.0%)     8 (0.0%) 1 (0.0%)     1,684,000 (0.0%)         0          0                  0                0         0                  0                0         0   0          const double one_minus_gamma = 1.0 - gamma;
    3,368,000 (0.0%)     0        0            1,684,000 (0.0%)    30,000  (0.1%)  0                  0                0         0                  0                0         0   0          const double two_minus_gamma = 2.0 - gamma;
    1,684,000 (0.0%)    20 (0.0%) 1 (0.0%)             0                0          0                  0                0         0                  0                0         0   0          const double denom = gamma * two_minus_gamma;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Correct BDF2 coefficients (Ascher, Ruuth, Wetton 1995)
    1,684,000 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          const double alpha = 1.0 / denom;  // Coefficient for u^{n+}
    5,052,000 (0.0%)     0        0            1,684,000 (0.0%)         0          0                  0                0         0                  0                0         0   0          const double beta = -(one_minus_gamma * one_minus_gamma) / denom;  // Coefficient for u^n
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double w2 = config_.stage2_weight(dt);  // (1-)dt/(2-)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // RHS = alphau^{n+} + betau^n (u_current_ currently holds u^{n+})
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA: alpha*u_current[i] + beta*u_old[i]
  161,140,000 (0.2%)    26 (0.0%) 1 (0.0%)     1,684,000 (0.0%)         0          0                  0                0         0         53,152,000 (0.4%) 1,705,033 (1.2%)  0   0          for (size_t i = 0; i < n_; ++i) {
  149,352,000 (0.1%)    65 (0.1%) 1 (0.0%)   243,868,000 (0.7%) 1,860,060  (4.9%) 60 (0.3%)  49,784,000 (0.5%) 1,890,060 (2.5%) 60 (0.0%)           0                0         0   0              rhs_[i] = std::fma(alpha, u_current_[i], beta * u_old_[i]);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Initial guess: u^{n+1} = u* (already in u_current_)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // (No need to copy, u_current_ already has u^{n+})
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Solve implicit stage
   11,788,000 (0.0%)     0        0            1,684,000 (0.0%)         0          0          1,684,000 (0.0%)         0         0                  0                0         0   0          auto result = solve_implicit_stage(t_next, w2,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{u_current_},
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                            std::span{rhs_});
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    3,368,000 (0.0%)   282 (0.2%) 1 (0.0%)     1,684,000 (0.0%)         0          0                  0                0         0          1,684,000 (0.0%)         0         0   0          if (!result.converged) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              SolverError error{
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .code = SolverErrorCode::Stage2ConvergenceFailure,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .message = result.failure_reason.value_or("TR-BDF2 stage2 failed to converge"),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  .iterations = result.iterations
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              };
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (error.message == "Singular Jacobian") {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  error.code = SolverErrorCode::LinearSolveFailure;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              return unexpected(error);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
    5,052,000 (0.0%)     0        0                    0                0          0          3,368,000 (0.0%)    30,000 (0.0%)  0                  0                0         0   0          return {};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // ========================================================================
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // Newton-Raphson methods (for implicit stage solving)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // ========================================================================
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      //
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // NOTE: These methods are TR-BDF2-specific implementation details and NOT
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      // intended as a general-purpose Newton solver. They solve the specific form:
-- line 502 ----------------------------------------
-- line 518 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Solves: u = rhs + coeff_dtL(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// Equivalently: F(u) = u - rhs - coeff_dtL(u) = 0
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      ///
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param t Time at which to evaluate operators
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param coeff_dt TR-BDF2 weight (stage1_weight or stage2_weight)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param u Solution vector (input: initial guess, output: converged solution)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @param rhs Right-hand side from previous stage
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      /// @return Result with convergence status
   70,728,000 (0.1%) 1,576 (1.3%) 2 (0.0%)     6,736,000 (0.0%)         0          0         43,784,000 (0.4%)     2,593 (0.0%)  0                  0                0         0   0      RootFindingResult solve_implicit_stage(double t, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                             std::span<double> u,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                             std::span<const double> rhs) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double eps = root_config_.jacobian_fd_epsilon;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Apply BCs to initial guess
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          apply_boundary_conditions(u, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Quasi-Newton: Build Jacobian once and reuse
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          build_jacobian(t, coeff_dt, u, eps);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Copy initial guess
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          std::copy(u.begin(), u.end(), newton_ws_.u_old().begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Newton iteration
   19,996,256 (0.0%)     0        0           13,313,192 (0.0%)         0          0                  0                0         0          6,683,064 (0.0%)         4 (0.0%)  0   0          for (size_t iter = 0; iter < root_config_.max_iter; ++iter) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Evaluate L(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_operator_with_blocking(t, u, workspace_->lu());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Compute residual: F(u) = u - rhs - coeff_dtL(u)
   13,366,128 (0.0%)     0        0            6,683,064 (0.0%)         0          0          6,683,064 (0.1%)         0         0                  0                0         0   0              compute_residual(u, coeff_dt, workspace_->lu(), rhs,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                             newton_ws_.residual());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // CRITICAL FIX: Pass u explicitly to avoid reading stale workspace
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_bc_to_residual(newton_ws_.residual(), u, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Newton method: Solve Ju = -F(u), then update u  u + u
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Negate residual for RHS
  514,427,280 (0.5%)     9 (0.0%) 1 (0.0%)    13,366,128 (0.0%)         0          0                  0                0         0        217,115,256 (1.6%) 6,683,117 (4.7%)  0   0              for (size_t i = 0; i < n_; ++i) {
  591,198,192 (0.6%)     0        0          203,749,128 (0.6%)         0          0        197,066,064 (1.9%)         0         0                  0                0         0   0                  newton_ws_.residual()[i] = -newton_ws_.residual()[i];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Solve Ju = -F(u) using Thomas algorithm
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              auto result = solve_thomas<double>(
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.jacobian_lower(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.jacobian_diag(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.jacobian_upper(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  newton_ws_.residual(),
-- line 563 ----------------------------------------
-- line 566 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              );
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              if (!result.ok()) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                  return {false, iter, std::numeric_limits<double>::infinity(),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                         "Singular Jacobian", std::nullopt};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Update: u  u + u
  731,542,536 (0.7%)    14 (0.0%) 2 (0.0%)     6,683,064 (0.0%)         0          0                  0                0         0        230,481,384 (1.7%) 6,683,070 (4.7%)  0   0              for (size_t i = 0; i < n_; ++i) {
  591,198,192 (0.6%)     0        0          394,132,128 (1.1%)   119,064  (0.3%)  0        197,066,064 (1.9%)         0         0                  0                0         0   0                  u[i] += newton_ws_.delta_u()[i];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Apply obstacle projection BEFORE boundary conditions
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // This ensures complementarity: u  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_obstacle(t, u);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_boundary_conditions(u, t);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Check convergence via step delta
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double error = compute_step_delta_error(u, newton_ws_.u_old());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
   20,049,192 (0.0%)     0        0            6,683,064 (0.0%)   119,064  (0.3%)  0                  0                0         0          6,683,064 (0.0%) 3,499,066 (2.5%)  0   0              if (error < root_config_.tolerance) {
   40,416,000 (0.0%)    18 (0.0%) 2 (0.0%)     6,736,000 (0.0%)         4  (0.0%)  0         20,208,000 (0.2%)   120,008 (0.2%)  0                  0                0         0   0                  return {true, iter + 1, error, std::nullopt, std::nullopt};
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Prepare for next iteration
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              std::copy(u.begin(), u.end(), newton_ws_.u_old().begin());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          return {false, root_config_.max_iter,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                 compute_step_delta_error(u, newton_ws_.u_old()),
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                 "Max iterations reached", std::nullopt};
   37,048,000 (0.0%)     7 (0.0%) 1 (0.0%)    26,944,000 (0.1%)    60,008  (0.2%)  0                  0                0         0                  0                0         0   0      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void compute_residual(std::span<const double> u, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                           std::span<const double> Lu,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                           std::span<const double> rhs,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                           std::span<double> residual) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // F(u) = u - rhs - coeff_dtL(u) = 0
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // We want to solve u = rhs + coeff_dtL(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA: u[i] - rhs[i] - coeff_dt*Lu[i] = (u[i] - rhs[i]) + (-coeff_dt)*Lu[i]
  644,662,704 (0.6%)     9 (0.0%) 1 (0.0%)     6,683,064 (0.0%)         0          0                  0                0         0        210,432,192 (1.6%) 6,683,072 (4.7%)  0   0          for (size_t i = 0; i < n_; ++i) {
  794,947,320 (0.8%)    17 (0.0%) 2 (0.0%) 1,169,030,256 (3.4%) 3,751,032  (9.8%)  0        197,066,064 (1.9%) 5,846,356 (7.8%) 52 (0.0%)           0                0         0   0              residual[i] = std::fma(-coeff_dt, Lu[i], u[i] - rhs[i]);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      double compute_step_delta_error(std::span<const double> u_new,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                      std::span<const double> u_old) {
   20,049,192 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          double sum_sq_error = 0.0;
    6,683,064 (0.0%)    10 (0.0%) 1 (0.0%)             0                0          0                  0                0         0                  0                0         0   0          double sum_sq_norm = 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Use FMA for sum of squares: sum += x*x
2,324,694,384 (2.2%)     0        0                    0                0          0                  0                0         0        774,898,128 (5.8%) 6,683,080 (4.7%)  0   0          for (size_t i = 0; i < n_; ++i) {
1,536,430,128 (1.5%)     0        0        1,536,430,128 (4.4%) 7,382,034 (19.3%) 66 (0.4%)           0                0         0                  0                0         0   0              double diff = u_new[i] - u_old[i];
  768,215,064 (0.7%)     0        0                    0                0          0                  0                0         0                  0                0         0   0              sum_sq_error = std::fma(diff, diff, sum_sq_error);
  768,215,064 (0.7%)     0        0                    0                0          0                  0                0         0                  0                0         0   0              sum_sq_norm = std::fma(u_new[i], u_new[i], sum_sq_norm);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
   60,147,576 (0.1%) 1,504 (1.2%) 1 (0.0%)             0                0          0                  0                0         0         13,366,128 (0.1%)         0         0   0          double rms_error = std::sqrt(sum_sq_error / n_);
   13,366,128 (0.0%)     0        0                    0                0          0                  0                0         0                  0                0         0   0          double rms_norm = std::sqrt(sum_sq_norm / n_);
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          const double epsilon = 1e-12;
   33,415,320 (0.0%)    72 (0.1%) 1 (0.0%)     6,683,064 (0.0%)         0          0                  0                0         0          6,683,064 (0.0%)         0         0   0          return (rms_norm > epsilon) ? rms_error / (rms_norm + epsilon) : rms_error;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void apply_bc_to_residual(std::span<double> residual,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                std::span<const double> u,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                double t) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // For Dirichlet BC: F(u) = u - g, so residual = u - g
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Left boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryL>, bc::dirichlet_tag>) {
   13,366,128 (0.0%)     0        0            6,683,064 (0.0%)         0          0          6,683,064 (0.1%)         0         0                  0                0         0   0              double g = left_bc_.value(t, grid_[0]);
   20,049,192 (0.0%)     0        0            6,683,064 (0.0%)         0          0          6,683,064 (0.1%)         0         0                  0                0         0   0              residual[0] = u[0] - g;  // u - g (we want u = g, so F = u - g = 0)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Right boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryR>, bc::dirichlet_tag>) {
   26,732,256 (0.0%)     0        0           13,366,128 (0.0%)         0          0         13,366,128 (0.1%)         0         0                  0                0         0   0              double g = right_bc_.value(t, grid_[n_ - 1]);
   20,049,192 (0.0%)    36 (0.0%) 1 (0.0%)     6,683,064 (0.0%)         0          0          6,683,064 (0.1%)         0         0                  0                0         0   0              residual[n_ - 1] = u[n_ - 1] - g;  // u - g
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void build_jacobian(double t, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                         std::span<const double> u, double eps) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Dispatch to analytical or finite-difference Jacobian
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (HasAnalyticalJacobian<SpatialOp>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // Analytical Jacobian (O(n) - fast path)
-- line 649 ----------------------------------------
-- line 697 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .      void build_jacobian_boundaries(double t, double coeff_dt,
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .                                     std::span<const double> u, double eps) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Left boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryL>, bc::dirichlet_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Dirichlet: F(u) = u - g, so F/u = 1
    3,368,000 (0.0%)     0        0                    0                0          0          3,368,000 (0.0%)         0         0                  0                0         0   0              newton_ws_.jacobian_diag()[0] = 1.0;
    3,368,000 (0.0%)     0        0                    0                0          0          3,368,000 (0.0%)         0         0                  0                0         0   0              newton_ws_.jacobian_upper()[0] = 0.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          } else if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryL>, bc::neumann_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Neumann: F(u) = u - rhs - coeff_dtL(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[0] = u[0] + eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_operator_with_blocking(t, newton_ws_.u_perturb(), newton_ws_.Lu_perturb());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double dL0_du0 = (newton_ws_.Lu_perturb()[0] - workspace_->lu()[0]) / eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.jacobian_diag()[0] = 1.0 - coeff_dt * dL0_du0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[0] = u[0];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
-- line 714 ----------------------------------------
-- line 717 ----------------------------------------
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double dL0_du1 = (newton_ws_.Lu_perturb()[0] - workspace_->lu()[0]) / eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.jacobian_upper()[0] = -coeff_dt * dL0_du1;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[1] = u[1];
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          }
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .  
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          // Right boundary
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryR>, bc::dirichlet_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Dirichlet: F(u) = u - g, so F/u = 1
    3,368,000 (0.0%)     0        0                    0                0          0          3,368,000 (0.0%)         0         0                  0                0         0   0              newton_ws_.jacobian_diag()[n_ - 1] = 1.0;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .          } else if constexpr (std::is_same_v<bc::boundary_tag_t<BoundaryR>, bc::neumann_tag>) {
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              // For Neumann: F(u) = u - rhs - coeff_dtL(u)
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              size_t i = n_ - 1;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[i] = u[i] + eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              apply_operator_with_blocking(t, newton_ws_.u_perturb(), newton_ws_.Lu_perturb());
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              double dLi_dui = (newton_ws_.Lu_perturb()[i] - workspace_->lu()[i]) / eps;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.jacobian_diag()[i] = 1.0 - coeff_dt * dLi_dui;
            .            .        .                    .                .          .                  .                .         .                  .                .         .   .              newton_ws_.u_perturb()[i] = u[i];
-- line 733 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde/core/thomas_solver.hpp
--------------------------------------------------------------------------------
Ir__________________ I1mr_____ ILmr____ Dr__________________ D1mr_____________ DLmr Dw________________ D1mw____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 94 ----------------------------------------
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      std::span<T> workspace,
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      const ThomasConfig<T>& config = {}) noexcept
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      using Result = ThomasResult<T>;
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      const size_t n = diag.size();
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Validate dimensions
   20,049,192 (0.0%)  0        0            6,683,064 (0.0%)         0            0           0                0         0          6,683,064 (0.0%)         2 (0.0%)  0   0      if (lower.size() != n - 1) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::error_result("Lower diagonal size must be n-1");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
   13,366,128 (0.0%)  8 (0.0%) 1 (0.0%)     6,683,064 (0.0%)         0            0           0                0         0          6,683,064 (0.0%)         2 (0.0%)  0   0      if (upper.size() != n - 1) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::error_result("Upper diagonal size must be n-1");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
   13,366,128 (0.0%)  0        0            6,683,064 (0.0%)         0            0           0                0         0          6,683,064 (0.0%)         0         0   0      if (rhs.size() != n) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::error_result("RHS size must be n");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
   20,049,192 (0.0%)  0        0           13,366,128 (0.0%)         0            0           0                0         0          6,683,064 (0.0%)         0         0   0      if (solution.size() != n) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::error_result("Solution size must be n");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
   20,049,192 (0.0%)  0        0            6,683,064 (0.0%)         6  (0.0%)    0           0                0         0          6,683,064 (0.0%)         0         0   0      if (workspace.size() < 2 * n) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::error_result("Workspace size must be at least 2n");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Handle trivial cases
   13,366,128 (0.0%)  0        0                    0                0            0           0                0         0          6,683,064 (0.0%)         2 (0.0%)  0   0      if (n == 0) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::ok_result();
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
   13,366,128 (0.0%)  0        0                    0                0            0           0                0         0          6,683,064 (0.0%)       302 (0.0%)  0   0      if (n == 1) {
    6,683,064 (0.0%)  0        0            6,683,064 (0.0%)    59,064  (0.2%)    0           0                0         0                  0                0         0   0          if (std::abs(diag[0]) < config.singularity_tol) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .              return Result::error_result("Singular matrix (diagonal[0]  0)");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          solution[0] = rhs[0] / diag[0];
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::ok_result();
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Split workspace into c' and d' arrays
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      std::span<T> c_prime = workspace.subspan(0, n);
-- line 132 ----------------------------------------
-- line 143 ----------------------------------------
            .         .        .                    .                .            .           .                .         .                  .                .         .   .                  return Result::error_result("Matrix not diagonally dominant");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .              }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // ========== Forward Elimination ==========
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // First row
   20,049,192 (0.0%)  0        0            6,683,064 (0.0%)         6  (0.0%)    0           0                0         0          6,683,064 (0.0%)         0         0   0      if (std::abs(diag[0]) < config.singularity_tol) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          return Result::error_result("Singular matrix (diagonal[0]  0)");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
   20,049,192 (0.0%)  0        0            6,683,064 (0.0%)    59,064  (0.2%)    0   6,683,064 (0.1%)    60,000 (0.1%)  0                  0                0         0   0      c_prime[0] = upper[0] / diag[0];
   20,049,192 (0.0%)  0        0           13,366,128 (0.0%)         0            0   6,683,064 (0.1%)    60,004 (0.1%)  4 (0.0%)           0                0         0   0      d_prime[0] = rhs[0] / diag[0];
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Middle rows
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Note: Singularity checking prevents SIMD vectorization (early return)
2,284,596,000 (2.2%) 36 (0.0%) 1 (0.0%)             0                0            0           0                0         0        761,532,000 (5.7%) 6,683,077 (4.7%)  0   0      for (size_t i = 1; i < n - 1; ++i) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          // Use FMA for denominator calculation
2,264,546,808 (2.2%)  0        0        2,264,546,808 (6.5%) 7,624,872 (19.9%)    0           0                0         0                  0                0         0   0          const T denom = std::fma(-lower[i-1], c_prime[i-1], diag[i]);
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          // Singularity check
1,509,697,872 (1.4%)  0        0                    0                0            0           0                0         0        754,848,936 (5.6%)         0         0   0          if (std::abs(denom) < config.singularity_tol) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .              return Result::error_result("Singular or ill-conditioned matrix");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
1,509,697,872 (1.4%)  0        0          754,848,936 (2.2%)         0            0           0                0         0                  0                0         0   0          const T inv_denom = static_cast<T>(1) / denom;
1,509,697,872 (1.4%)  0        0          754,848,936 (2.2%) 3,841,968 (10.0%)    0 754,848,936 (7.3%) 7,085,762 (9.4%) 50 (0.0%)           0                0         0   0          c_prime[i] = upper[i] * inv_denom;
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          // Use FMA: (rhs[i] - lower[i-1]*d_prime[i-1]) * inv_denom
3,774,244,680 (3.6%) 10 (0.0%) 1 (0.0%) 2,264,546,808 (6.5%)         0            0 754,848,936 (7.3%) 7,145,760 (9.5%) 48 (0.0%)           0                0         0   0          d_prime[i] = std::fma(-lower[i-1], d_prime[i-1], rhs[i]) * inv_denom;
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Last row (no upper diagonal term)
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          const size_t i = n - 1;
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          // Use FMA for denominator calculation
   20,049,192 (0.0%)  0        0           20,049,192 (0.1%)         0            0           0                0         0                  0                0         0   0          const T denom = std::fma(-lower[i-1], c_prime[i-1], diag[i]);
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
   13,366,128 (0.0%)  0        0                    0                0            0           0                0         0          6,683,064 (0.0%)         0         0   0          if (std::abs(denom) < config.singularity_tol) {
            .         .        .                    .                .            .           .                .         .                  .                .         .   .              return Result::error_result("Singular matrix (at last row)");
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .          // Use FMA for numerator calculation
   26,732,256 (0.0%) 58 (0.0%) 1 (0.0%)    13,366,128 (0.0%)         0            0   6,683,064 (0.1%)         0         0                  0                0         0   0          d_prime[i] = std::fma(-lower[i-1], d_prime[i-1], rhs[i]) / denom;
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // ========== Back Substitution ==========
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
    6,683,064 (0.0%)  0        0                    0                0            0   6,683,064 (0.1%)         0         0                  0                0         0   0      solution[n-1] = d_prime[n-1];
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Reverse iteration (vectorization limited by data dependency)
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      // Use FMA for back substitution: d_prime[i-1] - c_prime[i-1]*solution[i]
  774,898,128 (0.7%)  0        0            6,683,064 (0.0%)         0            0           0                0         0        761,532,000 (5.7%) 6,683,192 (4.7%)  0   0      for (size_t i = n - 1; i > 0; --i) {
3,046,128,000 (2.9%)  0        0        1,523,064,000 (4.4%)         0            0 761,532,000 (7.4%) 7,382,022 (9.8%) 54 (0.0%)           0                0         0   0          solution[i-1] = std::fma(-c_prime[i-1], solution[i], d_prime[i-1]);
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .      return Result::ok_result();
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  }
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  /// Convenience wrapper with automatic workspace allocation
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  ///
            .         .        .                    .                .            .           .                .         .                  .                .         .   .  /// For performance-critical code, prefer the workspace version above
-- line 204 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde/operators/black_scholes_pde.hpp
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr____ Dr__________________ D1mr_____ DLmr Dw__________ D1mw DLmw Bc Bcm Bi Bim 

-- line 20 ----------------------------------------
          .            .        .                    .         .           .     .           .    .  .   .  .   .  public:
          .            .        .                    .         .           .     .           .    .  .   .  .   .      /**
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Construct Black-Scholes operator
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @param sigma Volatility ()
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @param r Risk-free rate
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @param d Continuous dividend yield
          .            .        .                    .         .           .     .           .    .  .   .  .   .       */
          .            .        .                    .         .           .     .           .    .  .   .  .   .      BlackScholesPDE(T sigma, T r, T d)
      3,200 (0.0%) 1,515 (1.2%) 1 (0.0%)         1,600 (0.0%) 10 (0.0%)    0     0           0    0  0   0  0   0          : half_sigma_sq_(T(0.5) * sigma * sigma)
      7,888 (0.0%)     3 (0.0%) 1 (0.0%)         1,600 (0.0%)  0           0 1,544 (0.0%)    0    0  0   0  0   0          , drift_(r - d - half_sigma_sq_)
          .            .        .                    .         .           .     .           .    .  .   .  .   .          , discount_rate_(r)
          .            .        .                    .         .           .     .           .    .  .   .  .   .      {}
          .            .        .                    .         .           .     .           .    .  .   .  .   .  
          .            .        .                    .         .           .     .           .    .  .   .  .   .      /**
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Apply operator: L(V) = (/2)V/x + (r-d-/2)V/x - rV
          .            .        .                    .         .           .     .           .    .  .   .  .   .       *
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @param d2v_dx2 Second derivative V/x
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @param dv_dx First derivative V/x
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @param v Value V
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * @return L(V)
          .            .        .                    .         .           .     .           .    .  .   .  .   .       */
          .            .        .                    .         .           .     .           .    .  .   .  .   .      T operator()(T d2v_dx2, T dv_dx, T v) const {
790,752,576 (0.8%)    18 (0.0%) 2 (0.0%) 2,188,182,320 (6.3%)  0           0     0           0    0  0   0  0   0          return half_sigma_sq_ * d2v_dx2 + drift_ * dv_dx - discount_rate_ * v;
          .            .        .                    .         .           .     .           .    .  .   .  .   .      }
          .            .        .                    .         .           .     .           .    .  .   .  .   .  
          .            .        .                    .         .           .     .           .    .  .   .  .   .      /**
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Compute first derivative coefficient: (r - d - /2)
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Used for finite difference Jacobian construction
          .            .        .                    .         .           .     .           .    .  .   .  .   .       */
  3,368,000 (0.0%)     0        0            3,368,000 (0.0%)  0           0     0           0    0  0   0  0   0      T first_derivative_coeff() const { return drift_; }
          .            .        .                    .         .           .     .           .    .  .   .  .   .  
          .            .        .                    .         .           .     .           .    .  .   .  .   .      /**
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Compute second derivative coefficient: /2
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Used for finite difference Jacobian construction
          .            .        .                    .         .           .     .           .    .  .   .  .   .       */
  3,368,000 (0.0%)     0        0            3,368,000 (0.0%)  0           0     0           0    0  0   0  0   0      T second_derivative_coeff() const { return half_sigma_sq_; }
          .            .        .                    .         .           .     .           .    .  .   .  .   .  
          .            .        .                    .         .           .     .           .    .  .   .  .   .      /**
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Compute discount rate: r
          .            .        .                    .         .           .     .           .    .  .   .  .   .       * Used for finite difference Jacobian construction
          .            .        .                    .         .           .     .           .    .  .   .  .   .       */
  3,368,000 (0.0%)    37 (0.0%) 1 (0.0%)     3,368,000 (0.0%)  0           0     0           0    0  0   0  0   0      T discount_rate() const { return discount_rate_; }
          .            .        .                    .         .           .     .           .    .  .   .  .   .  
          .            .        .                    .         .           .     .           .    .  .   .  .   .  private:
          .            .        .                    .         .           .     .           .    .  .   .  .   .      T half_sigma_sq_;    // /2
          .            .        .                    .         .           .     .           .    .  .   .  .   .      T drift_;            // r - d - /2
          .            .        .                    .         .           .     .           .    .  .   .  .   .      T discount_rate_;    // r
          .            .        .                    .         .           .     .           .    .  .   .  .   .  };
          .            .        .                    .         .           .     .           .    .  .   .  .   .  
          .            .        .                    .         .           .     .           .    .  .   .  .   .  } // namespace mango::operators
-- line 69 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde/operators/centered_difference_facade.hpp
--------------------------------------------------------------------------------
Ir_______________ I1mr________ ILmr____ Dr_______________ D1mr__________ DLmr Dw_______________ D1mw DLmw Bc__________ Bcm_________ Bi______________ Bim______ 

-- line 36 ----------------------------------------
         .            .        .                 .              .           .          .           .    .     .            .                .         .             CenteredDifference& operator=(CenteredDifference&&) = default;
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .             // Public API - virtual dispatch happens after IFUNC resolution
         .            .        .                 .              .           .          .           .    .     .            .                .         .             void compute_second_derivative(std::span<const T> u,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                            std::span<T> d2u_dx2,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                            size_t start, size_t end) const {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 assert(start >= 1 && "start must allow u[i-1] access");
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 assert(end <= u.size() - 1 && "end must allow u[i+1] access");
75,303,576 (0.1%)     0        0        25,101,192 (0.1%) 238,134 (0.6%)    0 16,734,128 (0.2%)    0    0     0            0        8,367,064 (0.5%) 10 (0.0%)          impl_->compute_second_derivative(u, d2u_dx2, start, end);
         .            .        .                 .              .           .          .           .    .     .            .                .         .             }
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .             void compute_first_derivative(std::span<const T> u,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                           std::span<T> du_dx,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                           size_t start, size_t end) const {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 assert(start >= 1 && "start must allow u[i-1] access");
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 assert(end <= u.size() - 1 && "end must allow u[i+1] access");
75,303,576 (0.1%)   118 (0.1%) 1 (0.0%) 25,101,192 (0.1%)       0           0 16,734,128 (0.2%)    0    0     0            0        8,367,064 (0.5%)  2 (0.0%)          impl_->compute_first_derivative(u, du_dx, start, end);
         .            .        .                 .              .           .          .           .    .     .            .                .         .             }
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .             void compute_second_derivative_tiled(std::span<const T> u,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                                  std::span<T> d2u_dx2,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                                  size_t start, size_t end) const {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 assert(start >= 1 && "start must allow u[i-1] access");
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 assert(end <= u.size() - 1 && "end must allow u[i+1] access");
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 impl_->compute_second_derivative_tiled(u, d2u_dx2, start, end);
-- line 60 ----------------------------------------
-- line 70 ----------------------------------------
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     std::span<const T> u, std::span<T> du_dx,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     size_t start, size_t end) const = 0;
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 virtual void compute_second_derivative_tiled(
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     std::span<const T> u, std::span<T> d2u_dx2,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     size_t start, size_t end) const = 0;
         .            .        .                 .              .           .          .           .    .     .            .                .         .             };
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .             template<typename Backend>
     3,200 (0.0%)    40 (0.0%) 1 (0.0%)          0              0           0          0           0    0     0            0                0         0             struct BackendImpl final : BackendInterface {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 Backend backend_;
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 explicit BackendImpl(const GridSpacing<T>& spacing)
     3,200 (0.0%)     0        0                 0              0           0      1,600 (0.0%)    0    0     0            0                0         0                     : backend_(spacing) {}
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 void compute_second_derivative(
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     std::span<const T> u, std::span<T> d2u_dx2,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     size_t start, size_t end) const override {
16,734,128 (0.0%)     9 (0.0%) 1 (0.0%)          0              0           0          0           0    0     0            0                0         0                     backend_.compute_second_derivative(u, d2u_dx2, start, end);
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 }
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 void compute_first_derivative(
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     std::span<const T> u, std::span<T> du_dx,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     size_t start, size_t end) const override {
16,734,128 (0.0%) 1,514 (1.2%) 0                 0              0           0          0           0    0     0            0                0         0                     backend_.compute_first_derivative(u, du_dx, start, end);
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 }
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 void compute_second_derivative_tiled(
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     std::span<const T> u, std::span<T> d2u_dx2,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     size_t start, size_t end) const override {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     backend_.compute_second_derivative_tiled(u, d2u_dx2, start, end);
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 }
         .            .        .                 .              .           .          .           .    .     .            .                .         .             };
-- line 101 ----------------------------------------
-- line 105 ----------------------------------------
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .         // Constructor implementation
         .            .        .                 .              .           .          .           .    .     .            .                .         .         template<std::floating_point T>
         .            .        .                 .              .           .          .           .    .     .            .                .         .         inline CenteredDifference<T>::CenteredDifference(const GridSpacing<T>& spacing,
         .            .        .                 .              .           .          .           .    .     .            .                .         .                                                           Mode mode)
         .            .        .                 .              .           .          .           .    .     .            .                .         .         {
         .            .        .                 .              .           .          .           .    .     .            .                .         .             if (mode == Mode::Auto) {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 // Check CPU features AND OS support
       224 (0.0%)     0        0                 0              0           0         56 (0.0%)    0    0     0            0                0         0                 auto features = cpu::detect_cpu_features();
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 bool os_supports_avx = cpu::check_os_avx_support();
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 // Use SIMD if both CPU and OS support it
    11,200 (0.0%)    69 (0.1%) 3 (0.1%)          0              0           0          0           0    0 3,200 (0.0%) 1,543 (0.0%)         0         0                 if ((features.has_avx2 || features.has_avx512f) && os_supports_avx) {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     mode = Mode::Simd;
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 } else {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                     mode = Mode::Scalar;
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 }
         .            .        .                 .              .           .          .           .    .     .            .                .         .             }
         .            .        .                 .              .           .          .           .    .     .            .                .         .         
         .            .        .                 .              .           .          .           .    .     .            .                .         .             switch (mode) {
         .            .        .                 .              .           .          .           .    .     .            .                .         .                 case Mode::Scalar:
-- line 125 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde/operators/centered_difference_simd_backend.hpp
--------------------------------------------------------------------------------
Ir________________ I1mr______ ILmr____ Dr_______________ D1mr_________ DLmr Dw_______________ D1mw DLmw Bc________________ Bcm_____________ Bi Bim 

-- line 50 ----------------------------------------
          .          .        .                 .             .           .          .           .    .           .                .         .   .  template<std::floating_point T = double>
          .          .        .                 .             .           .          .           .    .           .                .         .   .  class SimdBackend {
          .          .        .                 .             .           .          .           .    .           .                .         .   .  public:
          .          .        .                 .             .           .          .           .    .           .                .         .   .      using simd_t = stdx::native_simd<T>;
          .          .        .                 .             .           .          .           .    .           .                .         .   .      static constexpr size_t simd_width = simd_t::size();
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      explicit SimdBackend(const GridSpacing<T>& spacing,
          .          .        .                 .             .           .          .           .    .           .                .         .   .                          size_t l1_tile_size = 1024)
      4,800 (0.0%) 278 (0.2%) 1 (0.0%)      1,600 (0.0%)      0           0      1,600 (0.0%)    0    0           0                0         0   0          : spacing_(spacing)
      1,600 (0.0%)   0        0                 0             0           0      1,600 (0.0%)    0    0           0                0         0   0          , l1_tile_size_(l1_tile_size)
          .          .        .                 .             .           .          .           .    .           .                .         .   .      {}
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      /**
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Vectorized second derivative kernel (uniform grid)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Marked with target_clones for ISA-specific code generation:
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * - default: SSE2 baseline (simd_width = 2 for double)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * - avx2: Haswell+ (simd_width = 4 for double)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * - avx512f: Skylake-X+ (simd_width = 8 for double)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Verify with: objdump -d <binary> | grep -A20 compute_second_derivative_uniform
          .          .        .                 .             .           .          .           .    .           .                .         .   .       */
          .          .        .                 .             .           .          .           .    .           .                .         .   .      [[gnu::target_clones("default","avx2","avx512f")]]
 33,468,256 (0.0%)  10 (0.0%) 1 (0.0%)  8,367,064 (0.0%)      0           0  8,367,064 (0.1%)    0    0           0                0         0   0      void compute_second_derivative_uniform(
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<const T> u,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<T> d2u_dx2,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t start,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t end) const
          .          .        .                 .             .           .          .           .    .           .                .         .   .      {
          .          .        .                 .             .           .          .           .    .           .                .         .   .          assert(start >= 1 && "start must allow u[i-1] access");
          .          .        .                 .             .           .          .           .    .           .                .         .   .          assert(end <= u.size() - 1 && "end must allow u[i+1] access");
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .          const T dx2_inv = spacing_.spacing_inv_sq();
          .          .        .                 .             .           .          .           .    .           .                .         .   .          const simd_t dx2_inv_vec(dx2_inv);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          const simd_t minus_two(T(-2));
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .          // Vectorized main loop
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t i = start;
748,917,256 (0.7%)   0        0         8,367,064 (0.0%)      0           0          0           0    0 238,483,000 (1.8%) 8,367,080 (5.9%)  0   0          for (; i + simd_width <= end; i += simd_width) {
          .          .        .                 .             .           .          .           .    .           .                .         .   .              // SoA layout ensures contiguous loads (no gather needed)
          .          .        .                 .             .           .          .           .    .           .                .         .   .              simd_t u_left, u_center, u_right;
          .          .        .                 .             .           .          .           .    .           .                .         .   .              u_left.copy_from(u.data() + i - 1, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .              u_center.copy_from(u.data() + i, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .              u_right.copy_from(u.data() + i + 1, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .              // d2u/dx2 = (u[i+1] + u[i-1] - 2*u[i]) * dx2_inv
          .          .        .                 .             .           .          .           .    .           .                .         .   .              const simd_t sum = u_left + u_right;
          .          .        .                 .             .           .          .           .    .           .                .         .   .              const simd_t result = stdx::fma(sum, dx2_inv_vec,
          .          .        .                 .             .           .          .           .    .           .                .         .   .                                             minus_two * u_center * dx2_inv_vec);
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .              result.copy_to(d2u_dx2.data() + i, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .          // Scalar tail (zero-padded arrays allow safe i+1 access)
125,505,960 (0.1%)  37 (0.0%) 1 (0.0%)          0             0           0          0           0    0  33,468,256 (0.2%)         3 (0.0%)  0   0          for (; i < end; ++i) {
133,873,024 (0.1%)   7 (0.0%) 1 (0.0%) 66,936,512 (0.2%)      0           0 16,734,128 (0.2%)    0    0           0                0         0   0              d2u_dx2[i] = std::fma(u[i+1] + u[i-1], dx2_inv, T(-2) * u[i] * dx2_inv);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
 16,734,128 (0.0%)   0        0        16,734,128 (0.0%)      0           0          0           0    0           0                0         0   0      }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      /**
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Tiled second derivative (cache-friendly)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Operator decides tile size based on stencil width and cache target.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Automatically dispatches to uniform or non-uniform implementation.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       */
          .          .        .                 .             .           .          .           .    .           .                .         .   .      [[gnu::target_clones("default","avx2","avx512f")]]
-- line 115 ----------------------------------------
-- line 131 ----------------------------------------
          .          .        .                 .             .           .          .           .    .           .                .         .   .              }
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
          .          .        .                 .             .           .          .           .    .           .                .         .   .      }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      /**
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * First derivative (vectorized, uniform grid)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       */
          .          .        .                 .             .           .          .           .    .           .                .         .   .      [[gnu::target_clones("default","avx2","avx512f")]]
 33,468,256 (0.0%)   9 (0.0%) 1 (0.0%)  8,367,064 (0.0%)      0           0  8,367,064 (0.1%)    0    0           0                0         0   0      void compute_first_derivative_uniform(
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<const T> u,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<T> du_dx,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t start,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t end) const
          .          .        .                 .             .           .          .           .    .           .                .         .   .      {
          .          .        .                 .             .           .          .           .    .           .                .         .   .          assert(start >= 1 && "start must allow u[i-1] access");
          .          .        .                 .             .           .          .           .    .           .                .         .   .          assert(end <= u.size() - 1 && "end must allow u[i+1] access");
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
 16,734,128 (0.0%)   0        0        16,734,128 (0.0%) 59,064 (0.2%)    0          0           0    0           0                0         0   0          const T half_dx_inv = spacing_.spacing_inv() * T(0.5);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          const simd_t half_dx_inv_vec(half_dx_inv);
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t i = start;
748,917,256 (0.7%)   0        0                 0             0           0          0           0    0 238,483,000 (1.8%) 8,367,080 (5.9%)  0   0          for (; i + simd_width <= end; i += simd_width) {
          .          .        .                 .             .           .          .           .    .           .                .         .   .              simd_t u_left, u_right;
          .          .        .                 .             .           .          .           .    .           .                .         .   .              u_left.copy_from(u.data() + i - 1, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .              u_right.copy_from(u.data() + i + 1, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .              const simd_t result = (u_right - u_left) * half_dx_inv_vec;
          .          .        .                 .             .           .          .           .    .           .                .         .   .              result.copy_to(du_dx.data() + i, stdx::element_aligned);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
142,240,088 (0.1%)  56 (0.0%) 1 (0.0%)          0             0           0          0           0    0  33,468,256 (0.2%)         0         0   0          for (; i < end; ++i) {
 75,303,576 (0.1%)  60 (0.0%) 1 (0.0%) 33,468,256 (0.1%)      0           0 16,734,128 (0.2%)    0    0           0                0         0   0              du_dx[i] = (u[i+1] - u[i-1]) * half_dx_inv;
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
 16,734,128 (0.0%)   0        0        16,734,128 (0.0%)      0           0          0           0    0           0                0         0   0      }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      /**
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Second derivative (vectorized, non-uniform grid)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Uses precomputed spacing arrays from GridSpacing to avoid divisions.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * SIMD kernel loads dx_left_inv, dx_right_inv, dx_center_inv for each point.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Scalar tail uses same precomputed arrays for exact numerical match.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       */
-- line 172 ----------------------------------------
-- line 294 ----------------------------------------
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * via [[gnu::target_clones]].
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Use this for tests, examples, or when grid type is runtime-determined.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * For performance-critical paths with known grid type at compile time,
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * prefer explicit compute_second_derivative_uniform() or
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * compute_second_derivative_non_uniform() to avoid branch overhead.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       */
          .          .        .                 .             .           .          .           .    .           .                .         .   .      [[gnu::target_clones("default","avx2","avx512f")]]
 25,101,192 (0.0%)   0        0         8,367,064 (0.0%)      0           0  8,367,064 (0.1%)    0    0           0                0         0   0      void compute_second_derivative(
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<const T> u,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<T> d2u_dx2,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t start,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t end) const
          .          .        .                 .             .           .          .           .    .           .                .         .   .      {
 16,734,128 (0.0%)   0        0         8,367,064 (0.0%) 89,064 (0.2%)    0          0           0    0   8,367,064 (0.1%)         0         0   0          if (spacing_.is_uniform()) {
 16,734,128 (0.0%)   0        0                 0             0           0  8,367,064 (0.1%)    0    0           0                0         0   0              compute_second_derivative_uniform(u, d2u_dx2, start, end);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          } else {
          .          .        .                 .             .           .          .           .    .           .                .         .   .              compute_second_derivative_non_uniform(u, d2u_dx2, start, end);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
  8,367,064 (0.0%)   0        0         8,367,064 (0.0%)      0           0          0           0    0           0                0         0   0      }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      /**
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Convenience wrapper for first derivative (automatic dispatch)
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Automatically dispatches to uniform or non-uniform implementation
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * based on grid type. Both variants get ISA-specific code generation
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * via [[gnu::target_clones]].
          .          .        .                 .             .           .          .           .    .           .                .         .   .       *
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * Use this for tests, examples, or when grid type is runtime-determined.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * For performance-critical paths with known grid type at compile time,
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * prefer explicit compute_first_derivative_uniform() or
          .          .        .                 .             .           .          .           .    .           .                .         .   .       * compute_first_derivative_non_uniform() to avoid branch overhead.
          .          .        .                 .             .           .          .           .    .           .                .         .   .       */
          .          .        .                 .             .           .          .           .    .           .                .         .   .      [[gnu::target_clones("default","avx2","avx512f")]]
 25,101,192 (0.0%)   0        0         8,367,064 (0.0%)      0           0  8,367,064 (0.1%)    0    0           0                0         0   0      void compute_first_derivative(
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<const T> u,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          std::span<T> du_dx,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t start,
          .          .        .                 .             .           .          .           .    .           .                .         .   .          size_t end) const
          .          .        .                 .             .           .          .           .    .           .                .         .   .      {
 16,734,128 (0.0%)   0        0         8,367,064 (0.0%)      0           0          0           0    0   8,367,064 (0.1%)         2 (0.0%)  0   0          if (spacing_.is_uniform()) {
 16,734,128 (0.0%)   0        0                 0             0           0  8,367,064 (0.1%)    0    0           0                0         0   0              compute_first_derivative_uniform(u, du_dx, start, end);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          } else {
          .          .        .                 .             .           .          .           .    .           .                .         .   .              compute_first_derivative_non_uniform(u, du_dx, start, end);
          .          .        .                 .             .           .          .           .    .           .                .         .   .          }
  8,367,064 (0.0%)   0        0         8,367,064 (0.0%)      0           0          0           0    0           0                0         0   0      }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .      size_t tile_size() const { return l1_tile_size_; }
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
          .          .        .                 .             .           .          .           .    .           .                .         .   .  private:
          .          .        .                 .             .           .          .           .    .           .                .         .   .      const GridSpacing<T>& spacing_;
          .          .        .                 .             .           .          .           .    .           .                .         .   .      size_t l1_tile_size_;
          .          .        .                 .             .           .          .           .    .           .                .         .   .  };
          .          .        .                 .             .           .          .           .    .           .                .         .   .  
-- line 347 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/./src/pde/operators/spatial_operator.hpp
--------------------------------------------------------------------------------
Ir________________ I1mr______ ILmr____ Dr_______________ D1mr__________ DLmr____ Dw________________ D1mw_____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 41 ----------------------------------------
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  /// SpatialOperator: Composes PDE, GridSpacing, and CenteredDifference
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  ///
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  /// Note: Uses std::fma in Jacobian assembly for improved precision and performance.
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  /// Therefore T must be a standard floating-point type (float, double, long double).
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  template<typename PDE, std::floating_point T = double>
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  class SpatialOperator {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  public:
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      SpatialOperator(PDE pde, std::shared_ptr<GridSpacing<T>> spacing)
      6,176 (0.0%)  36 (0.0%) 1 (0.0%)      3,088 (0.0%)      21 (0.0%) 0              3,088 (0.0%)         0          0                  0                0         0   0          : pde_(std::move(pde))
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          , spacing_(std::move(spacing))
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          , stencil_(std::make_shared<CenteredDifference<T>>(*spacing_))
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      {}
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      // Default copy/move (shared_ptr makes it copyable)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      SpatialOperator(const SpatialOperator&) = default;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      SpatialOperator& operator=(const SpatialOperator&) = default;
      6,400 (0.0%)   0        0             3,200 (0.0%)       0        0              3,200 (0.0%)       672  (0.0%) 31 (0.0%)           0                0         0   0      SpatialOperator(SpatialOperator&&) = default;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      SpatialOperator& operator=(SpatialOperator&&) = default;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      /// Get interior range for this stencil (3-point: [1, n-1))
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      /// Precondition: n >= GridSpacing<T>::min_stencil_size() (i.e., n >= 3)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      StencilInterior interior_range(size_t n) const {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          assert(n >= GridSpacing<T>::min_stencil_size() && "Grid too small for stencil");
 16,840,000 (0.0%)   0        0         3,368,000 (0.0%)       0        0          5,052,000 (0.0%)         0          0                  0                0         0   0          return {1, n - 1};  // 3-point stencil width
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      /// Apply operator to full grid (convenience)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      void apply(double t, std::span<const T> u, std::span<T> Lu) const {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const auto range = interior_range(u.size());
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          apply_interior(t, u, Lu, range.start, range.end);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
-- line 72 ----------------------------------------
-- line 73 ----------------------------------------
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      /// Apply operator to interior points only [start, end)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      /// Used by both full-grid and cache-blocked evaluation
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      void apply_interior(double t,
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                         std::span<const T> u,
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                         std::span<T> Lu,
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                         size_t start,
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                         size_t end) const {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // Temporary buffers for derivatives
 16,734,512 (0.0%)  69 (0.1%) 3 (0.1%)  8,367,128 (0.0%) 119,802 (0.3%) 0                 96 (0.0%)         0          0          8,367,064 (0.1%) 3,368,031 (2.4%)  0   0          thread_local std::vector<T> d2u_dx2_buf;
 16,734,160 (0.0%)   0        0         8,367,064 (0.0%)       0        0                 32 (0.0%)         0          0          8,367,064 (0.1%)         0         0   0          thread_local std::vector<T> du_dx_buf;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const size_t n = u.size();
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          d2u_dx2_buf.resize(n);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          du_dx_buf.resize(n);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // Zero only the active range to avoid stale values (optimization)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          std::fill(d2u_dx2_buf.begin() + start, d2u_dx2_buf.begin() + end, T(0));
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          std::fill(du_dx_buf.begin() + start, du_dx_buf.begin() + end, T(0));
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // Compute derivatives using facade
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          stencil_->compute_second_derivative(u, std::span<T>(d2u_dx2_buf), start, end);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          stencil_->compute_first_derivative(u, std::span<T>(du_dx_buf), start, end);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // Apply PDE operator to combine derivatives
856,005,088 (0.8%)  54 (0.0%) 5 (0.1%) 31,784,256 (0.1%)       0        0                  0                0          0        263,584,192 (2.0%) 8,367,088 (5.9%)  0   0          for (size_t i = start; i < end; ++i) {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              if constexpr (TimeDependentPDE<PDE>) {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  Lu[i] = pde_(t, d2u_dx2_buf[i], du_dx_buf[i], u[i]);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              } else {
246,850,064 (0.2%)   9 (0.0%) 1 (0.0%)          0              0        0        246,850,064 (2.4%) 7,501,090 (10.0%) 57 (0.0%)           0                0         0   0                  Lu[i] = pde_(d2u_dx2_buf[i], du_dx_buf[i], u[i]);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      /// Greeks computation (delegates to stencil)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      void compute_first_derivative(std::span<const T> u,
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                                   std::span<T> du_dx) const {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const auto range = interior_range(u.size());
-- line 109 ----------------------------------------
-- line 131 ----------------------------------------
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // Get PDE coefficients
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const T a = pde_.second_derivative_coeff();  // /2
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const T b = pde_.first_derivative_coeff();   // r - d - /2
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const T c = -pde_.discount_rate();           // -r
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          const size_t n = jac.size();
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
  6,736,000 (0.0%)   0        0         3,368,000 (0.0%)  30,004 (0.1%) 4 (0.0%)           0                0          0          3,368,000 (0.0%)         1 (0.0%)  0   0          if (spacing_->is_uniform()) {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // Uniform grid: constant coefficients (O(1) compute + O(n) fill)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              const T dx = spacing_->spacing();
  3,368,000 (0.0%)  24 (0.0%) 1 (0.0%)          0              0        0                  0                0          0                  0                0         0   0              const T dx_sq = dx * dx;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // Jacobian of L(u): L/u
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // Use FMA for coefficient computations
 23,576,000 (0.0%) 137 (0.1%) 1 (0.0%)  6,736,000 (0.0%)       0        0                  0                0          0                  0                0         0   0              const T jac_lower_coeff = std::fma(a, T(1) / dx_sq, -b / (T(2) * dx));
  6,736,000 (0.0%)   0        0         3,368,000 (0.0%)       0        0                  0                0          0                  0                0         0   0              const T jac_diag_coeff = std::fma(T(-2) * a, T(1) / dx_sq, c);
  3,368,000 (0.0%)   0        0                 0              0        0                  0                0          0                  0                0         0   0              const T jac_upper_coeff = std::fma(a, T(1) / dx_sq, b / (T(2) * dx));
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // F(u) = u - rhs - coeff_dtL(u)
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // F/u = I - coeff_dtL/u
 10,104,000 (0.0%)   0        0         6,736,000 (0.0%)       0        0                  0                0          0                  0                0         0   0              const T lower = -coeff_dt * jac_lower_coeff;
  6,736,000 (0.0%)   0        0                 0              0        0                  0                0          0                  0                0         0   0              const T diag = 1.0 - coeff_dt * jac_diag_coeff;
  3,368,000 (0.0%)   7 (0.0%) 1 (0.0%)          0              0        0                  0                0          0                  0                0         0   0              const T upper = -coeff_dt * jac_upper_coeff;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // Fill interior points
443,528,000 (0.4%)  45 (0.0%) 4 (0.1%)          0              0        0          3,368,000 (0.0%)         0          0        119,776,000 (0.9%) 3,368,011 (2.4%)  0   0              for (size_t i = 1; i < n - 1; ++i) {
102,936,000 (0.1%)   0        0                 0              0        0         99,568,000 (1.0%) 3,660,062  (4.9%) 62 (0.0%)           0                0         0   0                  jac.lower()[i - 1] = lower;
102,936,000 (0.1%)   0        0                 0              0        0         99,568,000 (1.0%) 3,720,050  (5.0%) 50 (0.0%)           0                0         0   0                  jac.diag()[i] = diag;
102,936,000 (0.1%)   0        0                 0              0        0         99,568,000 (1.0%) 3,780,052  (5.0%) 52 (0.0%)           0                0         0   0                  jac.upper()[i] = upper;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          } else {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              // Non-uniform grid: per-point coefficients (O(n))
  3,368,000 (0.0%)   0        0                 0              0        0                  0                0          0                  0                0         0   0              for (size_t i = 1; i < n - 1; ++i) {
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  // Get local grid spacing
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T dx_left = spacing_->left_spacing(i);    // x[i] - x[i-1]
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T dx_right = spacing_->right_spacing(i);  // x[i+1] - x[i]
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T dx_avg = (dx_left + dx_right) / 2.0;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  // Second derivative: (u[i-1]/dx_left - u[i]*(1/dx_left + 1/dx_right) + u[i+1]/dx_right) / dx_avg
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T d2_coeff_im1 = a / (dx_left * dx_avg);
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T d2_coeff_i = -a * (1.0 / dx_left + 1.0 / dx_right) / dx_avg;
-- line 172 ----------------------------------------
-- line 178 ----------------------------------------
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T d1_coeff_ip1 = b / d1_denom;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  // Jacobian of L(u): L_i/u
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T jac_lower_i = d2_coeff_im1 + d1_coeff_im1;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T jac_diag_i = d2_coeff_i + c;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  const T jac_upper_i = d2_coeff_ip1 + d1_coeff_ip1;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  // F(u) = u - rhs - coeff_dtL(u), so F/u = I - coeff_dtL/u
227,224,176 (0.2%) 290 (0.2%) 2 (0.0%) 20,049,192 (0.1%)       0        0          6,683,064 (0.1%)         0          0         26,732,256 (0.2%)         4 (0.0%)  0   0                  jac.lower()[i - 1] = -coeff_dt * jac_lower_i;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  jac.diag()[i] = 1.0 - coeff_dt * jac_diag_i;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .                  jac.upper()[i] = -coeff_dt * jac_upper_i;
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .              }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          }
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .  
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // Note: Boundary rows (i=0, i=n-1) are NOT filled here.
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .          // They must be handled separately based on boundary condition types.
          .          .        .                 .              .        .                  .                .          .                  .                .         .   .      }
-- line 194 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /proc/self/cwd/src/option/american_option.cpp
--------------------------------------------------------------------------------
Ir__________________ I1mr________ ILmr____ Dr__________________ D1mr_____________ DLmr_____ Dw___________________ D1mw____________ DLmw_____ Bc________________ Bcm_____________ Bi Bim 

-- line 28 ----------------------------------------
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  /**
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   * American put option obstacle in log-moneyness coordinates.
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   *
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   * Intrinsic value: (x) = max(1 - exp(x), 0)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   * where x = ln(S/K).
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   */
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  class AmericanPutObstacle {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  public:
   73,531,304 (0.1%)     0        0                    0                0          0           33,423,320  (0.3%)   119,064 (0.2%)  0                  0                0         0   0      void operator()(double, std::span<const double> x,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                      std::span<double> psi) const {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          #pragma omp simd
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          for (size_t i = 0; i < x.size(); ++i) {
8,452,235,704 (8.0%)    57 (0.0%) 1 (0.0%) 1,536,770,128 (4.4%) 7,382,022 (19.3%) 52 (0.3%) 1,536,770,128 (14.9%) 7,442,390 (9.9%) 40 (0.0%) 768,385,064 (5.7%) 6,684,674 (4.7%)  0   0              psi[i] = std::max(1.0 - std::exp(x[i]), 0.0);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
   40,107,984 (0.0%)     0        0           40,107,984 (0.1%)         0          0                    0                 0         0                  0                0         0   0      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  };
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  /**
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   * American call option obstacle in log-moneyness coordinates.
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   *
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   * Intrinsic value: (x) = max(exp(x) - 1, 0)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   * where x = ln(S/K).
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .   */
-- line 50 ----------------------------------------
-- line 109 ----------------------------------------
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          double dx = x[j] - x[i];
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          double weight = (x_target - x[i]) / dx;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          return (1.0 - weight) * u[i] + weight * u[j];
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  };
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  }  // anonymous namespace
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
       21,616 (0.0%)    57 (0.0%) 1 (0.0%)             0                0          0                9,264  (0.0%)       671 (0.0%)  0                  0                0         0   0  AmericanOptionSolver::AmericanOptionSolver(
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const AmericanOptionParams& params,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const AmericanOptionGrid& grid,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const TRBDF2Config& trbdf2_config,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const RootFindingConfig& root_config)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      : params_(params)
        3,088 (0.0%)     0        0                1,544 (0.0%)         0          0                1,544  (0.0%)       650 (0.0%)  0                  0                0         0   0      , grid_(grid)
        3,088 (0.0%)     0        0                1,544 (0.0%)         0          0                1,544  (0.0%)         0         0                  0                0         0   0      , trbdf2_config_(trbdf2_config)
        3,088 (0.0%)     0        0                1,544 (0.0%)         0          0                1,544  (0.0%)         0         0                  0                0         0   0      , root_config_(root_config)
        1,544 (0.0%)     0        0                    0                0          0                1,544  (0.0%)       669 (0.0%) 31 (0.0%)           0                0         0   0      , workspace_(nullptr)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Validate parameters (includes discrete dividend validation)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      params_.validate();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      grid_.validate();
       12,352 (0.0%)     0        0               10,808 (0.0%)         0          0                    0                 0         0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
        1,064 (0.0%)     8 (0.0%) 2 (0.0%)           112 (0.0%)         0          0                  504  (0.0%)         0         0                  0                0         0   0  AmericanOptionSolver::AmericanOptionSolver(
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const AmericanOptionParams& params,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const AmericanOptionGrid& grid,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      std::shared_ptr<SliceSolverWorkspace> workspace,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const TRBDF2Config& trbdf2_config,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const RootFindingConfig& root_config)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      : params_(params)
          112 (0.0%)     5 (0.0%) 1 (0.0%)            56 (0.0%)         0          0                   56  (0.0%)         0         0                  0                0         0   0      , grid_(grid)
          112 (0.0%)     0        0                   56 (0.0%)         0          0                   56  (0.0%)         0         0                  0                0         0   0      , trbdf2_config_(trbdf2_config)
          112 (0.0%)     0        0                   56 (0.0%)         0          0                   56  (0.0%)         0         0                  0                0         0   0      , root_config_(root_config)
           56 (0.0%)     0        0                    0                0          0                   56  (0.0%)         0         0                  0                0         0   0      , workspace_(std::move(workspace))
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Validate parameters
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      params_.validate();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      grid_.validate();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Validate workspace is not null
          112 (0.0%)     4 (0.0%) 1 (0.0%)             0                0          0                    0                 0         0                 56 (0.0%)         0         0   0      if (!workspace_) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          throw std::invalid_argument("Workspace cannot be null");
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Validate grid matches workspace
          616 (0.0%)     0        0                  112 (0.0%)         0          0                    0                 0         0                112 (0.0%)         0         0   0      if (grid_.x_min != workspace_->x_min() || grid_.x_max != workspace_->x_max() ||
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          grid_.n_space != workspace_->n_space()) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          throw std::invalid_argument(
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              "Grid parameters must match workspace "
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              "(x_min=" + std::to_string(workspace_->x_min()) +
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              ", x_max=" + std::to_string(workspace_->x_max()) +
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              ", n_space=" + std::to_string(workspace_->n_space()) + ")");
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
          784 (0.0%)     0        0                  560 (0.0%)         0          0                    0                 0         0                 56 (0.0%)         0         0   0  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  // ============================================================================
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  // Factory methods with expected-based validation
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  // ============================================================================
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  expected<AmericanOptionSolver, std::string> AmericanOptionSolver::create(
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const AmericanOptionParams& params,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const AmericanOptionGrid& grid,
-- line 171 ----------------------------------------
-- line 231 ----------------------------------------
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          return unexpected(std::string("Failed to create solver: ") + e.what());
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  // ============================================================================
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  // Public API
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  // ============================================================================
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
       25,600 (0.0%)    15 (0.0%) 2 (0.0%)         3,200 (0.0%)       670  (0.0%)  0               16,000  (0.0%)     1,344 (0.0%) 31 (0.0%)           0                0         0   0  expected<AmericanOptionResult, SolverError> AmericanOptionSolver::solve() {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 1. Acquire grid (reuse workspace grid if available)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      std::optional<GridBuffer<double>> owned_grid_buffer;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      std::span<const double> x_grid;
        1,544 (0.0%)     0        0                    0                0          0                1,544  (0.0%)         0         0                  0                0         0   0      std::shared_ptr<operators::GridSpacing<double>> shared_spacing;
        1,544 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      PDEWorkspace* external_workspace = nullptr;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
        3,200 (0.0%)     0        0                    0                0          0                    0                 0         0              1,600 (0.0%)         2 (0.0%)  0   0      if (workspace_) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          x_grid = workspace_->grid_span();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          shared_spacing = workspace_->grid_spacing();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          external_workspace = workspace_->workspace().get();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      } else {
        3,088 (0.0%)    52 (0.0%) 1 (0.0%)         3,088 (0.0%)         0          0                    0                 0         0                  0                0         0   0          auto grid_result = GridSpec<>::uniform(grid_.x_min, grid_.x_max, grid_.n_space);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          if (!grid_result.has_value()) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              return unexpected(SolverError{
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                  .code = SolverErrorCode::InvalidConfiguration,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                  .message = "Failed to create uniform grid: " + grid_result.error()
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              });
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
        6,176 (0.0%) 1,472 (1.2%) 1 (0.0%)         1,544 (0.0%)         0          0                1,544  (0.0%)       671 (0.0%)  0                  0                0         0   0          owned_grid_buffer.emplace(grid_result.value().generate());
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          x_grid = owned_grid_buffer->span();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 2. Setup time domain
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // For option pricing: solve forward in PDE time (backward in calendar time)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // t=0: terminal payoff at maturity
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // t=T: present value
       16,000 (0.0%)    27 (0.0%) 3 (0.1%)         4,800 (0.0%)        34  (0.0%)  0                3,200  (0.0%)        17 (0.0%)  0              1,600 (0.0%)        55 (0.0%)  0   0      TimeDomain time_domain(0.0, params_.maturity, params_.maturity / grid_.n_time);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 3. Create Black-Scholes operator in log-moneyness coordinates
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      auto make_operator = [&]() {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          auto pde = operators::BlackScholesPDE<double>(
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              params_.volatility,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              params_.rate,
        4,856 (0.0%)     0        0                3,200 (0.0%)         0          0                1,656  (0.0%)       673 (0.0%)  0                  0                0         0   0              params_.continuous_dividend_yield);
          112 (0.0%)     0        0                   56 (0.0%)         0          0                    0                 0         0                 56 (0.0%)         0         0   0          if (shared_spacing) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              return operators::create_spatial_operator(std::move(pde), shared_spacing);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          auto grid_view = GridView<double>(x_grid);
       37,056 (0.0%) 1,604 (1.3%) 2 (0.0%)        12,352 (0.0%)         0          0               16,984  (0.0%)       799 (0.0%)  0                  0                0         0   0          return operators::create_spatial_operator(std::move(pde), grid_view);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      };
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      auto bs_op = make_operator();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 4. Setup boundary conditions (NORMALIZED by K=1)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // For log-moneyness: x  - (S  0), x  + (S  )
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // IMPORTANT: Boundaries must account for time evolution via discounting
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // LEFT boundary (x  -, S  0):
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      auto left_bc = DirichletBC([this](double t, double x) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          const double tau = t;  // Time to maturity (backward PDE time)
   86,996,904 (0.1%)    66 (0.1%) 2 (0.0%)    46,839,184 (0.1%)   119,080  (0.3%)  1 (0.0%)    16,737,328  (0.2%)       680 (0.0%) 31 (0.0%)           0                0         0   0          const double discount = std::exp(-params_.rate * tau);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
   36,841,056 (0.0%)     0        0           20,105,328 (0.1%)         0          0                    0                 0         0         16,735,728 (0.1%)        11 (0.0%)  0   0          if (params_.option_type == OptionType::PUT) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Deep ITM put: V = Ke^(-r*) - S  Ke^(-r*) as S  0
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Normalized: V/K = e^(-r*) - e^(x - r*)  e^(-r*) as x  -
  110,468,632 (0.1%) 1,994 (1.6%) 3 (0.1%)    26,788,392 (0.1%)         0          0           26,789,992  (0.3%)         0         0                  0                0         0   0              return discount - std::exp(x) * discount;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          } else {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Deep OTM call: V  0 as S  0
   13,367,728 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0              return 0.0;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      });
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // RIGHT boundary (x  +, S  ):
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      auto right_bc = DirichletBC([this](double t, double x) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          const double tau = t;  // Time to maturity (backward PDE time)
   93,729,704 (0.1%) 1,523 (1.2%) 1 (0.0%)    50,205,584 (0.1%)         0          0           43,522,520  (0.4%)         0         0                  0                0         0   0          const double discount = std::exp(-params_.rate * tau);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
   70,309,312 (0.1%) 3,109 (2.5%) 3 (0.1%)    36,837,856 (0.1%)         0          0                    0                 0         0         16,735,728 (0.1%) 3,370,827 (2.4%)  0   0          if (params_.option_type == OptionType::CALL) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Deep ITM call: V = S - Ke^(-r*)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Normalized: V/K = (S/K) - e^(-r*) = e^x - e^(-r*)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              return std::exp(x) - discount;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          } else {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Deep OTM put: V  0 as S  
   16,735,728 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0              return 0.0;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      });
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 5. Setup obstacle condition
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      AmericanOptionResult result;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
        6,344 (0.0%)    56 (0.0%) 1 (0.0%)         3,144 (0.0%)        21  (0.0%)  0                    0                 0         0              1,600 (0.0%)        12 (0.0%)  0   0      if (params_.option_type == OptionType::PUT) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // Create PDESolver with obstacle
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          PDESolver solver(x_grid, time_domain, trbdf2_config_, root_config_,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                          left_bc, right_bc, bs_op,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                          [](double t, auto x, auto psi) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                              AmericanPutObstacle obstacle;
   13,369,328 (0.0%)     0        0            6,684,664 (0.0%)         0          0                    0                 0         0                  0                0         0   0                              obstacle(t, x, psi);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                          },
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                          external_workspace);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 6. Register discrete dividends as temporal events
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // Convert from calendar time (years from now) to solver time (backward time)
        3,200 (0.0%)     0        0                    0                0          0                    0                 0         0              1,600 (0.0%)         2 (0.0%)  0   0          for (const auto& [calendar_time, amount] : params_.discrete_dividends) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Solver time: t=0 at maturity, t=T at present
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Calendar time: time=0 now, time=T at maturity
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              double solver_time = params_.maturity - calendar_time;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              // Skip dividends at or beyond maturity (solver_time <= 0)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              if (solver_time <= 1e-10) continue;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              DividendJump div_jump(amount, params_.strike);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              solver.add_temporal_event(solver_time,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                  [div_jump](double t, auto x, auto u) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                      div_jump(t, x, u);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                  });
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 6a. Register snapshots (if any requested)
        3,200 (0.0%)     0        0                    0                0          0                    0                 0         0              1,600 (0.0%)         2 (0.0%)  0   0          for (const auto& req : snapshot_requests_) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              solver.register_snapshot(req.step_index, req.user_index, req.collector);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 7. Initialize with terminal condition (payoff at maturity)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // In log-moneyness, obstacle is normalized:  = max(1 - exp(x), 0)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // Initial condition must match (already normalized by K=1)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          solver.initialize([](auto x, auto u) {
      516,400 (0.0%)     0        0                    0                0          0                    0                 0         0            171,600 (0.0%)     2,933 (0.0%)  0   0              for (size_t i = 0; i < x.size(); ++i) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                  // Normalized payoff: max(1 - exp(x), 0) where x = ln(S/K)
    1,360,000 (0.0%)    14 (0.0%) 1 (0.0%)       340,000 (0.0%)       365  (0.0%)  0              340,000  (0.0%)       221 (0.0%)  0                  0                0         0   0                  u[i] = std::max(1.0 - std::exp(x[i]), 0.0);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          });
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 8. Solve the PDE
        6,400 (0.0%)     8 (0.0%) 1 (0.0%)             0                0          0                1,600  (0.0%)         0         0                  0                0         0   0          auto solve_status = solver.solve();
        3,200 (0.0%)     0        0                1,600 (0.0%)         0          0                    0                 0         0              1,600 (0.0%)         2 (0.0%)  0   0          if (!solve_status) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .              return unexpected(solve_status.error());
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          result.converged = true;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 9. Extract solution
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          auto solution_view = solver.solution();
        1,600 (0.0%)    52 (0.0%) 1 (0.0%)             0                0          0                    0                 0         0                  0                0         0   0          solution_.assign(solution_view.begin(), solution_view.end());
        1,600 (0.0%)     0        0                    0                0          0                1,600  (0.0%)         0         0                  0                0         0   0          solved_ = true;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 10. Interpolate to current spot price and denormalize
        8,000 (0.0%)     0        0                3,200 (0.0%)        90  (0.0%)  0                3,200  (0.0%)        12 (0.0%)  0                  0                0         0   0          double current_moneyness = std::log(params_.spot / params_.strike);
        8,000 (0.0%) 1,583 (1.3%) 1 (0.0%)         3,200 (0.0%)        18  (0.0%)  0                1,600  (0.0%)         0         0                  0                0         0   0          double normalized_value = interpolate_solution(current_moneyness, x_grid);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
        4,800 (0.0%)     0        0                1,600 (0.0%)         0          0                1,600  (0.0%)         0         0                  0                0         0   0          result.value = normalized_value * params_.strike;  // Denormalize
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      } else {  // CALL
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // Create PDESolver with obstacle
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // Note: left_bc and right_bc already defined above with time-dependent discounting
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          PDESolver solver(x_grid, time_domain, trbdf2_config_, root_config_,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                          left_bc, right_bc, bs_op,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                          [](double t, auto x, auto psi) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                              AmericanCallObstacle obstacle;
-- line 385 ----------------------------------------
-- line 429 ----------------------------------------
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          auto solution_view = solver.solution();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          solution_.assign(solution_view.begin(), solution_view.end());
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          solved_ = true;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          // 10. Interpolate to current spot price and denormalize
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          double current_moneyness = std::log(params_.spot / params_.strike);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          double normalized_value = interpolate_solution(current_moneyness, x_grid);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          result.value = normalized_value * params_.strike;  // Denormalize
        3,200 (0.0%)     9 (0.0%) 1 (0.0%)             0                0          0                1,600  (0.0%)         0         0                  0                0         0   0      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 11. Compute Greeks (stub implementation for now - Task 9)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      result.delta = compute_delta();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      result.gamma = compute_gamma();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      result.theta = compute_theta();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      return result;
       22,400 (0.0%)     2 (0.0%) 1 (0.0%)        17,600 (0.0%)       164  (0.0%)  0                    0                 0         0              1,600 (0.0%)         2 (0.0%)  0   0  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  double AmericanOptionSolver::interpolate_solution(double x_target,
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .                                                     std::span<const double> x_grid) const {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const size_t n = solution_.size();
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Boundary cases
        4,800 (0.0%)    14 (0.0%) 1 (0.0%)         1,600 (0.0%)         0          0                    0                 0         0              1,600 (0.0%)         4 (0.0%)  0   0      if (x_target <= x_grid[0]) return solution_[0];
        3,200 (0.0%)     0        0                1,600 (0.0%)         0          0                    0                 0         0              1,600 (0.0%)         0         0   0      if (x_target >= x_grid[n-1]) return solution_[n-1];
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Find bracketing indices
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      size_t i = 0;
      840,870 (0.0%)    71 (0.1%) 2 (0.0%)        83,767 (0.0%)         0          0                    0                 0         0            167,534 (0.0%)     1,614 (0.0%)  0   0      while (i < n-1 && x_grid[i+1] < x_target) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          i++;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Linear interpolation
        4,800 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      double t = (x_target - x_grid[i]) / (x_grid[i+1] - x_grid[i]);
        6,400 (0.0%)     9 (0.0%) 1 (0.0%)         4,800 (0.0%)         0          0                    0                 0         0                  0                0         0   0      return (1.0 - t) * solution_[i] + t * solution_[i+1];
        1,600 (0.0%)     0        0                1,600 (0.0%)         0          0                    0                 0         0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  std::vector<double> AmericanOptionSolver::get_solution() const {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      if (!solved_) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          throw std::runtime_error("Solver has not been run yet");
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      return solution_;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
       11,200 (0.0%)   281 (0.2%) 1 (0.0%)             0                0          0                6,400  (0.0%)         0         0                  0                0         0   0  double AmericanOptionSolver::compute_delta() const {
        9,600 (0.0%)     0        0                1,600 (0.0%)         0          0                3,200  (0.0%)         0         0              1,600 (0.0%)         0         0   0      if (!solved_) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          return 0.0;  // No solution available
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const size_t n = solution_.size();
       14,400 (0.0%)     9 (0.0%) 1 (0.0%)         3,200 (0.0%)        72  (0.0%)  0                1,600  (0.0%)         0         0              1,600 (0.0%)         0         0   0      const double dx = (grid_.x_max - grid_.x_min) / (n - 1);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Find current spot in grid
       11,200 (0.0%)     0        0                3,200 (0.0%)         0          0                6,400  (0.0%)         0         0                  0                0         0   0      double current_moneyness = std::log(params_.spot / params_.strike);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Find the grid point closest to current_moneyness
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Use the same approach as interpolate_solution
        1,600 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      size_t i = 0;
      766,703 (0.0%)     8 (0.0%) 1 (0.0%)         6,400 (0.0%)         0          0                    0                 0         0            169,134 (0.0%)     2,431 (0.0%)  0   0      while (i < n-1 && grid_.x_min + (i+1)*dx < current_moneyness) {
       83,767 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0          i++;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Ensure we're in valid interior range for centered differences
        4,800 (0.0%)     9 (0.0%) 1 (0.0%)             0                0          0                    0                 0         0                  0                0         0   0      if (i == 0) i = 1;
        3,200 (0.0%)     0        0                    0                0          0                    0                 0         0              1,600 (0.0%)         0         0   0      if (i >= n-1) i = n-2;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Compute V/x using centered finite difference
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Note: solution_ stores V/K (normalized)
        4,800 (0.0%)     9 (0.0%) 1 (0.0%)         1,600 (0.0%)         0          0                    0                 0         0                  0                0         0   0      const double half_dx_inv = 1.0 / (2.0 * dx);
        6,400 (0.0%)     0        0                3,200 (0.0%)         0          0                    0                 0         0                  0                0         0   0      double dVdx = (solution_[i+1] - solution_[i-1]) * half_dx_inv;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Transform from log-moneyness to spot
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // V_dollar = V_norm * K
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Delta = V_dollar/S = K * V_norm/x * x/S
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //       = K * dVdx * (1/S)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //       = (K/S) * dVdx
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Use FMA: (K/S) * dVdx
        1,600 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      const double K_over_S = params_.strike / params_.spot;
        1,600 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      double delta = K_over_S * dVdx;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      return delta;
        9,600 (0.0%)     0        0                8,000 (0.0%)         0          0                    0                 0         0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
       11,200 (0.0%)    57 (0.0%) 1 (0.0%)             0                0          0                6,400  (0.0%)         0         0                  0                0         0   0  double AmericanOptionSolver::compute_gamma() const {
        3,200 (0.0%)     0        0                1,600 (0.0%)         0          0                1,600  (0.0%)         0         0                  0                0         0   0      if (!solved_) {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .          return 0.0;  // No solution available
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      const size_t n = solution_.size();
       14,400 (0.0%) 1,542 (1.3%) 1 (0.0%)         3,200 (0.0%)         0          0                1,600  (0.0%)         0         0              1,600 (0.0%)         0         0   0      const double dx = (grid_.x_max - grid_.x_min) / (n - 1);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Find current spot in grid
       11,200 (0.0%) 1,542 (1.3%) 1 (0.0%)         3,200 (0.0%)         0          0                6,400  (0.0%)         0         0                  0                0         0   0      double current_moneyness = std::log(params_.spot / params_.strike);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Find the grid point closest to current_moneyness
        1,600 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      size_t i = 0;
      766,703 (0.0%)    36 (0.0%) 1 (0.0%)         6,400 (0.0%)         0          0                    0                 0         0            169,134 (0.0%)     1,617 (0.0%)  0   0      while (i < n-1 && grid_.x_min + (i+1)*dx < current_moneyness) {
       83,767 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0          i++;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Ensure we're in valid interior range for centered differences
        4,800 (0.0%)     9 (0.0%) 1 (0.0%)             0                0          0                    0                 0         0                  0                0         0   0      if (i == 0) i = 1;
        3,200 (0.0%)     0        0                    0                0          0                    0                 0         0              1,600 (0.0%)         0         0   0      if (i >= n-1) i = n-2;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Centered second derivative: [V(i+1) - 2*V(i) + V(i-1)] / dx
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Use FMA: (V(i+1) + V(i-1)) / dx - 2*V(i) / dx
        4,800 (0.0%)     0        0                1,600 (0.0%)         0          0                    0                 0         0                  0                0         0   0      const double dx2_inv = 1.0 / (dx * dx);
       12,800 (0.0%)    10 (0.0%) 1 (0.0%)         6,400 (0.0%)         0          0                    0                 0         0                  0                0         0   0      double d2Vdx2 = std::fma(solution_[i+1] + solution_[i-1], dx2_inv, -2.0*solution_[i]*dx2_inv);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Centered first derivative: [V(i+1) - V(i-1)] / (2*dx)
        4,800 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      double dVdx = (solution_[i+1] - solution_[i-1]) / (2.0 * dx);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Transform from log-moneyness to spot using chain rule
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // x = ln(S/K), so x/S = 1/S and x/S = -1/S
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // V_dollar(S) = K * V_norm(x(S))
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // First derivative:
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // dV/dS = K * dV_norm/dx * dx/dS = K * dV_norm/dx * (1/S)
-- line 546 ----------------------------------------
-- line 550 ----------------------------------------
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //         = K * d/dS[dV_norm/dx * (1/S)]
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //         = K * [dV_norm/dx * (dx/dS) * (1/S) + dV_norm/dx * d/dS(1/S)]
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //         = K * [dV_norm/dx * (1/S) + dV_norm/dx * (-1/S)]
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //         = (K/S) * [dV_norm/dx - dV_norm/dx]
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      double S = params_.spot;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      double K = params_.strike;
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Use FMA: (K/S) * (d2Vdx2 - dVdx) = (K/S)*d2Vdx2 - (K/S)*dVdx
        3,200 (0.0%)     0        0                    0                0          0                    0                 0         0                  0                0         0   0      const double K_over_S2 = K / (S * S);
        4,800 (0.0%)     0        0                1,600 (0.0%)         0          0                    0                 0         0                  0                0         0   0      double gamma = std::fma(K_over_S2, d2Vdx2, -K_over_S2 * dVdx);
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      return gamma;
        9,600 (0.0%)     0        0                8,000 (0.0%)         0          0                    0                 0         0                  0                0         0   0  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  double AmericanOptionSolver::compute_theta() const {
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Theta is time decay: V/t
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // For American options with no closed form, accurate theta requires:
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 1. Re-solving at slightly different time, or
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // 2. Evaluating the PDE operator: V/t = L(V)
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      //
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Both approaches are expensive and complex. For now, return 0.0 as stub.
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      // Future enhancement could evaluate the BS operator on the solution surface.
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .      return 0.0;  // Stub implementation
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  }
            .            .        .                    .                .          .                    .                 .         .                  .                .         .   .  
           36 (0.0%)     4 (0.0%) 4 (0.1%)             9 (0.0%)         0          0                    6  (0.0%)         0         0                  6 (0.0%)         3 (0.0%)  0   0  }  // namespace mango

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/bits/std_abs.h
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr____ Dr_______________ D1mr__________ DLmr____ Dw____________ D1mw DLmw Bc Bcm Bi Bim 

-- line 64 ----------------------------------------
          .            .        .                 .              .        .              .           .    .  .   .  .   .  // _GLIBCXX_RESOLVE_LIB_DEFECTS
          .            .        .                 .              .        .              .           .    .  .   .  .   .  // 2192. Validity and return type of std::abs(0u) is unclear
          .            .        .                 .              .        .              .           .    .  .   .  .   .  // 2294. <cstdlib> should declare abs(double)
          .            .        .                 .              .        .              .           .    .  .   .  .   .  // 2735. std::abs(short), std::abs(signed char) and others should return int
          .            .        .                 .              .        .              .           .    .  .   .  .   .  
          .            .        .                 .              .        .              .           .    .  .   .  .   .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
          .            .        .                 .              .        .              .           .    .  .   .  .   .    inline _GLIBCXX_CONSTEXPR double
          .            .        .                 .              .        .              .           .    .  .   .  .   .    abs(double __x)
780,612,187 (0.7%) 1,633 (1.3%) 7 (0.1%) 11,927,201 (0.0%) 119,066 (0.3%) 1 (0.0%) 271,876 (0.0%)    0    0  0   0  0   0    { return __builtin_fabs(__x); }
          .            .        .                 .              .        .              .           .    .  .   .  .   .  
          .            .        .                 .              .        .              .           .    .  .   .  .   .    inline _GLIBCXX_CONSTEXPR float
          .            .        .                 .              .        .              .           .    .  .   .  .   .    abs(float __x)
          .            .        .                 .              .        .              .           .    .  .   .  .   .    { return __builtin_fabsf(__x); }
          .            .        .                 .              .        .              .           .    .  .   .  .   .  
          .            .        .                 .              .        .              .           .    .  .   .  .   .    inline _GLIBCXX_CONSTEXPR long double
          .            .        .                 .              .        .              .           .    .  .   .  .   .    abs(long double __x)
          .            .        .                 .              .        .              .           .    .  .   .  .   .    { return __builtin_fabsl(__x); }
-- line 80 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr_____ Dr_______________ D1mr____ DLmr____ Dw_______________ D1mw____ DLmw____ Bc_______________ Bcm_________ Bi Bim 

-- line 230 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _Tp>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      inline const _Tp&
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      min(const _Tp& __a, const _Tp& __b)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        // concept requirements
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        //return __b < __a ? __b : __a;
     25,902 (0.0%)     8 (0.0%)  3 (0.1%)          0        0        0                 9 (0.0%) 0        0                 0            0         0   0        if (__b < __a)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	return __b;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        return __a;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    /**
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @brief This does what you think it does.
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @ingroup sorting_algorithms
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @param  __a  A thing of arbitrary type.
-- line 246 ----------------------------------------
-- line 254 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _Tp>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      inline const _Tp&
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      max(const _Tp& __a, const _Tp& __b)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        // concept requirements
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        //return  __a < __b ? __b : __a;
176,179,247 (0.2%)    22 (0.0%)  9 (0.2%)  4,035,345 (0.0%) 7 (0.0%) 0         1,255,663 (0.0%) 0        0               109 (0.0%)     3 (0.0%)  0   0        if (__a < __b)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	return __b;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        return __a;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    /**
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @brief This does what you think it does.
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @ingroup sorting_algorithms
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @param  __a  A thing of arbitrary type.
-- line 270 ----------------------------------------
-- line 405 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	      ++__result;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	    }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	  return __result;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	}
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        template<typename _Tp, typename _Up>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	static void
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	__assign_one(_Tp* __to, _Up* __from)
          8 (0.0%)     2 (0.0%)  1 (0.0%)          2 (0.0%) 2 (0.0%) 0                 4 (0.0%) 0        0                 0            0         0   0  	{ *__to = *__from; }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      };
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      struct __copy_move<true, false, random_access_iterator_tag>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        template<typename _II, typename _OI>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	_GLIBCXX20_CONSTEXPR
-- line 421 ----------------------------------------
-- line 442 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<bool _IsMove>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      struct __copy_move<_IsMove, true, random_access_iterator_tag>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        template<typename _Tp, typename _Up>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	static _Up*
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	__copy_m(_Tp* __first, _Tp* __last, _Up* __result)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	{
  6,736,818 (0.0%)     1 (0.0%)  1 (0.0%)  3,368,416 (0.0%) 0        0                 0        0        0                 0            0         0   0  	  const ptrdiff_t _Num = __last - __first;
 26,793,142 (0.0%)     1 (0.0%)  1 (0.0%)  3,315,064 (0.0%) 0        0                 0        0        0        10,055,039 (0.1%) 1,520 (0.0%)  0   0  	  if (__builtin_expect(_Num > 1, true))
 36,957,977 (0.0%)    49 (0.0%)  5 (0.1%)  6,736,023 (0.0%) 2 (0.0%) 2 (0.0%) 16,793,000 (0.2%) 7 (0.0%) 1 (0.0%)          0            0         0   0  	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
         21 (0.0%)     6 (0.0%)  1 (0.0%)          0        0        0                 0        0        0                21 (0.0%)     2 (0.0%)  0   0  	  else if (_Num == 1)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	    std::__copy_move<_IsMove, false, random_access_iterator_tag>::
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	      __assign_one(__result, __first);
        830 (0.0%)    14 (0.0%)  2 (0.0%)          3 (0.0%) 0        0               413 (0.0%) 0        0                 0            0         0   0  	  return __result + _Num;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	}
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      };
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _Tp, typename _Ref, typename _Ptr>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      struct _Deque_iterator;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
-- line 464 ----------------------------------------
-- line 942 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _ForwardIterator, typename _Tp>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      inline typename
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	      const _Tp& __value)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
         36 (0.0%)     0         0                36 (0.0%) 0        0                 0        0        0                 0            0         0   0        const _Tp __tmp = __value;
 16,757,668 (0.0%)    57 (0.0%)  5 (0.1%)  6,684,616 (0.0%) 0        0                 8 (0.0%) 0        0         8,378,004 (0.1%)     6 (0.0%)  0   0        for (; __first != __last; ++__first)
100,511,847 (0.1%) 2,000 (1.6%) 17 (0.3%) 25,111,402 (0.1%) 0        0        36,867,591 (0.4%) 0        0                 0            0         0   0  	*__first = __tmp;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    // Specialization: for char types we can use memset.
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _Tp>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      inline typename
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
-- line 960 ----------------------------------------
-- line 1094 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _OutputIterator, typename _Size, typename _Tp>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      inline typename
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
          8 (0.0%)     1 (0.0%)  1 (0.0%)          0        0        0                 8 (0.0%) 0        0                 0            0         0   0        const _Tp __tmp = __value;
         32 (0.0%)     0         0                 0        0        0                 0        0        0                16 (0.0%)     4 (0.0%)  0   0        for (; __n > 0; --__n, (void) ++__first)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	*__first = __tmp;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        return __first;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	   typename _Tp>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
-- line 1111 ----------------------------------------
-- line 1141 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      inline _OutputIterator
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	       std::random_access_iterator_tag)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  #endif
     11,714 (0.0%)     4 (0.0%)  1 (0.0%)        506 (0.0%) 0        0                 0        0        0             5,605 (0.0%)    39 (0.0%)  0   0        if (__n <= 0)
          1 (0.0%)     0         0                 0        0        0                 0        0        0                 0            0         0   0  	return __first;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        __glibcxx_requires_can_increment(__first, __n);
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
         42 (0.0%)     0         0                16 (0.0%) 0        0                 0        0        0                 0            0         0   0        std::__fill_a(__first, __first + __n, __value);
      6,252 (0.0%)     2 (0.0%)  1 (0.0%)        727 (0.0%) 0        0                 1 (0.0%) 0        0                 0            0         0   0        return __first + __n;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    /**
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @brief Fills the range [first,first+n) with copies of value.
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @ingroup mutating_algorithms
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @param  __first  An output iterator.
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @param  __n      The count of copies to perform.
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .     *  @param  __value  A reference-to-const of arbitrary type.
-- line 1163 ----------------------------------------
-- line 2153 ----------------------------------------
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  		       std::__iterator_category(__first));
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _InputIterator, typename _Predicate>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      typename iterator_traits<_InputIterator>::difference_type
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      {
         24 (0.0%)     0         0                 0        0        0                 0        0        0                 0            0         0   0        typename iterator_traits<_InputIterator>::difference_type __n = 0;
         40 (0.0%)     0         0                 0        0        0                 0        0        0                16 (0.0%)     3 (0.0%)  0   0        for (; __first != __last; ++__first)
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  	if (__pred(__first))
         16 (0.0%)     0         0                 8 (0.0%) 0        0                 0        0        0                 0            0         0   0  	  ++__n;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .        return __n;
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      }
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .    template<typename _ForwardIterator, typename _Predicate>
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _GLIBCXX20_CONSTEXPR
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      _ForwardIterator
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .      __remove_if(_ForwardIterator __first, _ForwardIterator __last,
          .            .         .                 .        .        .                 .        .        .                 .            .         .   .  		_Predicate __pred)
-- line 2172 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr_____ Dr_______________ D1mr_________ DLmr Dw___________ D1mw________ DLmw______ Bc_______________ Bcm_______ Bi Bim 

-- line 91 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        struct _Vector_impl_data
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	pointer _M_start;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	pointer _M_finish;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	pointer _M_end_of_storage;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_Vector_impl_data() _GLIBCXX_NOEXCEPT
     56,891 (0.0%)   104 (0.1%) 18 (0.3%)        201 (0.0%)      0           0 53,257 (0.0%) 1,405 (0.0%) 689 (0.4%)          0          0         0   0  	: _M_start(), _M_finish(), _M_end_of_storage()
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	{ }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          3 (0.0%)     0         0                 0             0           0      1 (0.0%)     0          0                 0          0         0   0  	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
     11,252 (0.0%)    32 (0.0%) 11 (0.2%)      4,710 (0.0%)      3 (0.0%)    0  4,985 (0.0%)    38 (0.0%)   0                 0          0         0   0  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
      4,807 (0.0%)    14 (0.0%)  3 (0.1%)      1,561 (0.0%)      0           0  3,241 (0.0%)   698 (0.0%)  31 (0.0%)          0          0         0   0  	  _M_end_of_storage(__x._M_end_of_storage)
        133 (0.0%)    11 (0.0%) 11 (0.2%)          0             0           0    118 (0.0%)     0          0                 0          0         0   0  	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	{
         70 (0.0%)     3 (0.0%)  3 (0.1%)         33 (0.0%)      0           0     26 (0.0%)     0          0                 0          0         0   0  	  _M_start = __x._M_start;
         17 (0.0%)     1 (0.0%)  1 (0.0%)         13 (0.0%)      0           0      4 (0.0%)     0          0                 0          0         0   0  	  _M_finish = __x._M_finish;
         55 (0.0%)     9 (0.0%)  2 (0.0%)         31 (0.0%)      0           0     24 (0.0%)     0          0                 0          0         0   0  	  _M_end_of_storage = __x._M_end_of_storage;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	}
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	{
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  // information used by TBAA.
-- line 124 ----------------------------------------
-- line 361 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        { }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        ~_Vector_base() _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_M_deallocate(_M_impl._M_start,
     41,701 (0.0%) 1,753 (1.4%) 42 (0.7%)     30,321 (0.0%)    213 (0.0%)    0    280 (0.0%)     0          0                 0          0         0   0  		      _M_impl._M_end_of_storage - _M_impl._M_start);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .      public:
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _Vector_impl _M_impl;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        pointer
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_allocate(size_t __n)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
     22,078 (0.0%)    47 (0.0%)  8 (0.1%)      1,616 (0.0%)      0           0     59 (0.0%)     0          0             9,568 (0.0%) 829 (0.0%)  0   0  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_deallocate(pointer __p, size_t __n)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
     61,464 (0.0%)   104 (0.1%) 16 (0.3%)      1,906 (0.0%)      0           0      5 (0.0%)     0          0            27,813 (0.0%) 154 (0.0%)  0   0  	if (__p)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  _Tr::deallocate(_M_impl, __p, __n);
          1 (0.0%)     0         0                 0             0           0      0            0          0                 0          0         0   0        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .      protected:
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_create_storage(size_t __n)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
     13,184 (0.0%)     5 (0.0%)  2 (0.0%)          0             0           0  9,172 (0.0%)     0          0                 0          0         0   0  	this->_M_impl._M_start = this->_M_allocate(__n);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	this->_M_impl._M_finish = this->_M_impl._M_start;
     20,247 (0.0%)    38 (0.0%)  7 (0.1%)         21 (0.0%)      0           0  9,211 (0.0%)     0          0                 0          0         0   0  	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .      };
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .    /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .     *  @brief A standard container which offers fixed time access to
          .            .         .                 .             .           .      .            .          .                 .          .         .   .     *  individual elements in any order.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .     *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .     *  @ingroup sequences
-- line 408 ----------------------------------------
-- line 548 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __n  The number of elements to initially create.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __a  An allocator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  This constructor fills the %vector with @a __n default
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  constructed elements.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        explicit
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
      2,888 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0  2,166 (0.0%)     0          0                 0          0         0   0        vector(size_type __n, const allocator_type& __a = allocator_type())
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        : _Base(_S_check_init_len(__n, __a), __a)
      2,888 (0.0%)     0         0             2,527 (0.0%)      0           0      0            0          0                 0          0         0   0        { _M_default_initialize(__n); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Creates a %vector with copies of an exemplar element.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __n  The number of elements to initially create.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __value  An element to copy.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __a  An allocator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 566 ----------------------------------------
-- line 593 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  All the elements of @a __x are copied, but any unused capacity in
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @a __x  will not be copied
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  (i.e. capacity() == size() in the new %vector).
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  The newly-created %vector uses a copy of the allocator object used
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  by @a __x (unless the allocator traits dictate a different object).
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
      2,992 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0  1,496 (0.0%)     0          0                 0          0         0   0        vector(const vector& __x)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        : _Base(__x.size(),
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
      1,600 (0.0%)    84 (0.1%)  2 (0.0%)          0             0           0  1,600 (0.0%)     0          0                 0          0         0   0  	this->_M_impl._M_finish =
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  				      this->_M_impl._M_start,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  				      _M_get_Tp_allocator());
      2,244 (0.0%)     0         0             1,870 (0.0%)      0           0      0            0          0                 0          0         0   0        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  %Vector move constructor.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  The newly-created %vector contains the exact contents of the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  moved instance.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  The contents of the moved instance are a valid, but unspecified
-- line 617 ----------------------------------------
-- line 670 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Create a %vector consisting of copies of the elements in the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  initializer_list @a __l.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  This will call the element type's copy constructor N times
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  (where N is @a __l.size()) and do no memory reallocation.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
         24 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0     12 (0.0%)     0          0                 0          0         0   0        vector(initializer_list<value_type> __l,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	     const allocator_type& __a = allocator_type())
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        : _Base(__a)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_M_range_initialize(__l.begin(), __l.end(),
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  			    random_access_iterator_tag());
         16 (0.0%)     0         0                16 (0.0%)      0           0      0            0          0                 0          0         0   0        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Builds a %vector from a range.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __first  An input iterator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __last  An input iterator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __a  An allocator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
-- line 692 ----------------------------------------
-- line 725 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  The dtor only erases the elements, and note that if the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  elements themselves are pointers, the pointed-to memory is
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  not touched in any way.  Managing the pointer is the user's
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  responsibility.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
        295 (0.0%)     8 (0.0%)  1 (0.0%)          0             0           0    196 (0.0%)     0          0                 0          0         0   0        ~vector() _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
      3,374 (0.0%)   665 (0.5%)  5 (0.1%)      3,374 (0.0%)     14 (0.0%)    0      0            0          0                 0          0         0   0  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  		      _M_get_Tp_allocator());
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
        613 (0.0%)     9 (0.0%)  2 (0.0%)        220 (0.0%)      0           0      0            0          0                 0          0         0   0        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  %Vector assignment operator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __x  A %vector of identical element and allocator types.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  All the elements of @a __x are copied, but any unused capacity in
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @a __x will not be copied.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
-- line 746 ----------------------------------------
-- line 782 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Note that the assignment completely changes the %vector and
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  that the resulting %vector's size is the same as the number
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  of elements assigned.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        vector&
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        operator=(initializer_list<value_type> __l)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
         13 (0.0%)     0         0                 0             0           0      4 (0.0%)     0          0                 0          0         0   0  	this->_M_assign_aux(__l.begin(), __l.end(),
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  			    random_access_iterator_tag());
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	return *this;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Assigns a given value to a %vector.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __n  Number of elements to be assigned.
-- line 798 ----------------------------------------
-- line 821 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  of elements assigned.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        template<typename _InputIterator,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	       typename = std::_RequireInputIter<_InputIterator>>
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	assign(_InputIterator __first, _InputIterator __last)
      4,800 (0.0%)     0         0             3,200 (0.0%)      0           0  1,600 (0.0%)     0          0                 0          0         0   0  	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #else
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        template<typename _InputIterator>
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	assign(_InputIterator __first, _InputIterator __last)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	{
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  // Check whether it's an integral type.  If so, it's not an iterator.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  _M_assign_dispatch(__first, __last, _Integral());
-- line 837 ----------------------------------------
-- line 984 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        crend() const noexcept
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        { return const_reverse_iterator(begin()); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // [23.2.4.2] capacity
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**  Returns the number of elements in the %vector.  */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        size_type
      3,233 (0.0%)     0         0             1,633 (0.0%)      0           0  1,600 (0.0%)     0          0                 0          0         0   0        size() const _GLIBCXX_NOEXCEPT
223,263,929 (0.2%) 3,564 (2.9%) 41 (0.7%) 68,703,582 (0.2%) 61,090 (0.2%)    0  3,217 (0.0%)     2 (0.0%)   0             3,200 (0.0%)   0         0   0        { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**  Returns the size() of the largest possible %vector.  */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        size_type
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        max_size() const _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        { return _S_max_size(_M_get_Tp_allocator()); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #if __cplusplus >= 201103L
-- line 1001 ----------------------------------------
-- line 1007 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  number of elements.  If the number is smaller than the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  %vector's current size the %vector is truncated, otherwise
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  default constructed elements are appended.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        resize(size_type __new_size)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
 46,834,386 (0.0%)     0         0        13,366,128 (0.0%)      0           0      0            0          0        16,734,129 (0.1%)  18 (0.0%)  0   0  	if (__new_size > size())
        136 (0.0%)     0         0                 0             0           0      0            0          0                 0          0         0   0  	  _M_default_append(__new_size - size());
 33,468,122 (0.0%)     9 (0.0%)  1 (0.0%) 13,366,128 (0.0%)      0           0      0            0          0        15,050,094 (0.1%)   5 (0.0%)  0   0  	else if (__new_size < size())
  1,683,968 (0.0%)     0         0                 0             0           0      0            0          0                 0          0         0   0  	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Resizes the %vector to the specified number of elements.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __new_size  Number of elements the %vector should contain.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __x  Data with which new elements should be populated.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  This function will %resize the %vector to the specified
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  number of elements.  If the number is smaller than the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  %vector's current size the %vector is truncated, otherwise
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  the %vector is extended and new elements are populated with
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  given data.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
         20 (0.0%)     0         0                16 (0.0%)      0           0      0            0          0                 0          0         0   0        resize(size_type __new_size, const value_type& __x)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
         20 (0.0%)     0         0                 8 (0.0%)      0           0      0            0          0                 4 (0.0%)   0         0   0  	if (__new_size > size())
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  _M_fill_insert(end(), __new_size - size(), __x);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	else if (__new_size < size())
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #else
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Resizes the %vector to the specified number of elements.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __new_size  Number of elements the %vector should contain.
-- line 1044 ----------------------------------------
-- line 1073 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Returns the total number of elements that the %vector can
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  hold before needing to allocate more memory.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        size_type
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        capacity() const _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	return size_type(this->_M_impl._M_end_of_storage
     11,096 (0.0%)     1 (0.0%)  1 (0.0%)      5,536 (0.0%)      0           0      6 (0.0%)     0          0                 0          0         0   0  			   - this->_M_impl._M_start);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Returns true if the %vector is empty.  (Thus begin() would
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  equal end().)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        bool
-- line 1089 ----------------------------------------
-- line 1120 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  This operator allows for easy, array-style, data access.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Note that data access with this operator is unchecked and
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  out_of_range lookups are not defined. (For checked lookups
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  see at().)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        reference
     15,614 (0.0%)     1 (0.0%)  1 (0.0%)     15,600 (0.0%)      0           0      0            0          0                 0          0         0   0        operator[](size_type __n) _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	__glibcxx_requires_subscript(__n);
420,736,008 (0.4%)   403 (0.3%) 17 (0.3%) 83,775,684 (0.2%) 30,003 (0.1%)    0 75,960 (0.0%)     0          0        40,204,256 (0.3%) 225 (0.0%)  0   0  	return *(this->_M_impl._M_start + __n);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Subscript access to the data contained in the %vector.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param __n The index of the element for which data should be
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  accessed.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @return  Read-only (constant) reference to data.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
-- line 1139 ----------------------------------------
-- line 1142 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  out_of_range lookups are not defined. (For checked lookups
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  see at().)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        const_reference
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        operator[](size_type __n) const _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	__glibcxx_requires_subscript(__n);
 85,570,076 (0.1%)     5 (0.0%)  3 (0.1%)     23,840 (0.0%)      0           0  4,640 (0.0%)     0          0            22,400 (0.0%)   7 (0.0%)  0   0  	return *(this->_M_impl._M_start + __n);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .      protected:
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /// Safety check used only from at().
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_range_check(size_type __n) const
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
-- line 1158 ----------------------------------------
-- line 1255 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // data access
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *   Returns a pointer such that [data(), data() + size()) is a valid
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *   range.  For a non-empty %vector, data() == &front().
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _Tp*
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        data() _GLIBCXX_NOEXCEPT
 15,106,268 (0.0%)    94 (0.1%)  3 (0.1%) 15,106,268 (0.0%) 30,004 (0.1%)    0      0            0          0                 0          0         0   0        { return _M_data_ptr(this->_M_impl._M_start); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        const _Tp*
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        data() const _GLIBCXX_NOEXCEPT
 80,289,107 (0.1%)    12 (0.0%)  1 (0.0%) 80,289,107 (0.2%)      0           0      0            0          0                 0          0         0   0        { return _M_data_ptr(this->_M_impl._M_start); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // [23.2.4.3] modifiers
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @brief  Add data to the end of the %vector.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  @param  __x  Data to be added.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  This is a typical stack operation.  The function creates an
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  element at the end of the %vector and assigns the given data
-- line 1276 ----------------------------------------
-- line 1277 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  to it.  Due to the nature of a %vector this operation can be
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  done in constant time if the %vector has preallocated space
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  available.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        push_back(const value_type& __x)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
      2,217 (0.0%)     7 (0.0%)  7 (0.1%)      1,210 (0.0%)      4 (0.0%)    0      0            0          0               747 (0.0%)  57 (0.0%)  0   0  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  				     __x);
      1,073 (0.0%)     0         0                 1 (0.0%)      0           0    408 (0.0%)     0          0                 0          0         0   0  	    ++this->_M_impl._M_finish;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	else
        987 (0.0%)    26 (0.0%) 19 (0.3%)        278 (0.0%)      0           0    344 (0.0%)     0          0                 0          0         0   0  	  _M_realloc_append(__x);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        push_back(value_type&& __x)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        { emplace_back(std::move(__x)); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
-- line 1302 ----------------------------------------
-- line 1600 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Erases all the elements.  Note that this function only erases the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  elements, and that if the elements themselves are pointers, the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  pointed-to memory is not touched in any way.  Managing the pointer is
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  the user's responsibility.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        clear() _GLIBCXX_NOEXCEPT
          1 (0.0%)     0         0                 1 (0.0%)      0           0      0            0          0                 0          0         0   0        { _M_erase_at_end(this->_M_impl._M_start); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .      protected:
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        /**
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  Memory expansion handler.  Uses the member allocation function to
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         *  obtain @a n bytes of memory, and then copies [first,last) into it.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .         */
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        template<typename _ForwardIterator>
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
-- line 1616 ----------------------------------------
-- line 1686 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        template<typename _ForwardIterator>
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  			    std::forward_iterator_tag)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	{
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  const size_type __n = std::distance(__first, __last);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  this->_M_impl._M_start
          6 (0.0%)     0         0                 0             0           0      6 (0.0%)     0          0                 0          0         0   0  	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
         14 (0.0%)     0         0                 0             0           0      6 (0.0%)     0          0                 0          0         0   0  	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
          7 (0.0%)     0         0                 0             0           0      7 (0.0%)     0          0                 0          0         0   0  	  this->_M_impl._M_finish =
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	    std::__uninitialized_copy_a(__first, __last,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  					this->_M_impl._M_start,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  					_M_get_Tp_allocator());
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	}
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Called by the first initialize_dispatch above and by the
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // vector(n,value,a) constructor.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_fill_initialize(size_type __n, const value_type& __value)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
        361 (0.0%)     1 (0.0%)  1 (0.0%)          0             0           0    361 (0.0%)     0          0                 0          0         0   0  	this->_M_impl._M_finish =
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  					_M_get_Tp_allocator());
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #if __cplusplus >= 201103L
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Called by the vector(n) constructor.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_default_initialize(size_type __n)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
      6,807 (0.0%)    10 (0.0%)  1 (0.0%)          1 (0.0%)      0           0  6,806 (0.0%)     0          0                 0          0         0   0  	this->_M_impl._M_finish =
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  					   _M_get_Tp_allocator());
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Internal assign functions follow.  The *_aux functions do the actual
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // assignment work for the range versions.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
-- line 1727 ----------------------------------------
-- line 1900 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        { return _M_insert_rval(__position, std::move(__v)); }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  #endif
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Called by _M_fill_insert, _M_insert_aux etc.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        size_type
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_check_len(size_type __n, const char* __s) const
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
        471 (0.0%)    10 (0.0%)  6 (0.1%)          0             0           0      0            0          0               179 (0.0%)   1 (0.0%)  0   0  	if (max_size() - size() < __n)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  __throw_length_error(__N(__s));
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
         66 (0.0%)     0         0                 0             0           0      0            0          0                 0          0         0   0  	const size_type __len = size() + (std::max)(size(), __n);
        591 (0.0%)     6 (0.0%)  2 (0.0%)          0             0           0     66 (0.0%)     0          0                 0          0         0   0  	return (__len < size() || __len > max_size()) ? max_size() : __len;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Called by constructors to check initial size.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        static _GLIBCXX20_CONSTEXPR size_type
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _S_check_init_len(size_type __n, const allocator_type& __a)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
     32,403 (0.0%)   268 (0.2%)  4 (0.1%)        360 (0.0%)      0           0      0            0          0            11,090 (0.0%)  11 (0.0%)  0   0  	if (__n > _S_max_size(_Tp_alloc_type(__a)))
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  __throw_length_error(
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	      __N("cannot create std::vector larger than max_size()"));
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	return __n;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        static _GLIBCXX20_CONSTEXPR size_type
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
-- line 1927 ----------------------------------------
-- line 1937 ----------------------------------------
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Internal erase functions follow.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        // _M_assign_aux.
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        void
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        {
  3,367,937 (0.0%)     0         0                 1 (0.0%)      0           0      0            0          0         1,683,968 (0.0%)   3 (0.0%)  0   0  	if (size_type __n = this->_M_impl._M_finish - __pos)
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  {
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	    std::_Destroy(__pos, this->_M_impl._M_finish,
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  			  _M_get_Tp_allocator());
          3 (0.0%)     0         0                 1 (0.0%)      0           0      2 (0.0%)     0          0                 0          0         0   0  	    this->_M_impl._M_finish = __pos;
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  	  }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        }
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _GLIBCXX20_CONSTEXPR
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        iterator
          .            .         .                 .             .           .      .            .          .                 .          .         .   .        _M_erase(iterator __position);
          .            .         .                 .             .           .      .            .          .                 .          .         .   .  
-- line 1957 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/experimental/bits/simd_builtin.h
--------------------------------------------------------------------------------
Ir________________ I1mr_____ ILmr____ Dr________________ D1mr DLmr Dw________________ D1mw DLmw Bc Bcm Bi Bim 

-- line 1118 ----------------------------------------
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _S_load(const void* __p)
          .         .        .                  .           .    .           .           .    .  .   .  .   .      {
          .         .        .                  .           .    .           .           .    .  .   .  .   .        static_assert(_Np > 1);
          .         .        .                  .           .    .           .           .    .  .   .  .   .        static_assert(_Bytes % sizeof(_Tp) == 0);
          .         .        .                  .           .    .           .           .    .  .   .  .   .        using _Rp = __vector_type_t<_Tp, _Np>;
          .         .        .                  .           .    .           .           .    .  .   .  .   .        if constexpr (sizeof(_Rp) == _Bytes)
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	{
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	  _Rp __r;
460,231,872 (0.4%) 40 (0.0%) 1 (0.0%) 460,231,872 (1.3%)    0    0           0           0    0  0   0  0   0  	  __builtin_memcpy(&__r, __p, _Bytes);
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	  return __r;
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	}
          .         .        .                  .           .    .           .           .    .  .   .  .   .        else
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	{
          .         .        .                  .           .    .           .           .    .  .   .  .   .  #ifdef _GLIBCXX_SIMD_WORKAROUND_PR90424
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	  using _Up = conditional_t<
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	    is_integral_v<_Tp>,
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	    conditional_t<_Bytes % 4 == 0,
-- line 1134 ----------------------------------------
-- line 1160 ----------------------------------------
          .         .        .                  .           .    .           .           .    .  .   .  .   .    // _S_store {{{
          .         .        .                  .           .    .           .           .    .  .   .  .   .    template <size_t _Bytes>
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _GLIBCXX_SIMD_INTRINSIC static void
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _S_memcpy(char* __dst, const char* __src)
          .         .        .                  .           .    .           .           .    .  .   .  .   .      {
          .         .        .                  .           .    .           .           .    .  .   .  .   .        if constexpr (_Bytes > 0)
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	{
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	  constexpr size_t _Ns = std::__bit_floor(_Bytes);
460,231,872 (0.4%)  0        0                  0           0    0 460,231,872 (4.5%)    0    0  0   0  0   0  	  __builtin_memcpy(__dst, __src, _Ns);
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	  _S_memcpy<_Bytes - _Ns>(__dst + _Ns, __src + _Ns);
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	}
          .         .        .                  .           .    .           .           .    .  .   .  .   .      }
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .    template <size_t _ReqBytes = 0, typename _TV>
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _GLIBCXX_SIMD_INTRINSIC static void
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _S_store(_TV __x, void* __addr)
          .         .        .                  .           .    .           .           .    .  .   .  .   .      {
-- line 1176 ----------------------------------------
-- line 1540 ----------------------------------------
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	// just as good a choice as pcmpeqd & psign. So meh.
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	return -__x._M_data;
          .         .        .                  .           .    .           .           .    .  .   .  .   .        }
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .      // arithmetic operators {{{2
          .         .        .                  .           .    .           .           .    .  .   .  .   .      template <typename _Tp, size_t _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _S_plus(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
460,231,872 (0.4%)  0        0        230,115,936 (0.7%)    0    0           0           0    0  0   0  0   0        { return __x._M_data + __y._M_data; }
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .      template <typename _Tp, size_t _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _S_minus(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
460,231,872 (0.4%)  0        0        230,115,936 (0.7%)    0    0           0           0    0  0   0  0   0        { return __x._M_data - __y._M_data; }
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .      template <typename _Tp, size_t _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _S_multiplies(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
460,231,872 (0.4%)  0        0                  0           0    0           0           0    0  0   0  0   0        { return __x._M_data * __y._M_data; }
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .      template <typename _Tp, size_t _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _GLIBCXX_SIMD_INTRINSIC static constexpr _SimdWrapper<_Tp, _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _S_divides(_SimdWrapper<_Tp, _Np> __x, _SimdWrapper<_Tp, _Np> __y)
          .         .        .                  .           .    .           .           .    .  .   .  .   .        {
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	// Note that division by 0 is always UB, so we must ensure we avoid the
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	// case for partial registers
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	if constexpr (!_Abi::template _S_is_partial<_Tp>)
-- line 1566 ----------------------------------------
-- line 1908 ----------------------------------------
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	});
          .         .        .                  .           .    .           .           .    .  .   .  .   .        }
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .      // copysign in simd_math.h
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _GLIBCXX_SIMD_MATH_FALLBACK(nextafter)
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _GLIBCXX_SIMD_MATH_FALLBACK(fdim)
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _GLIBCXX_SIMD_MATH_FALLBACK(fmax)
          .         .        .                  .           .    .           .           .    .  .   .  .   .      _GLIBCXX_SIMD_MATH_FALLBACK(fmin)
230,115,936 (0.2%)  0        0                  0           0    0           0           0    0  0   0  0   0      _GLIBCXX_SIMD_MATH_FALLBACK(fma)
          .         .        .                  .           .    .           .           .    .  .   .  .   .  
          .         .        .                  .           .    .           .           .    .  .   .  .   .      template <typename _Tp, size_t _Np>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        static constexpr _MaskMember<_Tp>
          .         .        .                  .           .    .           .           .    .  .   .  .   .        _S_isgreater(_SimdWrapper<_Tp, _Np> __x,
          .         .        .                  .           .    .           .           .    .  .   .  .   .  		   _SimdWrapper<_Tp, _Np> __y) noexcept
          .         .        .                  .           .    .           .           .    .  .   .  .   .        {
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	using _Ip = __int_for_sizeof_t<_Tp>;
          .         .        .                  .           .    .           .           .    .  .   .  .   .  	const auto __xn = __vector_bitcast<_Ip>(__x);
-- line 1924 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/experimental/bits/simd_x86.h
--------------------------------------------------------------------------------
Ir________________ I1mr_____ ILmr____ Dr________________ D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim 

-- line 1320 ----------------------------------------
          .         .        .                  .           .    .  .    .    .  .   .  .   .      // _S_multiplies {{{
          .         .        .                  .           .    .  .    .    .  .   .  .   .      template <typename _V, typename _VVT = _VectorTraits<_V>>
          .         .        .                  .           .    .  .    .    .  .   .  .   .        _GLIBCXX_SIMD_INTRINSIC static constexpr _V
          .         .        .                  .           .    .  .    .    .  .   .  .   .        _S_multiplies(_V __x, _V __y)
          .         .        .                  .           .    .  .    .    .  .   .  .   .        {
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	using _Tp = typename _VVT::value_type;
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	if (__builtin_is_constant_evaluated() || __x._M_is_constprop()
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	    || __y._M_is_constprop())
230,115,936 (0.2%) 58 (0.0%) 1 (0.0%) 230,115,936 (0.7%)    0    0  0    0    0  0   0  0   0  	  return __as_vector(__x) * __as_vector(__y);
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	else if constexpr (sizeof(_Tp) == 1)
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	  {
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	    if constexpr (sizeof(_V) == 2)
          .         .        .                  .           .    .  .    .    .  .   .  .   .  	      {
          .         .        .                  .           .    .  .    .    .  .   .  .   .  		const auto __xs = reinterpret_cast<short>(__x._M_data);
          .         .        .                  .           .    .  .    .    .  .   .  .   .  		const auto __ys = reinterpret_cast<short>(__y._M_data);
          .         .        .                  .           .    .  .    .    .  .   .  .   .  		return reinterpret_cast<__vector_type_t<_Tp, 2>>(short(
          .         .        .                  .           .    .  .    .    .  .   .  .   .  		  ((__xs * __ys) & 0xff) | ((__xs >> 8) * (__ys & 0xff00))));
-- line 1336 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /usr/include/c++/14/span
--------------------------------------------------------------------------------
Ir________________ I1mr________ ILmr____ Dr_______________ D1mr_____ DLmr Dw_______________ D1mw__________ DLmw Bc______________ Bcm______ Bi Bim 

-- line 80 ----------------------------------------
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	{ return _Extent; }
          .            .        .                 .         .           .          .              .           .         .         .         .   .        };
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .      template<>
          .            .        .                 .         .           .          .              .           .         .         .         .   .        class __extent_storage<dynamic_extent>
          .            .        .                 .         .           .          .              .           .         .         .         .   .        {
          .            .        .                 .         .           .          .              .           .         .         .         .   .        public:
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	constexpr
 41,788,784 (0.0%)   153 (0.1%) 2 (0.0%) 13,366,128 (0.0%)  0           0 20,055,592 (0.2%) 119,097 (0.2%)    0         0         0         0   0  	__extent_storage(size_t __extent) noexcept
  3,368,000 (0.0%)     0        0                 0         0           0          0              0           0         0         0         0   0  	: _M_extent_value(__extent)
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	{ }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	constexpr size_t
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	_M_extent() const noexcept
 30,119,584 (0.0%)   638 (0.5%) 3 (0.1%)  8,368,408 (0.0%)  1 (0.0%)    0  8,369,080 (0.1%)  30,665 (0.0%)    0 6,686,680 (0.0%) 39 (0.0%)  0   0  	{ return this->_M_extent_value; }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .        private:
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	size_t _M_extent_value;
          .            .        .                 .         .           .          .              .           .         .         .         .   .        };
          .            .        .                 .         .           .          .              .           .         .         .         .   .    } // namespace __detail
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .    template<typename _Type, size_t _Extent = dynamic_extent>
          .            .        .                 .         .           .          .              .           .         .         .         .   .      class span
-- line 102 ----------------------------------------
-- line 278 ----------------------------------------
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	__glibcxx_assert(!empty());
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	return *(this->_M_ptr + (size() - 1));
          .            .        .                 .         .           .          .              .           .         .         .         .   .        }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[nodiscard]]
          .            .        .                 .         .           .          .              .           .         .         .         .   .        constexpr reference
          .            .        .                 .         .           .          .              .           .         .         .         .   .        operator[](size_type __idx) const noexcept
          .            .        .                 .         .           .          .              .           .         .         .         .   .        {
  8,368,664 (0.0%)     0        0             1,600 (0.0%)  6 (0.0%)    0          0              0           0         0         0         0   0  	__glibcxx_assert(__idx < size());
175,640,932 (0.2%) 3,145 (2.6%) 7 (0.1%) 46,842,076 (0.1%) 48 (0.0%)    0 13,366,128 (0.1%)       4 (0.0%)    0     4,644 (0.0%)  2 (0.0%)  0   0  	return *(this->_M_ptr + __idx);
          .            .        .                 .         .           .          .              .           .         .         .         .   .        }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .  #if __cpp_lib_span >= 202311L // >= C++26
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[nodiscard]]
          .            .        .                 .         .           .          .              .           .         .         .         .   .        constexpr reference
          .            .        .                 .         .           .          .              .           .         .         .         .   .        at(size_type __idx) const
          .            .        .                 .         .           .          .              .           .         .         .         .   .        {
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	if (__idx >= size())
-- line 295 ----------------------------------------
-- line 309 ----------------------------------------
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[nodiscard]]
          .            .        .                 .         .           .          .              .           .         .         .         .   .        constexpr iterator
          .            .        .                 .         .           .          .              .           .         .         .         .   .        begin() const noexcept
          .            .        .                 .         .           .          .              .           .         .         .         .   .        { return iterator(this->_M_ptr); }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[nodiscard]]
          .            .        .                 .         .           .          .              .           .         .         .         .   .        constexpr iterator
          .            .        .                 .         .           .          .              .           .         .         .         .   .        end() const noexcept
 10,104,000 (0.0%)    36 (0.0%) 1 (0.0%)  3,368,000 (0.0%)  0           0  3,368,000 (0.0%)       0           0         0         0         0   0        { return iterator(this->_M_ptr + this->size()); }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[nodiscard]]
          .            .        .                 .         .           .          .              .           .         .         .         .   .        constexpr reverse_iterator
          .            .        .                 .         .           .          .              .           .         .         .         .   .        rbegin() const noexcept
          .            .        .                 .         .           .          .              .           .         .         .         .   .        { return reverse_iterator(this->end()); }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[nodiscard]]
          .            .        .                 .         .           .          .              .           .         .         .         .   .        constexpr reverse_iterator
-- line 325 ----------------------------------------
-- line 433 ----------------------------------------
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	__glibcxx_assert(__offset <= size());
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	if (__count == dynamic_extent)
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	  __count = this->size() - __offset;
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	else
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	  {
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	    __glibcxx_assert(__count <= size());
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	    __glibcxx_assert(__offset + __count <= size());
          .            .        .                 .         .           .          .              .           .         .         .         .   .  	  }
 13,366,128 (0.0%)     0        0                 0         0           0          0              0           0         0         0         0   0  	return {this->data() + __offset, __count};
          .            .        .                 .         .           .          .              .           .         .         .         .   .        }
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .      private:
          .            .        .                 .         .           .          .              .           .         .         .         .   .        pointer _M_ptr;
          .            .        .                 .         .           .          .              .           .         .         .         .   .        [[no_unique_address]] __detail::__extent_storage<extent> _M_extent;
          .            .        .                 .         .           .          .              .           .         .         .         .   .      };
          .            .        .                 .         .           .          .              .           .         .         .         .   .  
          .            .        .                 .         .           .          .              .           .         .         .         .   .    // deduction guides
-- line 449 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir____________________ I1mr__________ ILmr_________ Dr____________________ D1mr______________ DLmr__________ Dw___________________ D1mw______________ DLmw___________ Bc___________________ Bcm________________ Bi___________________ Bim________________ 

55,584,326,785 (52.9%) 42,821 (35.0%)   506  (8.8%) 19,662,149,147 (56.7%) 33,483,712 (87.4%)    260  (1.4%) 6,556,188,931 (63.6%) 57,926,981 (77.2%)   1,499  (0.8%) 6,978,449,190 (52.1%) 137,764,516 (97.1%)    16,734,128  (1.0%)         12   (0.0%)    annotated: files known & above threshold & readable, line numbers known
             0              0             0                      0                  0              0                     0                  0               0                     0                   0                     0                  0             annotated: files known & above threshold & readable, line numbers unknown
             0              0             0                      0                  0              0                     0                  0               0                     0                   0                     0                  0           unannotated: files known & above threshold & two or more non-identical
44,435,278,587 (42.3%)    856  (0.7%)    30  (0.5%) 12,662,637,077 (36.5%)  3,992,117 (10.4%)     62  (0.3%) 3,653,036,188 (35.4%) 17,108,890 (22.8%) 164,914 (86.0%) 5,607,173,509 (41.9%)   3,457,070  (2.4%)             0                  0           unannotated: files known & above threshold & unreadable 
   681,981,652  (0.6%) 60,253 (49.3%) 4,218 (73.5%)    296,034,689  (0.9%)    362,096  (0.9%) 18,434 (98.0%)    98,416,431  (1.0%)     41,579  (0.1%)  24,638 (12.8%)    48,889,642  (0.4%)     578,719  (0.4%)     6,700,955  (0.4%)      8,032   (0.0%)  unannotated: files known & below threshold
 4,353,092,911  (4.1%) 18,380 (15.0%)   986 (17.2%)  2,062,969,571  (5.9%)    482,406  (1.3%)     46  (0.2%)       137,472  (0.0%)      5,150  (0.0%)     781  (0.4%)   763,221,146  (5.7%)       5,732  (0.0%) 1,681,217,328 (98.6%) 16,763,706 (100.0%)  unannotated: files unknown

