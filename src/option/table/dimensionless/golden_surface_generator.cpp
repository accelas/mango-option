// SPDX-License-Identifier: MIT
//
// Generates golden_surface_data.inc by building the adaptive dimensionless
// surface and printing all grid points and B-spline coefficients as C++ arrays.
//
// Usage:
//   bazel run //src/option/table:golden_surface_generator > src/option/table/golden_surface_data.inc

#include "mango/option/table/dimensionless/dimensionless_builder.hpp"
#include <cstdio>
#include <cstdlib>

static void print_array(const char* name, const double* data, size_t n) {
    std::printf("static constexpr double %s[] = {\n", name);
    for (size_t i = 0; i < n; ++i) {
        if (i % 6 == 0) std::printf("    ");
        std::printf("%.17e", data[i]);
        if (i + 1 < n) std::printf(",");
        if (i % 6 == 5 || i + 1 == n) std::printf("\n");
        else std::printf(" ");
    }
    std::printf("};\n\n");
}

int main() {
    using namespace mango;

    auto result = build_dimensionless_surface_adaptive();
    if (!result.has_value()) {
        std::fprintf(stderr, "Adaptive build failed: code=%d\n",
            static_cast<int>(result.error().code));
        return 1;
    }

    if (!result->target_met) {
        std::fprintf(stderr, "Warning: target not met (max_error=%.6f)\n",
            result->achieved_max_error);
    }

    std::fprintf(stderr, "Built %zu segments, iter=%zu, max_error=%.6f\n",
        result->num_segments, result->iterations_used, result->achieved_max_error);

    const auto& segs = result->surface->segments();

    std::printf("// Auto-generated by golden_surface_generator â€” do not edit.\n");
    std::printf("// Segments: %zu  max_error: %.6f  iterations: %zu\n",
        result->num_segments, result->achieved_max_error, result->iterations_used);
    std::printf("//\n");
    std::printf("// This file is included inside an anonymous namespace in golden_surface.cpp.\n");
    std::printf("// It defines static constexpr arrays for each segment's grid and coefficients.\n\n");

    std::printf("static constexpr size_t kNumSegments = %zu;\n\n", segs.size());

    for (size_t s = 0; s < segs.size(); ++s) {
        const auto& seg = segs[s];
        const auto& ax = seg.surface->axes();
        const auto& coeffs = seg.surface->coefficients();

        char buf[64];

        std::snprintf(buf, sizeof(buf), "kSeg%zuX", s);
        print_array(buf, ax.grids[0].data(), ax.grids[0].size());

        std::snprintf(buf, sizeof(buf), "kSeg%zuTp", s);
        print_array(buf, ax.grids[1].data(), ax.grids[1].size());

        std::snprintf(buf, sizeof(buf), "kSeg%zuLk", s);
        print_array(buf, ax.grids[2].data(), ax.grids[2].size());

        std::snprintf(buf, sizeof(buf), "kSeg%zuCoeffs", s);
        print_array(buf, coeffs.data(), coeffs.size());

        std::printf("static constexpr double kSeg%zuLkMin = %.17e;\n", s, seg.lk_min);
        std::printf("static constexpr double kSeg%zuLkMax = %.17e;\n\n", s, seg.lk_max);

        std::fprintf(stderr, "  seg[%zu]: x=%zu tp=%zu lk=%zu coeffs=%zu lk=[%.3f, %.3f]\n",
            s, ax.grids[0].size(), ax.grids[1].size(), ax.grids[2].size(),
            coeffs.size(), seg.lk_min, seg.lk_max);
    }

    return 0;
}
